
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model assinatura
 * 
 */
export type assinatura = $Result.DefaultSelection<Prisma.$assinaturaPayload>
/**
 * Model historicoPagamento
 * 
 */
export type historicoPagamento = $Result.DefaultSelection<Prisma.$historicoPagamentoPayload>
/**
 * Model planos
 * 
 */
export type planos = $Result.DefaultSelection<Prisma.$planosPayload>
/**
 * Model autenticacao
 * 
 */
export type autenticacao = $Result.DefaultSelection<Prisma.$autenticacaoPayload>
/**
 * Model contas
 * 
 */
export type contas = $Result.DefaultSelection<Prisma.$contasPayload>
/**
 * Model questionario
 * 
 */
export type questionario = $Result.DefaultSelection<Prisma.$questionarioPayload>
/**
 * Model geral
 * 
 */
export type geral = $Result.DefaultSelection<Prisma.$geralPayload>
/**
 * Model grupos
 * 
 */
export type grupos = $Result.DefaultSelection<Prisma.$gruposPayload>
/**
 * Model grupoConta
 * 
 */
export type grupoConta = $Result.DefaultSelection<Prisma.$grupoContaPayload>
/**
 * Model datas
 * 
 */
export type datas = $Result.DefaultSelection<Prisma.$datasPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const tipoFuncionalidade: {
  Nutricao: 'Nutricao',
  Tabaquismo: 'Tabaquismo'
};

export type tipoFuncionalidade = (typeof tipoFuncionalidade)[keyof typeof tipoFuncionalidade]


export const tipoPlano: {
  Individual: 'Individual',
  Grupo: 'Grupo',
  Mentoria: 'Mentoria'
};

export type tipoPlano = (typeof tipoPlano)[keyof typeof tipoPlano]


export const contas_perfil: {
  Admin: 'Admin',
  Usuario: 'Usuario',
  Nutricionista: 'Nutricionista'
};

export type contas_perfil = (typeof contas_perfil)[keyof typeof contas_perfil]


export const dias: {
  Segunda: 'Segunda',
  Terca: 'Terca',
  Quarta: 'Quarta',
  Quinta: 'Quinta',
  Sexta: 'Sexta',
  Sabado: 'Sabado',
  Domingo: 'Domingo'
};

export type dias = (typeof dias)[keyof typeof dias]

}

export type tipoFuncionalidade = $Enums.tipoFuncionalidade

export const tipoFuncionalidade: typeof $Enums.tipoFuncionalidade

export type tipoPlano = $Enums.tipoPlano

export const tipoPlano: typeof $Enums.tipoPlano

export type contas_perfil = $Enums.contas_perfil

export const contas_perfil: typeof $Enums.contas_perfil

export type dias = $Enums.dias

export const dias: typeof $Enums.dias

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Assinaturas
 * const assinaturas = await prisma.assinatura.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Assinaturas
   * const assinaturas = await prisma.assinatura.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.assinatura`: Exposes CRUD operations for the **assinatura** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assinaturas
    * const assinaturas = await prisma.assinatura.findMany()
    * ```
    */
  get assinatura(): Prisma.assinaturaDelegate<ExtArgs>;

  /**
   * `prisma.historicoPagamento`: Exposes CRUD operations for the **historicoPagamento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HistoricoPagamentos
    * const historicoPagamentos = await prisma.historicoPagamento.findMany()
    * ```
    */
  get historicoPagamento(): Prisma.historicoPagamentoDelegate<ExtArgs>;

  /**
   * `prisma.planos`: Exposes CRUD operations for the **planos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Planos
    * const planos = await prisma.planos.findMany()
    * ```
    */
  get planos(): Prisma.planosDelegate<ExtArgs>;

  /**
   * `prisma.autenticacao`: Exposes CRUD operations for the **autenticacao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Autenticacaos
    * const autenticacaos = await prisma.autenticacao.findMany()
    * ```
    */
  get autenticacao(): Prisma.autenticacaoDelegate<ExtArgs>;

  /**
   * `prisma.contas`: Exposes CRUD operations for the **contas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contas
    * const contas = await prisma.contas.findMany()
    * ```
    */
  get contas(): Prisma.contasDelegate<ExtArgs>;

  /**
   * `prisma.questionario`: Exposes CRUD operations for the **questionario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questionarios
    * const questionarios = await prisma.questionario.findMany()
    * ```
    */
  get questionario(): Prisma.questionarioDelegate<ExtArgs>;

  /**
   * `prisma.geral`: Exposes CRUD operations for the **geral** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gerals
    * const gerals = await prisma.geral.findMany()
    * ```
    */
  get geral(): Prisma.geralDelegate<ExtArgs>;

  /**
   * `prisma.grupos`: Exposes CRUD operations for the **grupos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Grupos
    * const grupos = await prisma.grupos.findMany()
    * ```
    */
  get grupos(): Prisma.gruposDelegate<ExtArgs>;

  /**
   * `prisma.grupoConta`: Exposes CRUD operations for the **grupoConta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GrupoContas
    * const grupoContas = await prisma.grupoConta.findMany()
    * ```
    */
  get grupoConta(): Prisma.grupoContaDelegate<ExtArgs>;

  /**
   * `prisma.datas`: Exposes CRUD operations for the **datas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Datas
    * const datas = await prisma.datas.findMany()
    * ```
    */
  get datas(): Prisma.datasDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.10.2
   * Query Engine version: 5a9203d0590c951969e85a7d07215503f4672eb9
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    assinatura: 'assinatura',
    historicoPagamento: 'historicoPagamento',
    planos: 'planos',
    autenticacao: 'autenticacao',
    contas: 'contas',
    questionario: 'questionario',
    geral: 'geral',
    grupos: 'grupos',
    grupoConta: 'grupoConta',
    datas: 'datas'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'assinatura' | 'historicoPagamento' | 'planos' | 'autenticacao' | 'contas' | 'questionario' | 'geral' | 'grupos' | 'grupoConta' | 'datas'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      assinatura: {
        payload: Prisma.$assinaturaPayload<ExtArgs>
        fields: Prisma.assinaturaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.assinaturaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$assinaturaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.assinaturaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$assinaturaPayload>
          }
          findFirst: {
            args: Prisma.assinaturaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$assinaturaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.assinaturaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$assinaturaPayload>
          }
          findMany: {
            args: Prisma.assinaturaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$assinaturaPayload>[]
          }
          create: {
            args: Prisma.assinaturaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$assinaturaPayload>
          }
          createMany: {
            args: Prisma.assinaturaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.assinaturaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$assinaturaPayload>
          }
          update: {
            args: Prisma.assinaturaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$assinaturaPayload>
          }
          deleteMany: {
            args: Prisma.assinaturaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.assinaturaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.assinaturaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$assinaturaPayload>
          }
          aggregate: {
            args: Prisma.AssinaturaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAssinatura>
          }
          groupBy: {
            args: Prisma.assinaturaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AssinaturaGroupByOutputType>[]
          }
          count: {
            args: Prisma.assinaturaCountArgs<ExtArgs>,
            result: $Utils.Optional<AssinaturaCountAggregateOutputType> | number
          }
        }
      }
      historicoPagamento: {
        payload: Prisma.$historicoPagamentoPayload<ExtArgs>
        fields: Prisma.historicoPagamentoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.historicoPagamentoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$historicoPagamentoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.historicoPagamentoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$historicoPagamentoPayload>
          }
          findFirst: {
            args: Prisma.historicoPagamentoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$historicoPagamentoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.historicoPagamentoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$historicoPagamentoPayload>
          }
          findMany: {
            args: Prisma.historicoPagamentoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$historicoPagamentoPayload>[]
          }
          create: {
            args: Prisma.historicoPagamentoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$historicoPagamentoPayload>
          }
          createMany: {
            args: Prisma.historicoPagamentoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.historicoPagamentoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$historicoPagamentoPayload>
          }
          update: {
            args: Prisma.historicoPagamentoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$historicoPagamentoPayload>
          }
          deleteMany: {
            args: Prisma.historicoPagamentoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.historicoPagamentoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.historicoPagamentoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$historicoPagamentoPayload>
          }
          aggregate: {
            args: Prisma.HistoricoPagamentoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateHistoricoPagamento>
          }
          groupBy: {
            args: Prisma.historicoPagamentoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<HistoricoPagamentoGroupByOutputType>[]
          }
          count: {
            args: Prisma.historicoPagamentoCountArgs<ExtArgs>,
            result: $Utils.Optional<HistoricoPagamentoCountAggregateOutputType> | number
          }
        }
      }
      planos: {
        payload: Prisma.$planosPayload<ExtArgs>
        fields: Prisma.planosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.planosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$planosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.planosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$planosPayload>
          }
          findFirst: {
            args: Prisma.planosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$planosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.planosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$planosPayload>
          }
          findMany: {
            args: Prisma.planosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$planosPayload>[]
          }
          create: {
            args: Prisma.planosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$planosPayload>
          }
          createMany: {
            args: Prisma.planosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.planosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$planosPayload>
          }
          update: {
            args: Prisma.planosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$planosPayload>
          }
          deleteMany: {
            args: Prisma.planosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.planosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.planosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$planosPayload>
          }
          aggregate: {
            args: Prisma.PlanosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePlanos>
          }
          groupBy: {
            args: Prisma.planosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PlanosGroupByOutputType>[]
          }
          count: {
            args: Prisma.planosCountArgs<ExtArgs>,
            result: $Utils.Optional<PlanosCountAggregateOutputType> | number
          }
        }
      }
      autenticacao: {
        payload: Prisma.$autenticacaoPayload<ExtArgs>
        fields: Prisma.autenticacaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.autenticacaoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$autenticacaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.autenticacaoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$autenticacaoPayload>
          }
          findFirst: {
            args: Prisma.autenticacaoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$autenticacaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.autenticacaoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$autenticacaoPayload>
          }
          findMany: {
            args: Prisma.autenticacaoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$autenticacaoPayload>[]
          }
          create: {
            args: Prisma.autenticacaoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$autenticacaoPayload>
          }
          createMany: {
            args: Prisma.autenticacaoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.autenticacaoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$autenticacaoPayload>
          }
          update: {
            args: Prisma.autenticacaoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$autenticacaoPayload>
          }
          deleteMany: {
            args: Prisma.autenticacaoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.autenticacaoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.autenticacaoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$autenticacaoPayload>
          }
          aggregate: {
            args: Prisma.AutenticacaoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAutenticacao>
          }
          groupBy: {
            args: Prisma.autenticacaoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AutenticacaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.autenticacaoCountArgs<ExtArgs>,
            result: $Utils.Optional<AutenticacaoCountAggregateOutputType> | number
          }
        }
      }
      contas: {
        payload: Prisma.$contasPayload<ExtArgs>
        fields: Prisma.contasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.contasFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.contasFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contasPayload>
          }
          findFirst: {
            args: Prisma.contasFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.contasFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contasPayload>
          }
          findMany: {
            args: Prisma.contasFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contasPayload>[]
          }
          create: {
            args: Prisma.contasCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contasPayload>
          }
          createMany: {
            args: Prisma.contasCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.contasDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contasPayload>
          }
          update: {
            args: Prisma.contasUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contasPayload>
          }
          deleteMany: {
            args: Prisma.contasDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.contasUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.contasUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contasPayload>
          }
          aggregate: {
            args: Prisma.ContasAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateContas>
          }
          groupBy: {
            args: Prisma.contasGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ContasGroupByOutputType>[]
          }
          count: {
            args: Prisma.contasCountArgs<ExtArgs>,
            result: $Utils.Optional<ContasCountAggregateOutputType> | number
          }
        }
      }
      questionario: {
        payload: Prisma.$questionarioPayload<ExtArgs>
        fields: Prisma.questionarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.questionarioFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$questionarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.questionarioFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$questionarioPayload>
          }
          findFirst: {
            args: Prisma.questionarioFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$questionarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.questionarioFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$questionarioPayload>
          }
          findMany: {
            args: Prisma.questionarioFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$questionarioPayload>[]
          }
          create: {
            args: Prisma.questionarioCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$questionarioPayload>
          }
          createMany: {
            args: Prisma.questionarioCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.questionarioDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$questionarioPayload>
          }
          update: {
            args: Prisma.questionarioUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$questionarioPayload>
          }
          deleteMany: {
            args: Prisma.questionarioDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.questionarioUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.questionarioUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$questionarioPayload>
          }
          aggregate: {
            args: Prisma.QuestionarioAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateQuestionario>
          }
          groupBy: {
            args: Prisma.questionarioGroupByArgs<ExtArgs>,
            result: $Utils.Optional<QuestionarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.questionarioCountArgs<ExtArgs>,
            result: $Utils.Optional<QuestionarioCountAggregateOutputType> | number
          }
        }
      }
      geral: {
        payload: Prisma.$geralPayload<ExtArgs>
        fields: Prisma.geralFieldRefs
        operations: {
          findUnique: {
            args: Prisma.geralFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$geralPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.geralFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$geralPayload>
          }
          findFirst: {
            args: Prisma.geralFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$geralPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.geralFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$geralPayload>
          }
          findMany: {
            args: Prisma.geralFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$geralPayload>[]
          }
          create: {
            args: Prisma.geralCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$geralPayload>
          }
          createMany: {
            args: Prisma.geralCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.geralDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$geralPayload>
          }
          update: {
            args: Prisma.geralUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$geralPayload>
          }
          deleteMany: {
            args: Prisma.geralDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.geralUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.geralUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$geralPayload>
          }
          aggregate: {
            args: Prisma.GeralAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGeral>
          }
          groupBy: {
            args: Prisma.geralGroupByArgs<ExtArgs>,
            result: $Utils.Optional<GeralGroupByOutputType>[]
          }
          count: {
            args: Prisma.geralCountArgs<ExtArgs>,
            result: $Utils.Optional<GeralCountAggregateOutputType> | number
          }
        }
      }
      grupos: {
        payload: Prisma.$gruposPayload<ExtArgs>
        fields: Prisma.gruposFieldRefs
        operations: {
          findUnique: {
            args: Prisma.gruposFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$gruposPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.gruposFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$gruposPayload>
          }
          findFirst: {
            args: Prisma.gruposFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$gruposPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.gruposFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$gruposPayload>
          }
          findMany: {
            args: Prisma.gruposFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$gruposPayload>[]
          }
          create: {
            args: Prisma.gruposCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$gruposPayload>
          }
          createMany: {
            args: Prisma.gruposCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.gruposDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$gruposPayload>
          }
          update: {
            args: Prisma.gruposUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$gruposPayload>
          }
          deleteMany: {
            args: Prisma.gruposDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.gruposUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.gruposUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$gruposPayload>
          }
          aggregate: {
            args: Prisma.GruposAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGrupos>
          }
          groupBy: {
            args: Prisma.gruposGroupByArgs<ExtArgs>,
            result: $Utils.Optional<GruposGroupByOutputType>[]
          }
          count: {
            args: Prisma.gruposCountArgs<ExtArgs>,
            result: $Utils.Optional<GruposCountAggregateOutputType> | number
          }
        }
      }
      grupoConta: {
        payload: Prisma.$grupoContaPayload<ExtArgs>
        fields: Prisma.grupoContaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.grupoContaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$grupoContaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.grupoContaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$grupoContaPayload>
          }
          findFirst: {
            args: Prisma.grupoContaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$grupoContaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.grupoContaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$grupoContaPayload>
          }
          findMany: {
            args: Prisma.grupoContaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$grupoContaPayload>[]
          }
          create: {
            args: Prisma.grupoContaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$grupoContaPayload>
          }
          createMany: {
            args: Prisma.grupoContaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.grupoContaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$grupoContaPayload>
          }
          update: {
            args: Prisma.grupoContaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$grupoContaPayload>
          }
          deleteMany: {
            args: Prisma.grupoContaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.grupoContaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.grupoContaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$grupoContaPayload>
          }
          aggregate: {
            args: Prisma.GrupoContaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGrupoConta>
          }
          groupBy: {
            args: Prisma.grupoContaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<GrupoContaGroupByOutputType>[]
          }
          count: {
            args: Prisma.grupoContaCountArgs<ExtArgs>,
            result: $Utils.Optional<GrupoContaCountAggregateOutputType> | number
          }
        }
      }
      datas: {
        payload: Prisma.$datasPayload<ExtArgs>
        fields: Prisma.datasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.datasFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$datasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.datasFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$datasPayload>
          }
          findFirst: {
            args: Prisma.datasFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$datasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.datasFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$datasPayload>
          }
          findMany: {
            args: Prisma.datasFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$datasPayload>[]
          }
          create: {
            args: Prisma.datasCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$datasPayload>
          }
          createMany: {
            args: Prisma.datasCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.datasDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$datasPayload>
          }
          update: {
            args: Prisma.datasUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$datasPayload>
          }
          deleteMany: {
            args: Prisma.datasDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.datasUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.datasUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$datasPayload>
          }
          aggregate: {
            args: Prisma.DatasAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDatas>
          }
          groupBy: {
            args: Prisma.datasGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DatasGroupByOutputType>[]
          }
          count: {
            args: Prisma.datasCountArgs<ExtArgs>,
            result: $Utils.Optional<DatasCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PlanosCountOutputType
   */

  export type PlanosCountOutputType = {
    assinatura: number
    grupos: number
  }

  export type PlanosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assinatura?: boolean | PlanosCountOutputTypeCountAssinaturaArgs
    grupos?: boolean | PlanosCountOutputTypeCountGruposArgs
  }

  // Custom InputTypes

  /**
   * PlanosCountOutputType without action
   */
  export type PlanosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanosCountOutputType
     */
    select?: PlanosCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PlanosCountOutputType without action
   */
  export type PlanosCountOutputTypeCountAssinaturaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: assinaturaWhereInput
  }


  /**
   * PlanosCountOutputType without action
   */
  export type PlanosCountOutputTypeCountGruposArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gruposWhereInput
  }



  /**
   * Count Type ContasCountOutputType
   */

  export type ContasCountOutputType = {
    autenticacao: number
    historicoPagamento: number
    assinaturas: number
  }

  export type ContasCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    autenticacao?: boolean | ContasCountOutputTypeCountAutenticacaoArgs
    historicoPagamento?: boolean | ContasCountOutputTypeCountHistoricoPagamentoArgs
    assinaturas?: boolean | ContasCountOutputTypeCountAssinaturasArgs
  }

  // Custom InputTypes

  /**
   * ContasCountOutputType without action
   */
  export type ContasCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContasCountOutputType
     */
    select?: ContasCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ContasCountOutputType without action
   */
  export type ContasCountOutputTypeCountAutenticacaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: autenticacaoWhereInput
  }


  /**
   * ContasCountOutputType without action
   */
  export type ContasCountOutputTypeCountHistoricoPagamentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: historicoPagamentoWhereInput
  }


  /**
   * ContasCountOutputType without action
   */
  export type ContasCountOutputTypeCountAssinaturasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: assinaturaWhereInput
  }



  /**
   * Count Type QuestionarioCountOutputType
   */

  export type QuestionarioCountOutputType = {
    contas: number
  }

  export type QuestionarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contas?: boolean | QuestionarioCountOutputTypeCountContasArgs
  }

  // Custom InputTypes

  /**
   * QuestionarioCountOutputType without action
   */
  export type QuestionarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionarioCountOutputType
     */
    select?: QuestionarioCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * QuestionarioCountOutputType without action
   */
  export type QuestionarioCountOutputTypeCountContasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contasWhereInput
  }



  /**
   * Count Type GruposCountOutputType
   */

  export type GruposCountOutputType = {
    datas: number
  }

  export type GruposCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    datas?: boolean | GruposCountOutputTypeCountDatasArgs
  }

  // Custom InputTypes

  /**
   * GruposCountOutputType without action
   */
  export type GruposCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GruposCountOutputType
     */
    select?: GruposCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * GruposCountOutputType without action
   */
  export type GruposCountOutputTypeCountDatasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: datasWhereInput
  }



  /**
   * Models
   */

  /**
   * Model assinatura
   */

  export type AggregateAssinatura = {
    _count: AssinaturaCountAggregateOutputType | null
    _avg: AssinaturaAvgAggregateOutputType | null
    _sum: AssinaturaSumAggregateOutputType | null
    _min: AssinaturaMinAggregateOutputType | null
    _max: AssinaturaMaxAggregateOutputType | null
  }

  export type AssinaturaAvgAggregateOutputType = {
    idAssinatura: number | null
    idPlanos: number | null
    idConta: number | null
  }

  export type AssinaturaSumAggregateOutputType = {
    idAssinatura: number | null
    idPlanos: number | null
    idConta: number | null
  }

  export type AssinaturaMinAggregateOutputType = {
    idAssinatura: number | null
    codPagamento: string | null
    ativo: boolean | null
    data_inicio: Date | null
    ultimo_update: Date | null
    idPlanos: number | null
    idConta: number | null
  }

  export type AssinaturaMaxAggregateOutputType = {
    idAssinatura: number | null
    codPagamento: string | null
    ativo: boolean | null
    data_inicio: Date | null
    ultimo_update: Date | null
    idPlanos: number | null
    idConta: number | null
  }

  export type AssinaturaCountAggregateOutputType = {
    idAssinatura: number
    codPagamento: number
    ativo: number
    data_inicio: number
    ultimo_update: number
    idPlanos: number
    idConta: number
    _all: number
  }


  export type AssinaturaAvgAggregateInputType = {
    idAssinatura?: true
    idPlanos?: true
    idConta?: true
  }

  export type AssinaturaSumAggregateInputType = {
    idAssinatura?: true
    idPlanos?: true
    idConta?: true
  }

  export type AssinaturaMinAggregateInputType = {
    idAssinatura?: true
    codPagamento?: true
    ativo?: true
    data_inicio?: true
    ultimo_update?: true
    idPlanos?: true
    idConta?: true
  }

  export type AssinaturaMaxAggregateInputType = {
    idAssinatura?: true
    codPagamento?: true
    ativo?: true
    data_inicio?: true
    ultimo_update?: true
    idPlanos?: true
    idConta?: true
  }

  export type AssinaturaCountAggregateInputType = {
    idAssinatura?: true
    codPagamento?: true
    ativo?: true
    data_inicio?: true
    ultimo_update?: true
    idPlanos?: true
    idConta?: true
    _all?: true
  }

  export type AssinaturaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which assinatura to aggregate.
     */
    where?: assinaturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assinaturas to fetch.
     */
    orderBy?: assinaturaOrderByWithRelationInput | assinaturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: assinaturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assinaturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assinaturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned assinaturas
    **/
    _count?: true | AssinaturaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssinaturaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssinaturaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssinaturaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssinaturaMaxAggregateInputType
  }

  export type GetAssinaturaAggregateType<T extends AssinaturaAggregateArgs> = {
        [P in keyof T & keyof AggregateAssinatura]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssinatura[P]>
      : GetScalarType<T[P], AggregateAssinatura[P]>
  }




  export type assinaturaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: assinaturaWhereInput
    orderBy?: assinaturaOrderByWithAggregationInput | assinaturaOrderByWithAggregationInput[]
    by: AssinaturaScalarFieldEnum[] | AssinaturaScalarFieldEnum
    having?: assinaturaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssinaturaCountAggregateInputType | true
    _avg?: AssinaturaAvgAggregateInputType
    _sum?: AssinaturaSumAggregateInputType
    _min?: AssinaturaMinAggregateInputType
    _max?: AssinaturaMaxAggregateInputType
  }

  export type AssinaturaGroupByOutputType = {
    idAssinatura: number
    codPagamento: string | null
    ativo: boolean | null
    data_inicio: Date | null
    ultimo_update: Date | null
    idPlanos: number
    idConta: number
    _count: AssinaturaCountAggregateOutputType | null
    _avg: AssinaturaAvgAggregateOutputType | null
    _sum: AssinaturaSumAggregateOutputType | null
    _min: AssinaturaMinAggregateOutputType | null
    _max: AssinaturaMaxAggregateOutputType | null
  }

  type GetAssinaturaGroupByPayload<T extends assinaturaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssinaturaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssinaturaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssinaturaGroupByOutputType[P]>
            : GetScalarType<T[P], AssinaturaGroupByOutputType[P]>
        }
      >
    >


  export type assinaturaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idAssinatura?: boolean
    codPagamento?: boolean
    ativo?: boolean
    data_inicio?: boolean
    ultimo_update?: boolean
    idPlanos?: boolean
    idConta?: boolean
    planos?: boolean | planosDefaultArgs<ExtArgs>
    contas?: boolean | contasDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assinatura"]>

  export type assinaturaSelectScalar = {
    idAssinatura?: boolean
    codPagamento?: boolean
    ativo?: boolean
    data_inicio?: boolean
    ultimo_update?: boolean
    idPlanos?: boolean
    idConta?: boolean
  }

  export type assinaturaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planos?: boolean | planosDefaultArgs<ExtArgs>
    contas?: boolean | contasDefaultArgs<ExtArgs>
  }


  export type $assinaturaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "assinatura"
    objects: {
      planos: Prisma.$planosPayload<ExtArgs>
      contas: Prisma.$contasPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idAssinatura: number
      codPagamento: string | null
      ativo: boolean | null
      data_inicio: Date | null
      ultimo_update: Date | null
      idPlanos: number
      idConta: number
    }, ExtArgs["result"]["assinatura"]>
    composites: {}
  }


  type assinaturaGetPayload<S extends boolean | null | undefined | assinaturaDefaultArgs> = $Result.GetResult<Prisma.$assinaturaPayload, S>

  type assinaturaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<assinaturaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AssinaturaCountAggregateInputType | true
    }

  export interface assinaturaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['assinatura'], meta: { name: 'assinatura' } }
    /**
     * Find zero or one Assinatura that matches the filter.
     * @param {assinaturaFindUniqueArgs} args - Arguments to find a Assinatura
     * @example
     * // Get one Assinatura
     * const assinatura = await prisma.assinatura.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends assinaturaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, assinaturaFindUniqueArgs<ExtArgs>>
    ): Prisma__assinaturaClient<$Result.GetResult<Prisma.$assinaturaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Assinatura that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {assinaturaFindUniqueOrThrowArgs} args - Arguments to find a Assinatura
     * @example
     * // Get one Assinatura
     * const assinatura = await prisma.assinatura.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends assinaturaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, assinaturaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__assinaturaClient<$Result.GetResult<Prisma.$assinaturaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Assinatura that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assinaturaFindFirstArgs} args - Arguments to find a Assinatura
     * @example
     * // Get one Assinatura
     * const assinatura = await prisma.assinatura.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends assinaturaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, assinaturaFindFirstArgs<ExtArgs>>
    ): Prisma__assinaturaClient<$Result.GetResult<Prisma.$assinaturaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Assinatura that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assinaturaFindFirstOrThrowArgs} args - Arguments to find a Assinatura
     * @example
     * // Get one Assinatura
     * const assinatura = await prisma.assinatura.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends assinaturaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, assinaturaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__assinaturaClient<$Result.GetResult<Prisma.$assinaturaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Assinaturas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assinaturaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assinaturas
     * const assinaturas = await prisma.assinatura.findMany()
     * 
     * // Get first 10 Assinaturas
     * const assinaturas = await prisma.assinatura.findMany({ take: 10 })
     * 
     * // Only select the `idAssinatura`
     * const assinaturaWithIdAssinaturaOnly = await prisma.assinatura.findMany({ select: { idAssinatura: true } })
     * 
    **/
    findMany<T extends assinaturaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, assinaturaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$assinaturaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Assinatura.
     * @param {assinaturaCreateArgs} args - Arguments to create a Assinatura.
     * @example
     * // Create one Assinatura
     * const Assinatura = await prisma.assinatura.create({
     *   data: {
     *     // ... data to create a Assinatura
     *   }
     * })
     * 
    **/
    create<T extends assinaturaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, assinaturaCreateArgs<ExtArgs>>
    ): Prisma__assinaturaClient<$Result.GetResult<Prisma.$assinaturaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Assinaturas.
     *     @param {assinaturaCreateManyArgs} args - Arguments to create many Assinaturas.
     *     @example
     *     // Create many Assinaturas
     *     const assinatura = await prisma.assinatura.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends assinaturaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, assinaturaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Assinatura.
     * @param {assinaturaDeleteArgs} args - Arguments to delete one Assinatura.
     * @example
     * // Delete one Assinatura
     * const Assinatura = await prisma.assinatura.delete({
     *   where: {
     *     // ... filter to delete one Assinatura
     *   }
     * })
     * 
    **/
    delete<T extends assinaturaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, assinaturaDeleteArgs<ExtArgs>>
    ): Prisma__assinaturaClient<$Result.GetResult<Prisma.$assinaturaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Assinatura.
     * @param {assinaturaUpdateArgs} args - Arguments to update one Assinatura.
     * @example
     * // Update one Assinatura
     * const assinatura = await prisma.assinatura.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends assinaturaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, assinaturaUpdateArgs<ExtArgs>>
    ): Prisma__assinaturaClient<$Result.GetResult<Prisma.$assinaturaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Assinaturas.
     * @param {assinaturaDeleteManyArgs} args - Arguments to filter Assinaturas to delete.
     * @example
     * // Delete a few Assinaturas
     * const { count } = await prisma.assinatura.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends assinaturaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, assinaturaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assinaturas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assinaturaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assinaturas
     * const assinatura = await prisma.assinatura.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends assinaturaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, assinaturaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Assinatura.
     * @param {assinaturaUpsertArgs} args - Arguments to update or create a Assinatura.
     * @example
     * // Update or create a Assinatura
     * const assinatura = await prisma.assinatura.upsert({
     *   create: {
     *     // ... data to create a Assinatura
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Assinatura we want to update
     *   }
     * })
    **/
    upsert<T extends assinaturaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, assinaturaUpsertArgs<ExtArgs>>
    ): Prisma__assinaturaClient<$Result.GetResult<Prisma.$assinaturaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Assinaturas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assinaturaCountArgs} args - Arguments to filter Assinaturas to count.
     * @example
     * // Count the number of Assinaturas
     * const count = await prisma.assinatura.count({
     *   where: {
     *     // ... the filter for the Assinaturas we want to count
     *   }
     * })
    **/
    count<T extends assinaturaCountArgs>(
      args?: Subset<T, assinaturaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssinaturaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Assinatura.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssinaturaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssinaturaAggregateArgs>(args: Subset<T, AssinaturaAggregateArgs>): Prisma.PrismaPromise<GetAssinaturaAggregateType<T>>

    /**
     * Group by Assinatura.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assinaturaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends assinaturaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: assinaturaGroupByArgs['orderBy'] }
        : { orderBy?: assinaturaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, assinaturaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssinaturaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the assinatura model
   */
  readonly fields: assinaturaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for assinatura.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__assinaturaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    planos<T extends planosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, planosDefaultArgs<ExtArgs>>): Prisma__planosClient<$Result.GetResult<Prisma.$planosPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    contas<T extends contasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, contasDefaultArgs<ExtArgs>>): Prisma__contasClient<$Result.GetResult<Prisma.$contasPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the assinatura model
   */ 
  interface assinaturaFieldRefs {
    readonly idAssinatura: FieldRef<"assinatura", 'Int'>
    readonly codPagamento: FieldRef<"assinatura", 'String'>
    readonly ativo: FieldRef<"assinatura", 'Boolean'>
    readonly data_inicio: FieldRef<"assinatura", 'DateTime'>
    readonly ultimo_update: FieldRef<"assinatura", 'DateTime'>
    readonly idPlanos: FieldRef<"assinatura", 'Int'>
    readonly idConta: FieldRef<"assinatura", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * assinatura findUnique
   */
  export type assinaturaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assinatura
     */
    select?: assinaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: assinaturaInclude<ExtArgs> | null
    /**
     * Filter, which assinatura to fetch.
     */
    where: assinaturaWhereUniqueInput
  }


  /**
   * assinatura findUniqueOrThrow
   */
  export type assinaturaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assinatura
     */
    select?: assinaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: assinaturaInclude<ExtArgs> | null
    /**
     * Filter, which assinatura to fetch.
     */
    where: assinaturaWhereUniqueInput
  }


  /**
   * assinatura findFirst
   */
  export type assinaturaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assinatura
     */
    select?: assinaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: assinaturaInclude<ExtArgs> | null
    /**
     * Filter, which assinatura to fetch.
     */
    where?: assinaturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assinaturas to fetch.
     */
    orderBy?: assinaturaOrderByWithRelationInput | assinaturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for assinaturas.
     */
    cursor?: assinaturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assinaturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assinaturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of assinaturas.
     */
    distinct?: AssinaturaScalarFieldEnum | AssinaturaScalarFieldEnum[]
  }


  /**
   * assinatura findFirstOrThrow
   */
  export type assinaturaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assinatura
     */
    select?: assinaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: assinaturaInclude<ExtArgs> | null
    /**
     * Filter, which assinatura to fetch.
     */
    where?: assinaturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assinaturas to fetch.
     */
    orderBy?: assinaturaOrderByWithRelationInput | assinaturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for assinaturas.
     */
    cursor?: assinaturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assinaturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assinaturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of assinaturas.
     */
    distinct?: AssinaturaScalarFieldEnum | AssinaturaScalarFieldEnum[]
  }


  /**
   * assinatura findMany
   */
  export type assinaturaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assinatura
     */
    select?: assinaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: assinaturaInclude<ExtArgs> | null
    /**
     * Filter, which assinaturas to fetch.
     */
    where?: assinaturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assinaturas to fetch.
     */
    orderBy?: assinaturaOrderByWithRelationInput | assinaturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing assinaturas.
     */
    cursor?: assinaturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assinaturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assinaturas.
     */
    skip?: number
    distinct?: AssinaturaScalarFieldEnum | AssinaturaScalarFieldEnum[]
  }


  /**
   * assinatura create
   */
  export type assinaturaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assinatura
     */
    select?: assinaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: assinaturaInclude<ExtArgs> | null
    /**
     * The data needed to create a assinatura.
     */
    data: XOR<assinaturaCreateInput, assinaturaUncheckedCreateInput>
  }


  /**
   * assinatura createMany
   */
  export type assinaturaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many assinaturas.
     */
    data: assinaturaCreateManyInput | assinaturaCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * assinatura update
   */
  export type assinaturaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assinatura
     */
    select?: assinaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: assinaturaInclude<ExtArgs> | null
    /**
     * The data needed to update a assinatura.
     */
    data: XOR<assinaturaUpdateInput, assinaturaUncheckedUpdateInput>
    /**
     * Choose, which assinatura to update.
     */
    where: assinaturaWhereUniqueInput
  }


  /**
   * assinatura updateMany
   */
  export type assinaturaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update assinaturas.
     */
    data: XOR<assinaturaUpdateManyMutationInput, assinaturaUncheckedUpdateManyInput>
    /**
     * Filter which assinaturas to update
     */
    where?: assinaturaWhereInput
  }


  /**
   * assinatura upsert
   */
  export type assinaturaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assinatura
     */
    select?: assinaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: assinaturaInclude<ExtArgs> | null
    /**
     * The filter to search for the assinatura to update in case it exists.
     */
    where: assinaturaWhereUniqueInput
    /**
     * In case the assinatura found by the `where` argument doesn't exist, create a new assinatura with this data.
     */
    create: XOR<assinaturaCreateInput, assinaturaUncheckedCreateInput>
    /**
     * In case the assinatura was found with the provided `where` argument, update it with this data.
     */
    update: XOR<assinaturaUpdateInput, assinaturaUncheckedUpdateInput>
  }


  /**
   * assinatura delete
   */
  export type assinaturaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assinatura
     */
    select?: assinaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: assinaturaInclude<ExtArgs> | null
    /**
     * Filter which assinatura to delete.
     */
    where: assinaturaWhereUniqueInput
  }


  /**
   * assinatura deleteMany
   */
  export type assinaturaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which assinaturas to delete
     */
    where?: assinaturaWhereInput
  }


  /**
   * assinatura without action
   */
  export type assinaturaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assinatura
     */
    select?: assinaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: assinaturaInclude<ExtArgs> | null
  }



  /**
   * Model historicoPagamento
   */

  export type AggregateHistoricoPagamento = {
    _count: HistoricoPagamentoCountAggregateOutputType | null
    _avg: HistoricoPagamentoAvgAggregateOutputType | null
    _sum: HistoricoPagamentoSumAggregateOutputType | null
    _min: HistoricoPagamentoMinAggregateOutputType | null
    _max: HistoricoPagamentoMaxAggregateOutputType | null
  }

  export type HistoricoPagamentoAvgAggregateOutputType = {
    idHistoricoPagamento: number | null
    valorTotal: number | null
    idConta: number | null
  }

  export type HistoricoPagamentoSumAggregateOutputType = {
    idHistoricoPagamento: number | null
    valorTotal: number | null
    idConta: number | null
  }

  export type HistoricoPagamentoMinAggregateOutputType = {
    idHistoricoPagamento: number | null
    nome: string | null
    descricao: string | null
    pago: boolean | null
    valorTotal: number | null
    data_inicio: Date | null
    idConta: number | null
  }

  export type HistoricoPagamentoMaxAggregateOutputType = {
    idHistoricoPagamento: number | null
    nome: string | null
    descricao: string | null
    pago: boolean | null
    valorTotal: number | null
    data_inicio: Date | null
    idConta: number | null
  }

  export type HistoricoPagamentoCountAggregateOutputType = {
    idHistoricoPagamento: number
    nome: number
    descricao: number
    pago: number
    valorTotal: number
    data_inicio: number
    idConta: number
    _all: number
  }


  export type HistoricoPagamentoAvgAggregateInputType = {
    idHistoricoPagamento?: true
    valorTotal?: true
    idConta?: true
  }

  export type HistoricoPagamentoSumAggregateInputType = {
    idHistoricoPagamento?: true
    valorTotal?: true
    idConta?: true
  }

  export type HistoricoPagamentoMinAggregateInputType = {
    idHistoricoPagamento?: true
    nome?: true
    descricao?: true
    pago?: true
    valorTotal?: true
    data_inicio?: true
    idConta?: true
  }

  export type HistoricoPagamentoMaxAggregateInputType = {
    idHistoricoPagamento?: true
    nome?: true
    descricao?: true
    pago?: true
    valorTotal?: true
    data_inicio?: true
    idConta?: true
  }

  export type HistoricoPagamentoCountAggregateInputType = {
    idHistoricoPagamento?: true
    nome?: true
    descricao?: true
    pago?: true
    valorTotal?: true
    data_inicio?: true
    idConta?: true
    _all?: true
  }

  export type HistoricoPagamentoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which historicoPagamento to aggregate.
     */
    where?: historicoPagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historicoPagamentos to fetch.
     */
    orderBy?: historicoPagamentoOrderByWithRelationInput | historicoPagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: historicoPagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historicoPagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historicoPagamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned historicoPagamentos
    **/
    _count?: true | HistoricoPagamentoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HistoricoPagamentoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HistoricoPagamentoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HistoricoPagamentoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HistoricoPagamentoMaxAggregateInputType
  }

  export type GetHistoricoPagamentoAggregateType<T extends HistoricoPagamentoAggregateArgs> = {
        [P in keyof T & keyof AggregateHistoricoPagamento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistoricoPagamento[P]>
      : GetScalarType<T[P], AggregateHistoricoPagamento[P]>
  }




  export type historicoPagamentoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: historicoPagamentoWhereInput
    orderBy?: historicoPagamentoOrderByWithAggregationInput | historicoPagamentoOrderByWithAggregationInput[]
    by: HistoricoPagamentoScalarFieldEnum[] | HistoricoPagamentoScalarFieldEnum
    having?: historicoPagamentoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HistoricoPagamentoCountAggregateInputType | true
    _avg?: HistoricoPagamentoAvgAggregateInputType
    _sum?: HistoricoPagamentoSumAggregateInputType
    _min?: HistoricoPagamentoMinAggregateInputType
    _max?: HistoricoPagamentoMaxAggregateInputType
  }

  export type HistoricoPagamentoGroupByOutputType = {
    idHistoricoPagamento: number
    nome: string
    descricao: string
    pago: boolean
    valorTotal: number
    data_inicio: Date | null
    idConta: number
    _count: HistoricoPagamentoCountAggregateOutputType | null
    _avg: HistoricoPagamentoAvgAggregateOutputType | null
    _sum: HistoricoPagamentoSumAggregateOutputType | null
    _min: HistoricoPagamentoMinAggregateOutputType | null
    _max: HistoricoPagamentoMaxAggregateOutputType | null
  }

  type GetHistoricoPagamentoGroupByPayload<T extends historicoPagamentoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HistoricoPagamentoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HistoricoPagamentoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HistoricoPagamentoGroupByOutputType[P]>
            : GetScalarType<T[P], HistoricoPagamentoGroupByOutputType[P]>
        }
      >
    >


  export type historicoPagamentoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idHistoricoPagamento?: boolean
    nome?: boolean
    descricao?: boolean
    pago?: boolean
    valorTotal?: boolean
    data_inicio?: boolean
    idConta?: boolean
    contas?: boolean | contasDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["historicoPagamento"]>

  export type historicoPagamentoSelectScalar = {
    idHistoricoPagamento?: boolean
    nome?: boolean
    descricao?: boolean
    pago?: boolean
    valorTotal?: boolean
    data_inicio?: boolean
    idConta?: boolean
  }

  export type historicoPagamentoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contas?: boolean | contasDefaultArgs<ExtArgs>
  }


  export type $historicoPagamentoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "historicoPagamento"
    objects: {
      contas: Prisma.$contasPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idHistoricoPagamento: number
      nome: string
      descricao: string
      pago: boolean
      valorTotal: number
      data_inicio: Date | null
      idConta: number
    }, ExtArgs["result"]["historicoPagamento"]>
    composites: {}
  }


  type historicoPagamentoGetPayload<S extends boolean | null | undefined | historicoPagamentoDefaultArgs> = $Result.GetResult<Prisma.$historicoPagamentoPayload, S>

  type historicoPagamentoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<historicoPagamentoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HistoricoPagamentoCountAggregateInputType | true
    }

  export interface historicoPagamentoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['historicoPagamento'], meta: { name: 'historicoPagamento' } }
    /**
     * Find zero or one HistoricoPagamento that matches the filter.
     * @param {historicoPagamentoFindUniqueArgs} args - Arguments to find a HistoricoPagamento
     * @example
     * // Get one HistoricoPagamento
     * const historicoPagamento = await prisma.historicoPagamento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends historicoPagamentoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, historicoPagamentoFindUniqueArgs<ExtArgs>>
    ): Prisma__historicoPagamentoClient<$Result.GetResult<Prisma.$historicoPagamentoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one HistoricoPagamento that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {historicoPagamentoFindUniqueOrThrowArgs} args - Arguments to find a HistoricoPagamento
     * @example
     * // Get one HistoricoPagamento
     * const historicoPagamento = await prisma.historicoPagamento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends historicoPagamentoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, historicoPagamentoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__historicoPagamentoClient<$Result.GetResult<Prisma.$historicoPagamentoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first HistoricoPagamento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historicoPagamentoFindFirstArgs} args - Arguments to find a HistoricoPagamento
     * @example
     * // Get one HistoricoPagamento
     * const historicoPagamento = await prisma.historicoPagamento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends historicoPagamentoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, historicoPagamentoFindFirstArgs<ExtArgs>>
    ): Prisma__historicoPagamentoClient<$Result.GetResult<Prisma.$historicoPagamentoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first HistoricoPagamento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historicoPagamentoFindFirstOrThrowArgs} args - Arguments to find a HistoricoPagamento
     * @example
     * // Get one HistoricoPagamento
     * const historicoPagamento = await prisma.historicoPagamento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends historicoPagamentoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, historicoPagamentoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__historicoPagamentoClient<$Result.GetResult<Prisma.$historicoPagamentoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more HistoricoPagamentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historicoPagamentoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HistoricoPagamentos
     * const historicoPagamentos = await prisma.historicoPagamento.findMany()
     * 
     * // Get first 10 HistoricoPagamentos
     * const historicoPagamentos = await prisma.historicoPagamento.findMany({ take: 10 })
     * 
     * // Only select the `idHistoricoPagamento`
     * const historicoPagamentoWithIdHistoricoPagamentoOnly = await prisma.historicoPagamento.findMany({ select: { idHistoricoPagamento: true } })
     * 
    **/
    findMany<T extends historicoPagamentoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, historicoPagamentoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$historicoPagamentoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a HistoricoPagamento.
     * @param {historicoPagamentoCreateArgs} args - Arguments to create a HistoricoPagamento.
     * @example
     * // Create one HistoricoPagamento
     * const HistoricoPagamento = await prisma.historicoPagamento.create({
     *   data: {
     *     // ... data to create a HistoricoPagamento
     *   }
     * })
     * 
    **/
    create<T extends historicoPagamentoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, historicoPagamentoCreateArgs<ExtArgs>>
    ): Prisma__historicoPagamentoClient<$Result.GetResult<Prisma.$historicoPagamentoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many HistoricoPagamentos.
     *     @param {historicoPagamentoCreateManyArgs} args - Arguments to create many HistoricoPagamentos.
     *     @example
     *     // Create many HistoricoPagamentos
     *     const historicoPagamento = await prisma.historicoPagamento.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends historicoPagamentoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, historicoPagamentoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HistoricoPagamento.
     * @param {historicoPagamentoDeleteArgs} args - Arguments to delete one HistoricoPagamento.
     * @example
     * // Delete one HistoricoPagamento
     * const HistoricoPagamento = await prisma.historicoPagamento.delete({
     *   where: {
     *     // ... filter to delete one HistoricoPagamento
     *   }
     * })
     * 
    **/
    delete<T extends historicoPagamentoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, historicoPagamentoDeleteArgs<ExtArgs>>
    ): Prisma__historicoPagamentoClient<$Result.GetResult<Prisma.$historicoPagamentoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one HistoricoPagamento.
     * @param {historicoPagamentoUpdateArgs} args - Arguments to update one HistoricoPagamento.
     * @example
     * // Update one HistoricoPagamento
     * const historicoPagamento = await prisma.historicoPagamento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends historicoPagamentoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, historicoPagamentoUpdateArgs<ExtArgs>>
    ): Prisma__historicoPagamentoClient<$Result.GetResult<Prisma.$historicoPagamentoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more HistoricoPagamentos.
     * @param {historicoPagamentoDeleteManyArgs} args - Arguments to filter HistoricoPagamentos to delete.
     * @example
     * // Delete a few HistoricoPagamentos
     * const { count } = await prisma.historicoPagamento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends historicoPagamentoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, historicoPagamentoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HistoricoPagamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historicoPagamentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HistoricoPagamentos
     * const historicoPagamento = await prisma.historicoPagamento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends historicoPagamentoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, historicoPagamentoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HistoricoPagamento.
     * @param {historicoPagamentoUpsertArgs} args - Arguments to update or create a HistoricoPagamento.
     * @example
     * // Update or create a HistoricoPagamento
     * const historicoPagamento = await prisma.historicoPagamento.upsert({
     *   create: {
     *     // ... data to create a HistoricoPagamento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HistoricoPagamento we want to update
     *   }
     * })
    **/
    upsert<T extends historicoPagamentoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, historicoPagamentoUpsertArgs<ExtArgs>>
    ): Prisma__historicoPagamentoClient<$Result.GetResult<Prisma.$historicoPagamentoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of HistoricoPagamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historicoPagamentoCountArgs} args - Arguments to filter HistoricoPagamentos to count.
     * @example
     * // Count the number of HistoricoPagamentos
     * const count = await prisma.historicoPagamento.count({
     *   where: {
     *     // ... the filter for the HistoricoPagamentos we want to count
     *   }
     * })
    **/
    count<T extends historicoPagamentoCountArgs>(
      args?: Subset<T, historicoPagamentoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HistoricoPagamentoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HistoricoPagamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoricoPagamentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HistoricoPagamentoAggregateArgs>(args: Subset<T, HistoricoPagamentoAggregateArgs>): Prisma.PrismaPromise<GetHistoricoPagamentoAggregateType<T>>

    /**
     * Group by HistoricoPagamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historicoPagamentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends historicoPagamentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: historicoPagamentoGroupByArgs['orderBy'] }
        : { orderBy?: historicoPagamentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, historicoPagamentoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistoricoPagamentoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the historicoPagamento model
   */
  readonly fields: historicoPagamentoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for historicoPagamento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__historicoPagamentoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    contas<T extends contasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, contasDefaultArgs<ExtArgs>>): Prisma__contasClient<$Result.GetResult<Prisma.$contasPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the historicoPagamento model
   */ 
  interface historicoPagamentoFieldRefs {
    readonly idHistoricoPagamento: FieldRef<"historicoPagamento", 'Int'>
    readonly nome: FieldRef<"historicoPagamento", 'String'>
    readonly descricao: FieldRef<"historicoPagamento", 'String'>
    readonly pago: FieldRef<"historicoPagamento", 'Boolean'>
    readonly valorTotal: FieldRef<"historicoPagamento", 'Float'>
    readonly data_inicio: FieldRef<"historicoPagamento", 'DateTime'>
    readonly idConta: FieldRef<"historicoPagamento", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * historicoPagamento findUnique
   */
  export type historicoPagamentoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historicoPagamento
     */
    select?: historicoPagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: historicoPagamentoInclude<ExtArgs> | null
    /**
     * Filter, which historicoPagamento to fetch.
     */
    where: historicoPagamentoWhereUniqueInput
  }


  /**
   * historicoPagamento findUniqueOrThrow
   */
  export type historicoPagamentoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historicoPagamento
     */
    select?: historicoPagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: historicoPagamentoInclude<ExtArgs> | null
    /**
     * Filter, which historicoPagamento to fetch.
     */
    where: historicoPagamentoWhereUniqueInput
  }


  /**
   * historicoPagamento findFirst
   */
  export type historicoPagamentoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historicoPagamento
     */
    select?: historicoPagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: historicoPagamentoInclude<ExtArgs> | null
    /**
     * Filter, which historicoPagamento to fetch.
     */
    where?: historicoPagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historicoPagamentos to fetch.
     */
    orderBy?: historicoPagamentoOrderByWithRelationInput | historicoPagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for historicoPagamentos.
     */
    cursor?: historicoPagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historicoPagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historicoPagamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of historicoPagamentos.
     */
    distinct?: HistoricoPagamentoScalarFieldEnum | HistoricoPagamentoScalarFieldEnum[]
  }


  /**
   * historicoPagamento findFirstOrThrow
   */
  export type historicoPagamentoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historicoPagamento
     */
    select?: historicoPagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: historicoPagamentoInclude<ExtArgs> | null
    /**
     * Filter, which historicoPagamento to fetch.
     */
    where?: historicoPagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historicoPagamentos to fetch.
     */
    orderBy?: historicoPagamentoOrderByWithRelationInput | historicoPagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for historicoPagamentos.
     */
    cursor?: historicoPagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historicoPagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historicoPagamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of historicoPagamentos.
     */
    distinct?: HistoricoPagamentoScalarFieldEnum | HistoricoPagamentoScalarFieldEnum[]
  }


  /**
   * historicoPagamento findMany
   */
  export type historicoPagamentoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historicoPagamento
     */
    select?: historicoPagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: historicoPagamentoInclude<ExtArgs> | null
    /**
     * Filter, which historicoPagamentos to fetch.
     */
    where?: historicoPagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historicoPagamentos to fetch.
     */
    orderBy?: historicoPagamentoOrderByWithRelationInput | historicoPagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing historicoPagamentos.
     */
    cursor?: historicoPagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historicoPagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historicoPagamentos.
     */
    skip?: number
    distinct?: HistoricoPagamentoScalarFieldEnum | HistoricoPagamentoScalarFieldEnum[]
  }


  /**
   * historicoPagamento create
   */
  export type historicoPagamentoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historicoPagamento
     */
    select?: historicoPagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: historicoPagamentoInclude<ExtArgs> | null
    /**
     * The data needed to create a historicoPagamento.
     */
    data: XOR<historicoPagamentoCreateInput, historicoPagamentoUncheckedCreateInput>
  }


  /**
   * historicoPagamento createMany
   */
  export type historicoPagamentoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many historicoPagamentos.
     */
    data: historicoPagamentoCreateManyInput | historicoPagamentoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * historicoPagamento update
   */
  export type historicoPagamentoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historicoPagamento
     */
    select?: historicoPagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: historicoPagamentoInclude<ExtArgs> | null
    /**
     * The data needed to update a historicoPagamento.
     */
    data: XOR<historicoPagamentoUpdateInput, historicoPagamentoUncheckedUpdateInput>
    /**
     * Choose, which historicoPagamento to update.
     */
    where: historicoPagamentoWhereUniqueInput
  }


  /**
   * historicoPagamento updateMany
   */
  export type historicoPagamentoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update historicoPagamentos.
     */
    data: XOR<historicoPagamentoUpdateManyMutationInput, historicoPagamentoUncheckedUpdateManyInput>
    /**
     * Filter which historicoPagamentos to update
     */
    where?: historicoPagamentoWhereInput
  }


  /**
   * historicoPagamento upsert
   */
  export type historicoPagamentoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historicoPagamento
     */
    select?: historicoPagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: historicoPagamentoInclude<ExtArgs> | null
    /**
     * The filter to search for the historicoPagamento to update in case it exists.
     */
    where: historicoPagamentoWhereUniqueInput
    /**
     * In case the historicoPagamento found by the `where` argument doesn't exist, create a new historicoPagamento with this data.
     */
    create: XOR<historicoPagamentoCreateInput, historicoPagamentoUncheckedCreateInput>
    /**
     * In case the historicoPagamento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<historicoPagamentoUpdateInput, historicoPagamentoUncheckedUpdateInput>
  }


  /**
   * historicoPagamento delete
   */
  export type historicoPagamentoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historicoPagamento
     */
    select?: historicoPagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: historicoPagamentoInclude<ExtArgs> | null
    /**
     * Filter which historicoPagamento to delete.
     */
    where: historicoPagamentoWhereUniqueInput
  }


  /**
   * historicoPagamento deleteMany
   */
  export type historicoPagamentoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which historicoPagamentos to delete
     */
    where?: historicoPagamentoWhereInput
  }


  /**
   * historicoPagamento without action
   */
  export type historicoPagamentoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historicoPagamento
     */
    select?: historicoPagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: historicoPagamentoInclude<ExtArgs> | null
  }



  /**
   * Model planos
   */

  export type AggregatePlanos = {
    _count: PlanosCountAggregateOutputType | null
    _avg: PlanosAvgAggregateOutputType | null
    _sum: PlanosSumAggregateOutputType | null
    _min: PlanosMinAggregateOutputType | null
    _max: PlanosMaxAggregateOutputType | null
  }

  export type PlanosAvgAggregateOutputType = {
    idPlanos: number | null
    valorTotal: number | null
    qtdePessoas: number | null
    meses: number | null
    maxSessoes: number | null
  }

  export type PlanosSumAggregateOutputType = {
    idPlanos: number | null
    valorTotal: number | null
    qtdePessoas: number | null
    meses: number | null
    maxSessoes: number | null
  }

  export type PlanosMinAggregateOutputType = {
    idPlanos: number | null
    nome: string | null
    subtitulo: string | null
    descricao: string | null
    valorTotal: number | null
    tipoFuncionalidade: $Enums.tipoFuncionalidade | null
    tipo: $Enums.tipoPlano | null
    qtdePessoas: number | null
    meses: number | null
    maxSessoes: number | null
  }

  export type PlanosMaxAggregateOutputType = {
    idPlanos: number | null
    nome: string | null
    subtitulo: string | null
    descricao: string | null
    valorTotal: number | null
    tipoFuncionalidade: $Enums.tipoFuncionalidade | null
    tipo: $Enums.tipoPlano | null
    qtdePessoas: number | null
    meses: number | null
    maxSessoes: number | null
  }

  export type PlanosCountAggregateOutputType = {
    idPlanos: number
    nome: number
    subtitulo: number
    descricao: number
    valorTotal: number
    tipoFuncionalidade: number
    tipo: number
    qtdePessoas: number
    meses: number
    maxSessoes: number
    _all: number
  }


  export type PlanosAvgAggregateInputType = {
    idPlanos?: true
    valorTotal?: true
    qtdePessoas?: true
    meses?: true
    maxSessoes?: true
  }

  export type PlanosSumAggregateInputType = {
    idPlanos?: true
    valorTotal?: true
    qtdePessoas?: true
    meses?: true
    maxSessoes?: true
  }

  export type PlanosMinAggregateInputType = {
    idPlanos?: true
    nome?: true
    subtitulo?: true
    descricao?: true
    valorTotal?: true
    tipoFuncionalidade?: true
    tipo?: true
    qtdePessoas?: true
    meses?: true
    maxSessoes?: true
  }

  export type PlanosMaxAggregateInputType = {
    idPlanos?: true
    nome?: true
    subtitulo?: true
    descricao?: true
    valorTotal?: true
    tipoFuncionalidade?: true
    tipo?: true
    qtdePessoas?: true
    meses?: true
    maxSessoes?: true
  }

  export type PlanosCountAggregateInputType = {
    idPlanos?: true
    nome?: true
    subtitulo?: true
    descricao?: true
    valorTotal?: true
    tipoFuncionalidade?: true
    tipo?: true
    qtdePessoas?: true
    meses?: true
    maxSessoes?: true
    _all?: true
  }

  export type PlanosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which planos to aggregate.
     */
    where?: planosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of planos to fetch.
     */
    orderBy?: planosOrderByWithRelationInput | planosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: planosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` planos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` planos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned planos
    **/
    _count?: true | PlanosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanosMaxAggregateInputType
  }

  export type GetPlanosAggregateType<T extends PlanosAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanos[P]>
      : GetScalarType<T[P], AggregatePlanos[P]>
  }




  export type planosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: planosWhereInput
    orderBy?: planosOrderByWithAggregationInput | planosOrderByWithAggregationInput[]
    by: PlanosScalarFieldEnum[] | PlanosScalarFieldEnum
    having?: planosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanosCountAggregateInputType | true
    _avg?: PlanosAvgAggregateInputType
    _sum?: PlanosSumAggregateInputType
    _min?: PlanosMinAggregateInputType
    _max?: PlanosMaxAggregateInputType
  }

  export type PlanosGroupByOutputType = {
    idPlanos: number
    nome: string
    subtitulo: string
    descricao: string
    valorTotal: number
    tipoFuncionalidade: $Enums.tipoFuncionalidade
    tipo: $Enums.tipoPlano
    qtdePessoas: number
    meses: number
    maxSessoes: number
    _count: PlanosCountAggregateOutputType | null
    _avg: PlanosAvgAggregateOutputType | null
    _sum: PlanosSumAggregateOutputType | null
    _min: PlanosMinAggregateOutputType | null
    _max: PlanosMaxAggregateOutputType | null
  }

  type GetPlanosGroupByPayload<T extends planosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanosGroupByOutputType[P]>
            : GetScalarType<T[P], PlanosGroupByOutputType[P]>
        }
      >
    >


  export type planosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPlanos?: boolean
    nome?: boolean
    subtitulo?: boolean
    descricao?: boolean
    valorTotal?: boolean
    tipoFuncionalidade?: boolean
    tipo?: boolean
    qtdePessoas?: boolean
    meses?: boolean
    maxSessoes?: boolean
    assinatura?: boolean | planos$assinaturaArgs<ExtArgs>
    grupos?: boolean | planos$gruposArgs<ExtArgs>
    _count?: boolean | PlanosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planos"]>

  export type planosSelectScalar = {
    idPlanos?: boolean
    nome?: boolean
    subtitulo?: boolean
    descricao?: boolean
    valorTotal?: boolean
    tipoFuncionalidade?: boolean
    tipo?: boolean
    qtdePessoas?: boolean
    meses?: boolean
    maxSessoes?: boolean
  }

  export type planosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assinatura?: boolean | planos$assinaturaArgs<ExtArgs>
    grupos?: boolean | planos$gruposArgs<ExtArgs>
    _count?: boolean | PlanosCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $planosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "planos"
    objects: {
      assinatura: Prisma.$assinaturaPayload<ExtArgs>[]
      grupos: Prisma.$gruposPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idPlanos: number
      nome: string
      subtitulo: string
      descricao: string
      valorTotal: number
      tipoFuncionalidade: $Enums.tipoFuncionalidade
      tipo: $Enums.tipoPlano
      qtdePessoas: number
      meses: number
      maxSessoes: number
    }, ExtArgs["result"]["planos"]>
    composites: {}
  }


  type planosGetPayload<S extends boolean | null | undefined | planosDefaultArgs> = $Result.GetResult<Prisma.$planosPayload, S>

  type planosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<planosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlanosCountAggregateInputType | true
    }

  export interface planosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['planos'], meta: { name: 'planos' } }
    /**
     * Find zero or one Planos that matches the filter.
     * @param {planosFindUniqueArgs} args - Arguments to find a Planos
     * @example
     * // Get one Planos
     * const planos = await prisma.planos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends planosFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, planosFindUniqueArgs<ExtArgs>>
    ): Prisma__planosClient<$Result.GetResult<Prisma.$planosPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Planos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {planosFindUniqueOrThrowArgs} args - Arguments to find a Planos
     * @example
     * // Get one Planos
     * const planos = await prisma.planos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends planosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, planosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__planosClient<$Result.GetResult<Prisma.$planosPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Planos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planosFindFirstArgs} args - Arguments to find a Planos
     * @example
     * // Get one Planos
     * const planos = await prisma.planos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends planosFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, planosFindFirstArgs<ExtArgs>>
    ): Prisma__planosClient<$Result.GetResult<Prisma.$planosPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Planos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planosFindFirstOrThrowArgs} args - Arguments to find a Planos
     * @example
     * // Get one Planos
     * const planos = await prisma.planos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends planosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, planosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__planosClient<$Result.GetResult<Prisma.$planosPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Planos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Planos
     * const planos = await prisma.planos.findMany()
     * 
     * // Get first 10 Planos
     * const planos = await prisma.planos.findMany({ take: 10 })
     * 
     * // Only select the `idPlanos`
     * const planosWithIdPlanosOnly = await prisma.planos.findMany({ select: { idPlanos: true } })
     * 
    **/
    findMany<T extends planosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, planosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$planosPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Planos.
     * @param {planosCreateArgs} args - Arguments to create a Planos.
     * @example
     * // Create one Planos
     * const Planos = await prisma.planos.create({
     *   data: {
     *     // ... data to create a Planos
     *   }
     * })
     * 
    **/
    create<T extends planosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, planosCreateArgs<ExtArgs>>
    ): Prisma__planosClient<$Result.GetResult<Prisma.$planosPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Planos.
     *     @param {planosCreateManyArgs} args - Arguments to create many Planos.
     *     @example
     *     // Create many Planos
     *     const planos = await prisma.planos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends planosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, planosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Planos.
     * @param {planosDeleteArgs} args - Arguments to delete one Planos.
     * @example
     * // Delete one Planos
     * const Planos = await prisma.planos.delete({
     *   where: {
     *     // ... filter to delete one Planos
     *   }
     * })
     * 
    **/
    delete<T extends planosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, planosDeleteArgs<ExtArgs>>
    ): Prisma__planosClient<$Result.GetResult<Prisma.$planosPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Planos.
     * @param {planosUpdateArgs} args - Arguments to update one Planos.
     * @example
     * // Update one Planos
     * const planos = await prisma.planos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends planosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, planosUpdateArgs<ExtArgs>>
    ): Prisma__planosClient<$Result.GetResult<Prisma.$planosPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Planos.
     * @param {planosDeleteManyArgs} args - Arguments to filter Planos to delete.
     * @example
     * // Delete a few Planos
     * const { count } = await prisma.planos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends planosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, planosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Planos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Planos
     * const planos = await prisma.planos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends planosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, planosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Planos.
     * @param {planosUpsertArgs} args - Arguments to update or create a Planos.
     * @example
     * // Update or create a Planos
     * const planos = await prisma.planos.upsert({
     *   create: {
     *     // ... data to create a Planos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Planos we want to update
     *   }
     * })
    **/
    upsert<T extends planosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, planosUpsertArgs<ExtArgs>>
    ): Prisma__planosClient<$Result.GetResult<Prisma.$planosPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Planos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planosCountArgs} args - Arguments to filter Planos to count.
     * @example
     * // Count the number of Planos
     * const count = await prisma.planos.count({
     *   where: {
     *     // ... the filter for the Planos we want to count
     *   }
     * })
    **/
    count<T extends planosCountArgs>(
      args?: Subset<T, planosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Planos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanosAggregateArgs>(args: Subset<T, PlanosAggregateArgs>): Prisma.PrismaPromise<GetPlanosAggregateType<T>>

    /**
     * Group by Planos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends planosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: planosGroupByArgs['orderBy'] }
        : { orderBy?: planosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, planosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the planos model
   */
  readonly fields: planosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for planos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__planosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    assinatura<T extends planos$assinaturaArgs<ExtArgs> = {}>(args?: Subset<T, planos$assinaturaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$assinaturaPayload<ExtArgs>, T, 'findMany'> | Null>;

    grupos<T extends planos$gruposArgs<ExtArgs> = {}>(args?: Subset<T, planos$gruposArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gruposPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the planos model
   */ 
  interface planosFieldRefs {
    readonly idPlanos: FieldRef<"planos", 'Int'>
    readonly nome: FieldRef<"planos", 'String'>
    readonly subtitulo: FieldRef<"planos", 'String'>
    readonly descricao: FieldRef<"planos", 'String'>
    readonly valorTotal: FieldRef<"planos", 'Float'>
    readonly tipoFuncionalidade: FieldRef<"planos", 'tipoFuncionalidade'>
    readonly tipo: FieldRef<"planos", 'tipoPlano'>
    readonly qtdePessoas: FieldRef<"planos", 'Int'>
    readonly meses: FieldRef<"planos", 'Int'>
    readonly maxSessoes: FieldRef<"planos", 'Float'>
  }
    

  // Custom InputTypes

  /**
   * planos findUnique
   */
  export type planosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planos
     */
    select?: planosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: planosInclude<ExtArgs> | null
    /**
     * Filter, which planos to fetch.
     */
    where: planosWhereUniqueInput
  }


  /**
   * planos findUniqueOrThrow
   */
  export type planosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planos
     */
    select?: planosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: planosInclude<ExtArgs> | null
    /**
     * Filter, which planos to fetch.
     */
    where: planosWhereUniqueInput
  }


  /**
   * planos findFirst
   */
  export type planosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planos
     */
    select?: planosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: planosInclude<ExtArgs> | null
    /**
     * Filter, which planos to fetch.
     */
    where?: planosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of planos to fetch.
     */
    orderBy?: planosOrderByWithRelationInput | planosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for planos.
     */
    cursor?: planosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` planos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` planos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of planos.
     */
    distinct?: PlanosScalarFieldEnum | PlanosScalarFieldEnum[]
  }


  /**
   * planos findFirstOrThrow
   */
  export type planosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planos
     */
    select?: planosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: planosInclude<ExtArgs> | null
    /**
     * Filter, which planos to fetch.
     */
    where?: planosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of planos to fetch.
     */
    orderBy?: planosOrderByWithRelationInput | planosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for planos.
     */
    cursor?: planosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` planos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` planos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of planos.
     */
    distinct?: PlanosScalarFieldEnum | PlanosScalarFieldEnum[]
  }


  /**
   * planos findMany
   */
  export type planosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planos
     */
    select?: planosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: planosInclude<ExtArgs> | null
    /**
     * Filter, which planos to fetch.
     */
    where?: planosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of planos to fetch.
     */
    orderBy?: planosOrderByWithRelationInput | planosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing planos.
     */
    cursor?: planosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` planos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` planos.
     */
    skip?: number
    distinct?: PlanosScalarFieldEnum | PlanosScalarFieldEnum[]
  }


  /**
   * planos create
   */
  export type planosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planos
     */
    select?: planosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: planosInclude<ExtArgs> | null
    /**
     * The data needed to create a planos.
     */
    data: XOR<planosCreateInput, planosUncheckedCreateInput>
  }


  /**
   * planos createMany
   */
  export type planosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many planos.
     */
    data: planosCreateManyInput | planosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * planos update
   */
  export type planosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planos
     */
    select?: planosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: planosInclude<ExtArgs> | null
    /**
     * The data needed to update a planos.
     */
    data: XOR<planosUpdateInput, planosUncheckedUpdateInput>
    /**
     * Choose, which planos to update.
     */
    where: planosWhereUniqueInput
  }


  /**
   * planos updateMany
   */
  export type planosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update planos.
     */
    data: XOR<planosUpdateManyMutationInput, planosUncheckedUpdateManyInput>
    /**
     * Filter which planos to update
     */
    where?: planosWhereInput
  }


  /**
   * planos upsert
   */
  export type planosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planos
     */
    select?: planosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: planosInclude<ExtArgs> | null
    /**
     * The filter to search for the planos to update in case it exists.
     */
    where: planosWhereUniqueInput
    /**
     * In case the planos found by the `where` argument doesn't exist, create a new planos with this data.
     */
    create: XOR<planosCreateInput, planosUncheckedCreateInput>
    /**
     * In case the planos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<planosUpdateInput, planosUncheckedUpdateInput>
  }


  /**
   * planos delete
   */
  export type planosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planos
     */
    select?: planosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: planosInclude<ExtArgs> | null
    /**
     * Filter which planos to delete.
     */
    where: planosWhereUniqueInput
  }


  /**
   * planos deleteMany
   */
  export type planosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which planos to delete
     */
    where?: planosWhereInput
  }


  /**
   * planos.assinatura
   */
  export type planos$assinaturaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assinatura
     */
    select?: assinaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: assinaturaInclude<ExtArgs> | null
    where?: assinaturaWhereInput
    orderBy?: assinaturaOrderByWithRelationInput | assinaturaOrderByWithRelationInput[]
    cursor?: assinaturaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssinaturaScalarFieldEnum | AssinaturaScalarFieldEnum[]
  }


  /**
   * planos.grupos
   */
  export type planos$gruposArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupos
     */
    select?: gruposSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: gruposInclude<ExtArgs> | null
    where?: gruposWhereInput
    orderBy?: gruposOrderByWithRelationInput | gruposOrderByWithRelationInput[]
    cursor?: gruposWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GruposScalarFieldEnum | GruposScalarFieldEnum[]
  }


  /**
   * planos without action
   */
  export type planosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planos
     */
    select?: planosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: planosInclude<ExtArgs> | null
  }



  /**
   * Model autenticacao
   */

  export type AggregateAutenticacao = {
    _count: AutenticacaoCountAggregateOutputType | null
    _avg: AutenticacaoAvgAggregateOutputType | null
    _sum: AutenticacaoSumAggregateOutputType | null
    _min: AutenticacaoMinAggregateOutputType | null
    _max: AutenticacaoMaxAggregateOutputType | null
  }

  export type AutenticacaoAvgAggregateOutputType = {
    idAutenticacao: number | null
    idConta: number | null
  }

  export type AutenticacaoSumAggregateOutputType = {
    idAutenticacao: number | null
    idConta: number | null
  }

  export type AutenticacaoMinAggregateOutputType = {
    idAutenticacao: number | null
    email: string | null
    senha: string | null
    idConta: number | null
  }

  export type AutenticacaoMaxAggregateOutputType = {
    idAutenticacao: number | null
    email: string | null
    senha: string | null
    idConta: number | null
  }

  export type AutenticacaoCountAggregateOutputType = {
    idAutenticacao: number
    email: number
    senha: number
    idConta: number
    _all: number
  }


  export type AutenticacaoAvgAggregateInputType = {
    idAutenticacao?: true
    idConta?: true
  }

  export type AutenticacaoSumAggregateInputType = {
    idAutenticacao?: true
    idConta?: true
  }

  export type AutenticacaoMinAggregateInputType = {
    idAutenticacao?: true
    email?: true
    senha?: true
    idConta?: true
  }

  export type AutenticacaoMaxAggregateInputType = {
    idAutenticacao?: true
    email?: true
    senha?: true
    idConta?: true
  }

  export type AutenticacaoCountAggregateInputType = {
    idAutenticacao?: true
    email?: true
    senha?: true
    idConta?: true
    _all?: true
  }

  export type AutenticacaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which autenticacao to aggregate.
     */
    where?: autenticacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autenticacaos to fetch.
     */
    orderBy?: autenticacaoOrderByWithRelationInput | autenticacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: autenticacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autenticacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autenticacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned autenticacaos
    **/
    _count?: true | AutenticacaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AutenticacaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AutenticacaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutenticacaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutenticacaoMaxAggregateInputType
  }

  export type GetAutenticacaoAggregateType<T extends AutenticacaoAggregateArgs> = {
        [P in keyof T & keyof AggregateAutenticacao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutenticacao[P]>
      : GetScalarType<T[P], AggregateAutenticacao[P]>
  }




  export type autenticacaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: autenticacaoWhereInput
    orderBy?: autenticacaoOrderByWithAggregationInput | autenticacaoOrderByWithAggregationInput[]
    by: AutenticacaoScalarFieldEnum[] | AutenticacaoScalarFieldEnum
    having?: autenticacaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutenticacaoCountAggregateInputType | true
    _avg?: AutenticacaoAvgAggregateInputType
    _sum?: AutenticacaoSumAggregateInputType
    _min?: AutenticacaoMinAggregateInputType
    _max?: AutenticacaoMaxAggregateInputType
  }

  export type AutenticacaoGroupByOutputType = {
    idAutenticacao: number
    email: string
    senha: string
    idConta: number
    _count: AutenticacaoCountAggregateOutputType | null
    _avg: AutenticacaoAvgAggregateOutputType | null
    _sum: AutenticacaoSumAggregateOutputType | null
    _min: AutenticacaoMinAggregateOutputType | null
    _max: AutenticacaoMaxAggregateOutputType | null
  }

  type GetAutenticacaoGroupByPayload<T extends autenticacaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutenticacaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutenticacaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutenticacaoGroupByOutputType[P]>
            : GetScalarType<T[P], AutenticacaoGroupByOutputType[P]>
        }
      >
    >


  export type autenticacaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idAutenticacao?: boolean
    email?: boolean
    senha?: boolean
    idConta?: boolean
    conta?: boolean | contasDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["autenticacao"]>

  export type autenticacaoSelectScalar = {
    idAutenticacao?: boolean
    email?: boolean
    senha?: boolean
    idConta?: boolean
  }

  export type autenticacaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conta?: boolean | contasDefaultArgs<ExtArgs>
  }


  export type $autenticacaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "autenticacao"
    objects: {
      conta: Prisma.$contasPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idAutenticacao: number
      email: string
      senha: string
      idConta: number
    }, ExtArgs["result"]["autenticacao"]>
    composites: {}
  }


  type autenticacaoGetPayload<S extends boolean | null | undefined | autenticacaoDefaultArgs> = $Result.GetResult<Prisma.$autenticacaoPayload, S>

  type autenticacaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<autenticacaoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AutenticacaoCountAggregateInputType | true
    }

  export interface autenticacaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['autenticacao'], meta: { name: 'autenticacao' } }
    /**
     * Find zero or one Autenticacao that matches the filter.
     * @param {autenticacaoFindUniqueArgs} args - Arguments to find a Autenticacao
     * @example
     * // Get one Autenticacao
     * const autenticacao = await prisma.autenticacao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends autenticacaoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, autenticacaoFindUniqueArgs<ExtArgs>>
    ): Prisma__autenticacaoClient<$Result.GetResult<Prisma.$autenticacaoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Autenticacao that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {autenticacaoFindUniqueOrThrowArgs} args - Arguments to find a Autenticacao
     * @example
     * // Get one Autenticacao
     * const autenticacao = await prisma.autenticacao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends autenticacaoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, autenticacaoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__autenticacaoClient<$Result.GetResult<Prisma.$autenticacaoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Autenticacao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autenticacaoFindFirstArgs} args - Arguments to find a Autenticacao
     * @example
     * // Get one Autenticacao
     * const autenticacao = await prisma.autenticacao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends autenticacaoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, autenticacaoFindFirstArgs<ExtArgs>>
    ): Prisma__autenticacaoClient<$Result.GetResult<Prisma.$autenticacaoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Autenticacao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autenticacaoFindFirstOrThrowArgs} args - Arguments to find a Autenticacao
     * @example
     * // Get one Autenticacao
     * const autenticacao = await prisma.autenticacao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends autenticacaoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, autenticacaoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__autenticacaoClient<$Result.GetResult<Prisma.$autenticacaoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Autenticacaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autenticacaoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Autenticacaos
     * const autenticacaos = await prisma.autenticacao.findMany()
     * 
     * // Get first 10 Autenticacaos
     * const autenticacaos = await prisma.autenticacao.findMany({ take: 10 })
     * 
     * // Only select the `idAutenticacao`
     * const autenticacaoWithIdAutenticacaoOnly = await prisma.autenticacao.findMany({ select: { idAutenticacao: true } })
     * 
    **/
    findMany<T extends autenticacaoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, autenticacaoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$autenticacaoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Autenticacao.
     * @param {autenticacaoCreateArgs} args - Arguments to create a Autenticacao.
     * @example
     * // Create one Autenticacao
     * const Autenticacao = await prisma.autenticacao.create({
     *   data: {
     *     // ... data to create a Autenticacao
     *   }
     * })
     * 
    **/
    create<T extends autenticacaoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, autenticacaoCreateArgs<ExtArgs>>
    ): Prisma__autenticacaoClient<$Result.GetResult<Prisma.$autenticacaoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Autenticacaos.
     *     @param {autenticacaoCreateManyArgs} args - Arguments to create many Autenticacaos.
     *     @example
     *     // Create many Autenticacaos
     *     const autenticacao = await prisma.autenticacao.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends autenticacaoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, autenticacaoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Autenticacao.
     * @param {autenticacaoDeleteArgs} args - Arguments to delete one Autenticacao.
     * @example
     * // Delete one Autenticacao
     * const Autenticacao = await prisma.autenticacao.delete({
     *   where: {
     *     // ... filter to delete one Autenticacao
     *   }
     * })
     * 
    **/
    delete<T extends autenticacaoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, autenticacaoDeleteArgs<ExtArgs>>
    ): Prisma__autenticacaoClient<$Result.GetResult<Prisma.$autenticacaoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Autenticacao.
     * @param {autenticacaoUpdateArgs} args - Arguments to update one Autenticacao.
     * @example
     * // Update one Autenticacao
     * const autenticacao = await prisma.autenticacao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends autenticacaoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, autenticacaoUpdateArgs<ExtArgs>>
    ): Prisma__autenticacaoClient<$Result.GetResult<Prisma.$autenticacaoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Autenticacaos.
     * @param {autenticacaoDeleteManyArgs} args - Arguments to filter Autenticacaos to delete.
     * @example
     * // Delete a few Autenticacaos
     * const { count } = await prisma.autenticacao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends autenticacaoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, autenticacaoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Autenticacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autenticacaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Autenticacaos
     * const autenticacao = await prisma.autenticacao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends autenticacaoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, autenticacaoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Autenticacao.
     * @param {autenticacaoUpsertArgs} args - Arguments to update or create a Autenticacao.
     * @example
     * // Update or create a Autenticacao
     * const autenticacao = await prisma.autenticacao.upsert({
     *   create: {
     *     // ... data to create a Autenticacao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Autenticacao we want to update
     *   }
     * })
    **/
    upsert<T extends autenticacaoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, autenticacaoUpsertArgs<ExtArgs>>
    ): Prisma__autenticacaoClient<$Result.GetResult<Prisma.$autenticacaoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Autenticacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autenticacaoCountArgs} args - Arguments to filter Autenticacaos to count.
     * @example
     * // Count the number of Autenticacaos
     * const count = await prisma.autenticacao.count({
     *   where: {
     *     // ... the filter for the Autenticacaos we want to count
     *   }
     * })
    **/
    count<T extends autenticacaoCountArgs>(
      args?: Subset<T, autenticacaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutenticacaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Autenticacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutenticacaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutenticacaoAggregateArgs>(args: Subset<T, AutenticacaoAggregateArgs>): Prisma.PrismaPromise<GetAutenticacaoAggregateType<T>>

    /**
     * Group by Autenticacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autenticacaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends autenticacaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: autenticacaoGroupByArgs['orderBy'] }
        : { orderBy?: autenticacaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, autenticacaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutenticacaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the autenticacao model
   */
  readonly fields: autenticacaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for autenticacao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__autenticacaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    conta<T extends contasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, contasDefaultArgs<ExtArgs>>): Prisma__contasClient<$Result.GetResult<Prisma.$contasPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the autenticacao model
   */ 
  interface autenticacaoFieldRefs {
    readonly idAutenticacao: FieldRef<"autenticacao", 'Int'>
    readonly email: FieldRef<"autenticacao", 'String'>
    readonly senha: FieldRef<"autenticacao", 'String'>
    readonly idConta: FieldRef<"autenticacao", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * autenticacao findUnique
   */
  export type autenticacaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autenticacao
     */
    select?: autenticacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: autenticacaoInclude<ExtArgs> | null
    /**
     * Filter, which autenticacao to fetch.
     */
    where: autenticacaoWhereUniqueInput
  }


  /**
   * autenticacao findUniqueOrThrow
   */
  export type autenticacaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autenticacao
     */
    select?: autenticacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: autenticacaoInclude<ExtArgs> | null
    /**
     * Filter, which autenticacao to fetch.
     */
    where: autenticacaoWhereUniqueInput
  }


  /**
   * autenticacao findFirst
   */
  export type autenticacaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autenticacao
     */
    select?: autenticacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: autenticacaoInclude<ExtArgs> | null
    /**
     * Filter, which autenticacao to fetch.
     */
    where?: autenticacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autenticacaos to fetch.
     */
    orderBy?: autenticacaoOrderByWithRelationInput | autenticacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for autenticacaos.
     */
    cursor?: autenticacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autenticacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autenticacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of autenticacaos.
     */
    distinct?: AutenticacaoScalarFieldEnum | AutenticacaoScalarFieldEnum[]
  }


  /**
   * autenticacao findFirstOrThrow
   */
  export type autenticacaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autenticacao
     */
    select?: autenticacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: autenticacaoInclude<ExtArgs> | null
    /**
     * Filter, which autenticacao to fetch.
     */
    where?: autenticacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autenticacaos to fetch.
     */
    orderBy?: autenticacaoOrderByWithRelationInput | autenticacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for autenticacaos.
     */
    cursor?: autenticacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autenticacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autenticacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of autenticacaos.
     */
    distinct?: AutenticacaoScalarFieldEnum | AutenticacaoScalarFieldEnum[]
  }


  /**
   * autenticacao findMany
   */
  export type autenticacaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autenticacao
     */
    select?: autenticacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: autenticacaoInclude<ExtArgs> | null
    /**
     * Filter, which autenticacaos to fetch.
     */
    where?: autenticacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autenticacaos to fetch.
     */
    orderBy?: autenticacaoOrderByWithRelationInput | autenticacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing autenticacaos.
     */
    cursor?: autenticacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autenticacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autenticacaos.
     */
    skip?: number
    distinct?: AutenticacaoScalarFieldEnum | AutenticacaoScalarFieldEnum[]
  }


  /**
   * autenticacao create
   */
  export type autenticacaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autenticacao
     */
    select?: autenticacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: autenticacaoInclude<ExtArgs> | null
    /**
     * The data needed to create a autenticacao.
     */
    data: XOR<autenticacaoCreateInput, autenticacaoUncheckedCreateInput>
  }


  /**
   * autenticacao createMany
   */
  export type autenticacaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many autenticacaos.
     */
    data: autenticacaoCreateManyInput | autenticacaoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * autenticacao update
   */
  export type autenticacaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autenticacao
     */
    select?: autenticacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: autenticacaoInclude<ExtArgs> | null
    /**
     * The data needed to update a autenticacao.
     */
    data: XOR<autenticacaoUpdateInput, autenticacaoUncheckedUpdateInput>
    /**
     * Choose, which autenticacao to update.
     */
    where: autenticacaoWhereUniqueInput
  }


  /**
   * autenticacao updateMany
   */
  export type autenticacaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update autenticacaos.
     */
    data: XOR<autenticacaoUpdateManyMutationInput, autenticacaoUncheckedUpdateManyInput>
    /**
     * Filter which autenticacaos to update
     */
    where?: autenticacaoWhereInput
  }


  /**
   * autenticacao upsert
   */
  export type autenticacaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autenticacao
     */
    select?: autenticacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: autenticacaoInclude<ExtArgs> | null
    /**
     * The filter to search for the autenticacao to update in case it exists.
     */
    where: autenticacaoWhereUniqueInput
    /**
     * In case the autenticacao found by the `where` argument doesn't exist, create a new autenticacao with this data.
     */
    create: XOR<autenticacaoCreateInput, autenticacaoUncheckedCreateInput>
    /**
     * In case the autenticacao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<autenticacaoUpdateInput, autenticacaoUncheckedUpdateInput>
  }


  /**
   * autenticacao delete
   */
  export type autenticacaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autenticacao
     */
    select?: autenticacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: autenticacaoInclude<ExtArgs> | null
    /**
     * Filter which autenticacao to delete.
     */
    where: autenticacaoWhereUniqueInput
  }


  /**
   * autenticacao deleteMany
   */
  export type autenticacaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which autenticacaos to delete
     */
    where?: autenticacaoWhereInput
  }


  /**
   * autenticacao without action
   */
  export type autenticacaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autenticacao
     */
    select?: autenticacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: autenticacaoInclude<ExtArgs> | null
  }



  /**
   * Model contas
   */

  export type AggregateContas = {
    _count: ContasCountAggregateOutputType | null
    _avg: ContasAvgAggregateOutputType | null
    _sum: ContasSumAggregateOutputType | null
    _min: ContasMinAggregateOutputType | null
    _max: ContasMaxAggregateOutputType | null
  }

  export type ContasAvgAggregateOutputType = {
    idConta: number | null
    idQuestionario: number | null
  }

  export type ContasSumAggregateOutputType = {
    idConta: number | null
    idQuestionario: number | null
  }

  export type ContasMinAggregateOutputType = {
    idConta: number | null
    nome: string | null
    data_nasc: Date | null
    foto: string | null
    celular: string | null
    fagerstrom: boolean | null
    perfil: $Enums.contas_perfil | null
    idQuestionario: number | null
  }

  export type ContasMaxAggregateOutputType = {
    idConta: number | null
    nome: string | null
    data_nasc: Date | null
    foto: string | null
    celular: string | null
    fagerstrom: boolean | null
    perfil: $Enums.contas_perfil | null
    idQuestionario: number | null
  }

  export type ContasCountAggregateOutputType = {
    idConta: number
    nome: number
    data_nasc: number
    foto: number
    celular: number
    fagerstrom: number
    perfil: number
    idQuestionario: number
    _all: number
  }


  export type ContasAvgAggregateInputType = {
    idConta?: true
    idQuestionario?: true
  }

  export type ContasSumAggregateInputType = {
    idConta?: true
    idQuestionario?: true
  }

  export type ContasMinAggregateInputType = {
    idConta?: true
    nome?: true
    data_nasc?: true
    foto?: true
    celular?: true
    fagerstrom?: true
    perfil?: true
    idQuestionario?: true
  }

  export type ContasMaxAggregateInputType = {
    idConta?: true
    nome?: true
    data_nasc?: true
    foto?: true
    celular?: true
    fagerstrom?: true
    perfil?: true
    idQuestionario?: true
  }

  export type ContasCountAggregateInputType = {
    idConta?: true
    nome?: true
    data_nasc?: true
    foto?: true
    celular?: true
    fagerstrom?: true
    perfil?: true
    idQuestionario?: true
    _all?: true
  }

  export type ContasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contas to aggregate.
     */
    where?: contasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contas to fetch.
     */
    orderBy?: contasOrderByWithRelationInput | contasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: contasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned contas
    **/
    _count?: true | ContasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContasMaxAggregateInputType
  }

  export type GetContasAggregateType<T extends ContasAggregateArgs> = {
        [P in keyof T & keyof AggregateContas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContas[P]>
      : GetScalarType<T[P], AggregateContas[P]>
  }




  export type contasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contasWhereInput
    orderBy?: contasOrderByWithAggregationInput | contasOrderByWithAggregationInput[]
    by: ContasScalarFieldEnum[] | ContasScalarFieldEnum
    having?: contasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContasCountAggregateInputType | true
    _avg?: ContasAvgAggregateInputType
    _sum?: ContasSumAggregateInputType
    _min?: ContasMinAggregateInputType
    _max?: ContasMaxAggregateInputType
  }

  export type ContasGroupByOutputType = {
    idConta: number
    nome: string
    data_nasc: Date
    foto: string | null
    celular: string
    fagerstrom: boolean
    perfil: $Enums.contas_perfil
    idQuestionario: number | null
    _count: ContasCountAggregateOutputType | null
    _avg: ContasAvgAggregateOutputType | null
    _sum: ContasSumAggregateOutputType | null
    _min: ContasMinAggregateOutputType | null
    _max: ContasMaxAggregateOutputType | null
  }

  type GetContasGroupByPayload<T extends contasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContasGroupByOutputType[P]>
            : GetScalarType<T[P], ContasGroupByOutputType[P]>
        }
      >
    >


  export type contasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idConta?: boolean
    nome?: boolean
    data_nasc?: boolean
    foto?: boolean
    celular?: boolean
    fagerstrom?: boolean
    perfil?: boolean
    idQuestionario?: boolean
    autenticacao?: boolean | contas$autenticacaoArgs<ExtArgs>
    historicoPagamento?: boolean | contas$historicoPagamentoArgs<ExtArgs>
    assinaturas?: boolean | contas$assinaturasArgs<ExtArgs>
    questionario?: boolean | contas$questionarioArgs<ExtArgs>
    _count?: boolean | ContasCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contas"]>

  export type contasSelectScalar = {
    idConta?: boolean
    nome?: boolean
    data_nasc?: boolean
    foto?: boolean
    celular?: boolean
    fagerstrom?: boolean
    perfil?: boolean
    idQuestionario?: boolean
  }

  export type contasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    autenticacao?: boolean | contas$autenticacaoArgs<ExtArgs>
    historicoPagamento?: boolean | contas$historicoPagamentoArgs<ExtArgs>
    assinaturas?: boolean | contas$assinaturasArgs<ExtArgs>
    questionario?: boolean | contas$questionarioArgs<ExtArgs>
    _count?: boolean | ContasCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $contasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "contas"
    objects: {
      autenticacao: Prisma.$autenticacaoPayload<ExtArgs>[]
      historicoPagamento: Prisma.$historicoPagamentoPayload<ExtArgs>[]
      assinaturas: Prisma.$assinaturaPayload<ExtArgs>[]
      questionario: Prisma.$questionarioPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      idConta: number
      nome: string
      data_nasc: Date
      foto: string | null
      celular: string
      fagerstrom: boolean
      perfil: $Enums.contas_perfil
      idQuestionario: number | null
    }, ExtArgs["result"]["contas"]>
    composites: {}
  }


  type contasGetPayload<S extends boolean | null | undefined | contasDefaultArgs> = $Result.GetResult<Prisma.$contasPayload, S>

  type contasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<contasFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContasCountAggregateInputType | true
    }

  export interface contasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['contas'], meta: { name: 'contas' } }
    /**
     * Find zero or one Contas that matches the filter.
     * @param {contasFindUniqueArgs} args - Arguments to find a Contas
     * @example
     * // Get one Contas
     * const contas = await prisma.contas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends contasFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, contasFindUniqueArgs<ExtArgs>>
    ): Prisma__contasClient<$Result.GetResult<Prisma.$contasPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Contas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {contasFindUniqueOrThrowArgs} args - Arguments to find a Contas
     * @example
     * // Get one Contas
     * const contas = await prisma.contas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends contasFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, contasFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__contasClient<$Result.GetResult<Prisma.$contasPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Contas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contasFindFirstArgs} args - Arguments to find a Contas
     * @example
     * // Get one Contas
     * const contas = await prisma.contas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends contasFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, contasFindFirstArgs<ExtArgs>>
    ): Prisma__contasClient<$Result.GetResult<Prisma.$contasPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Contas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contasFindFirstOrThrowArgs} args - Arguments to find a Contas
     * @example
     * // Get one Contas
     * const contas = await prisma.contas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends contasFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, contasFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__contasClient<$Result.GetResult<Prisma.$contasPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Contas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contas
     * const contas = await prisma.contas.findMany()
     * 
     * // Get first 10 Contas
     * const contas = await prisma.contas.findMany({ take: 10 })
     * 
     * // Only select the `idConta`
     * const contasWithIdContaOnly = await prisma.contas.findMany({ select: { idConta: true } })
     * 
    **/
    findMany<T extends contasFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, contasFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contasPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Contas.
     * @param {contasCreateArgs} args - Arguments to create a Contas.
     * @example
     * // Create one Contas
     * const Contas = await prisma.contas.create({
     *   data: {
     *     // ... data to create a Contas
     *   }
     * })
     * 
    **/
    create<T extends contasCreateArgs<ExtArgs>>(
      args: SelectSubset<T, contasCreateArgs<ExtArgs>>
    ): Prisma__contasClient<$Result.GetResult<Prisma.$contasPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Contas.
     *     @param {contasCreateManyArgs} args - Arguments to create many Contas.
     *     @example
     *     // Create many Contas
     *     const contas = await prisma.contas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends contasCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, contasCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contas.
     * @param {contasDeleteArgs} args - Arguments to delete one Contas.
     * @example
     * // Delete one Contas
     * const Contas = await prisma.contas.delete({
     *   where: {
     *     // ... filter to delete one Contas
     *   }
     * })
     * 
    **/
    delete<T extends contasDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, contasDeleteArgs<ExtArgs>>
    ): Prisma__contasClient<$Result.GetResult<Prisma.$contasPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Contas.
     * @param {contasUpdateArgs} args - Arguments to update one Contas.
     * @example
     * // Update one Contas
     * const contas = await prisma.contas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends contasUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, contasUpdateArgs<ExtArgs>>
    ): Prisma__contasClient<$Result.GetResult<Prisma.$contasPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Contas.
     * @param {contasDeleteManyArgs} args - Arguments to filter Contas to delete.
     * @example
     * // Delete a few Contas
     * const { count } = await prisma.contas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends contasDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, contasDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contas
     * const contas = await prisma.contas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends contasUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, contasUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contas.
     * @param {contasUpsertArgs} args - Arguments to update or create a Contas.
     * @example
     * // Update or create a Contas
     * const contas = await prisma.contas.upsert({
     *   create: {
     *     // ... data to create a Contas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contas we want to update
     *   }
     * })
    **/
    upsert<T extends contasUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, contasUpsertArgs<ExtArgs>>
    ): Prisma__contasClient<$Result.GetResult<Prisma.$contasPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Contas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contasCountArgs} args - Arguments to filter Contas to count.
     * @example
     * // Count the number of Contas
     * const count = await prisma.contas.count({
     *   where: {
     *     // ... the filter for the Contas we want to count
     *   }
     * })
    **/
    count<T extends contasCountArgs>(
      args?: Subset<T, contasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContasAggregateArgs>(args: Subset<T, ContasAggregateArgs>): Prisma.PrismaPromise<GetContasAggregateType<T>>

    /**
     * Group by Contas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends contasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: contasGroupByArgs['orderBy'] }
        : { orderBy?: contasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, contasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the contas model
   */
  readonly fields: contasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for contas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__contasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    autenticacao<T extends contas$autenticacaoArgs<ExtArgs> = {}>(args?: Subset<T, contas$autenticacaoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$autenticacaoPayload<ExtArgs>, T, 'findMany'> | Null>;

    historicoPagamento<T extends contas$historicoPagamentoArgs<ExtArgs> = {}>(args?: Subset<T, contas$historicoPagamentoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$historicoPagamentoPayload<ExtArgs>, T, 'findMany'> | Null>;

    assinaturas<T extends contas$assinaturasArgs<ExtArgs> = {}>(args?: Subset<T, contas$assinaturasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$assinaturaPayload<ExtArgs>, T, 'findMany'> | Null>;

    questionario<T extends contas$questionarioArgs<ExtArgs> = {}>(args?: Subset<T, contas$questionarioArgs<ExtArgs>>): Prisma__questionarioClient<$Result.GetResult<Prisma.$questionarioPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the contas model
   */ 
  interface contasFieldRefs {
    readonly idConta: FieldRef<"contas", 'Int'>
    readonly nome: FieldRef<"contas", 'String'>
    readonly data_nasc: FieldRef<"contas", 'DateTime'>
    readonly foto: FieldRef<"contas", 'String'>
    readonly celular: FieldRef<"contas", 'String'>
    readonly fagerstrom: FieldRef<"contas", 'Boolean'>
    readonly perfil: FieldRef<"contas", 'contas_perfil'>
    readonly idQuestionario: FieldRef<"contas", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * contas findUnique
   */
  export type contasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contas
     */
    select?: contasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contasInclude<ExtArgs> | null
    /**
     * Filter, which contas to fetch.
     */
    where: contasWhereUniqueInput
  }


  /**
   * contas findUniqueOrThrow
   */
  export type contasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contas
     */
    select?: contasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contasInclude<ExtArgs> | null
    /**
     * Filter, which contas to fetch.
     */
    where: contasWhereUniqueInput
  }


  /**
   * contas findFirst
   */
  export type contasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contas
     */
    select?: contasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contasInclude<ExtArgs> | null
    /**
     * Filter, which contas to fetch.
     */
    where?: contasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contas to fetch.
     */
    orderBy?: contasOrderByWithRelationInput | contasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contas.
     */
    cursor?: contasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contas.
     */
    distinct?: ContasScalarFieldEnum | ContasScalarFieldEnum[]
  }


  /**
   * contas findFirstOrThrow
   */
  export type contasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contas
     */
    select?: contasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contasInclude<ExtArgs> | null
    /**
     * Filter, which contas to fetch.
     */
    where?: contasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contas to fetch.
     */
    orderBy?: contasOrderByWithRelationInput | contasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contas.
     */
    cursor?: contasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contas.
     */
    distinct?: ContasScalarFieldEnum | ContasScalarFieldEnum[]
  }


  /**
   * contas findMany
   */
  export type contasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contas
     */
    select?: contasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contasInclude<ExtArgs> | null
    /**
     * Filter, which contas to fetch.
     */
    where?: contasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contas to fetch.
     */
    orderBy?: contasOrderByWithRelationInput | contasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing contas.
     */
    cursor?: contasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contas.
     */
    skip?: number
    distinct?: ContasScalarFieldEnum | ContasScalarFieldEnum[]
  }


  /**
   * contas create
   */
  export type contasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contas
     */
    select?: contasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contasInclude<ExtArgs> | null
    /**
     * The data needed to create a contas.
     */
    data: XOR<contasCreateInput, contasUncheckedCreateInput>
  }


  /**
   * contas createMany
   */
  export type contasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many contas.
     */
    data: contasCreateManyInput | contasCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * contas update
   */
  export type contasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contas
     */
    select?: contasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contasInclude<ExtArgs> | null
    /**
     * The data needed to update a contas.
     */
    data: XOR<contasUpdateInput, contasUncheckedUpdateInput>
    /**
     * Choose, which contas to update.
     */
    where: contasWhereUniqueInput
  }


  /**
   * contas updateMany
   */
  export type contasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update contas.
     */
    data: XOR<contasUpdateManyMutationInput, contasUncheckedUpdateManyInput>
    /**
     * Filter which contas to update
     */
    where?: contasWhereInput
  }


  /**
   * contas upsert
   */
  export type contasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contas
     */
    select?: contasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contasInclude<ExtArgs> | null
    /**
     * The filter to search for the contas to update in case it exists.
     */
    where: contasWhereUniqueInput
    /**
     * In case the contas found by the `where` argument doesn't exist, create a new contas with this data.
     */
    create: XOR<contasCreateInput, contasUncheckedCreateInput>
    /**
     * In case the contas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<contasUpdateInput, contasUncheckedUpdateInput>
  }


  /**
   * contas delete
   */
  export type contasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contas
     */
    select?: contasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contasInclude<ExtArgs> | null
    /**
     * Filter which contas to delete.
     */
    where: contasWhereUniqueInput
  }


  /**
   * contas deleteMany
   */
  export type contasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contas to delete
     */
    where?: contasWhereInput
  }


  /**
   * contas.autenticacao
   */
  export type contas$autenticacaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autenticacao
     */
    select?: autenticacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: autenticacaoInclude<ExtArgs> | null
    where?: autenticacaoWhereInput
    orderBy?: autenticacaoOrderByWithRelationInput | autenticacaoOrderByWithRelationInput[]
    cursor?: autenticacaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutenticacaoScalarFieldEnum | AutenticacaoScalarFieldEnum[]
  }


  /**
   * contas.historicoPagamento
   */
  export type contas$historicoPagamentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historicoPagamento
     */
    select?: historicoPagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: historicoPagamentoInclude<ExtArgs> | null
    where?: historicoPagamentoWhereInput
    orderBy?: historicoPagamentoOrderByWithRelationInput | historicoPagamentoOrderByWithRelationInput[]
    cursor?: historicoPagamentoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HistoricoPagamentoScalarFieldEnum | HistoricoPagamentoScalarFieldEnum[]
  }


  /**
   * contas.assinaturas
   */
  export type contas$assinaturasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assinatura
     */
    select?: assinaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: assinaturaInclude<ExtArgs> | null
    where?: assinaturaWhereInput
    orderBy?: assinaturaOrderByWithRelationInput | assinaturaOrderByWithRelationInput[]
    cursor?: assinaturaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssinaturaScalarFieldEnum | AssinaturaScalarFieldEnum[]
  }


  /**
   * contas.questionario
   */
  export type contas$questionarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionario
     */
    select?: questionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: questionarioInclude<ExtArgs> | null
    where?: questionarioWhereInput
  }


  /**
   * contas without action
   */
  export type contasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contas
     */
    select?: contasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contasInclude<ExtArgs> | null
  }



  /**
   * Model questionario
   */

  export type AggregateQuestionario = {
    _count: QuestionarioCountAggregateOutputType | null
    _avg: QuestionarioAvgAggregateOutputType | null
    _sum: QuestionarioSumAggregateOutputType | null
    _min: QuestionarioMinAggregateOutputType | null
    _max: QuestionarioMaxAggregateOutputType | null
  }

  export type QuestionarioAvgAggregateOutputType = {
    idQuestionario: number | null
  }

  export type QuestionarioSumAggregateOutputType = {
    idQuestionario: number | null
  }

  export type QuestionarioMinAggregateOutputType = {
    idQuestionario: number | null
    questao1: string | null
    questao2: string | null
    questao3: string | null
    questao4: string | null
    questao5: string | null
    questao6: string | null
  }

  export type QuestionarioMaxAggregateOutputType = {
    idQuestionario: number | null
    questao1: string | null
    questao2: string | null
    questao3: string | null
    questao4: string | null
    questao5: string | null
    questao6: string | null
  }

  export type QuestionarioCountAggregateOutputType = {
    idQuestionario: number
    questao1: number
    questao2: number
    questao3: number
    questao4: number
    questao5: number
    questao6: number
    _all: number
  }


  export type QuestionarioAvgAggregateInputType = {
    idQuestionario?: true
  }

  export type QuestionarioSumAggregateInputType = {
    idQuestionario?: true
  }

  export type QuestionarioMinAggregateInputType = {
    idQuestionario?: true
    questao1?: true
    questao2?: true
    questao3?: true
    questao4?: true
    questao5?: true
    questao6?: true
  }

  export type QuestionarioMaxAggregateInputType = {
    idQuestionario?: true
    questao1?: true
    questao2?: true
    questao3?: true
    questao4?: true
    questao5?: true
    questao6?: true
  }

  export type QuestionarioCountAggregateInputType = {
    idQuestionario?: true
    questao1?: true
    questao2?: true
    questao3?: true
    questao4?: true
    questao5?: true
    questao6?: true
    _all?: true
  }

  export type QuestionarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which questionario to aggregate.
     */
    where?: questionarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questionarios to fetch.
     */
    orderBy?: questionarioOrderByWithRelationInput | questionarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: questionarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questionarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questionarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned questionarios
    **/
    _count?: true | QuestionarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionarioMaxAggregateInputType
  }

  export type GetQuestionarioAggregateType<T extends QuestionarioAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionario[P]>
      : GetScalarType<T[P], AggregateQuestionario[P]>
  }




  export type questionarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questionarioWhereInput
    orderBy?: questionarioOrderByWithAggregationInput | questionarioOrderByWithAggregationInput[]
    by: QuestionarioScalarFieldEnum[] | QuestionarioScalarFieldEnum
    having?: questionarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionarioCountAggregateInputType | true
    _avg?: QuestionarioAvgAggregateInputType
    _sum?: QuestionarioSumAggregateInputType
    _min?: QuestionarioMinAggregateInputType
    _max?: QuestionarioMaxAggregateInputType
  }

  export type QuestionarioGroupByOutputType = {
    idQuestionario: number
    questao1: string | null
    questao2: string | null
    questao3: string | null
    questao4: string | null
    questao5: string | null
    questao6: string | null
    _count: QuestionarioCountAggregateOutputType | null
    _avg: QuestionarioAvgAggregateOutputType | null
    _sum: QuestionarioSumAggregateOutputType | null
    _min: QuestionarioMinAggregateOutputType | null
    _max: QuestionarioMaxAggregateOutputType | null
  }

  type GetQuestionarioGroupByPayload<T extends questionarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionarioGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionarioGroupByOutputType[P]>
        }
      >
    >


  export type questionarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idQuestionario?: boolean
    questao1?: boolean
    questao2?: boolean
    questao3?: boolean
    questao4?: boolean
    questao5?: boolean
    questao6?: boolean
    contas?: boolean | questionario$contasArgs<ExtArgs>
    _count?: boolean | QuestionarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionario"]>

  export type questionarioSelectScalar = {
    idQuestionario?: boolean
    questao1?: boolean
    questao2?: boolean
    questao3?: boolean
    questao4?: boolean
    questao5?: boolean
    questao6?: boolean
  }

  export type questionarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contas?: boolean | questionario$contasArgs<ExtArgs>
    _count?: boolean | QuestionarioCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $questionarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "questionario"
    objects: {
      contas: Prisma.$contasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idQuestionario: number
      questao1: string | null
      questao2: string | null
      questao3: string | null
      questao4: string | null
      questao5: string | null
      questao6: string | null
    }, ExtArgs["result"]["questionario"]>
    composites: {}
  }


  type questionarioGetPayload<S extends boolean | null | undefined | questionarioDefaultArgs> = $Result.GetResult<Prisma.$questionarioPayload, S>

  type questionarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<questionarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuestionarioCountAggregateInputType | true
    }

  export interface questionarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['questionario'], meta: { name: 'questionario' } }
    /**
     * Find zero or one Questionario that matches the filter.
     * @param {questionarioFindUniqueArgs} args - Arguments to find a Questionario
     * @example
     * // Get one Questionario
     * const questionario = await prisma.questionario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends questionarioFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, questionarioFindUniqueArgs<ExtArgs>>
    ): Prisma__questionarioClient<$Result.GetResult<Prisma.$questionarioPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Questionario that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {questionarioFindUniqueOrThrowArgs} args - Arguments to find a Questionario
     * @example
     * // Get one Questionario
     * const questionario = await prisma.questionario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends questionarioFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, questionarioFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__questionarioClient<$Result.GetResult<Prisma.$questionarioPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Questionario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionarioFindFirstArgs} args - Arguments to find a Questionario
     * @example
     * // Get one Questionario
     * const questionario = await prisma.questionario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends questionarioFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, questionarioFindFirstArgs<ExtArgs>>
    ): Prisma__questionarioClient<$Result.GetResult<Prisma.$questionarioPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Questionario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionarioFindFirstOrThrowArgs} args - Arguments to find a Questionario
     * @example
     * // Get one Questionario
     * const questionario = await prisma.questionario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends questionarioFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, questionarioFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__questionarioClient<$Result.GetResult<Prisma.$questionarioPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Questionarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionarioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questionarios
     * const questionarios = await prisma.questionario.findMany()
     * 
     * // Get first 10 Questionarios
     * const questionarios = await prisma.questionario.findMany({ take: 10 })
     * 
     * // Only select the `idQuestionario`
     * const questionarioWithIdQuestionarioOnly = await prisma.questionario.findMany({ select: { idQuestionario: true } })
     * 
    **/
    findMany<T extends questionarioFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, questionarioFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionarioPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Questionario.
     * @param {questionarioCreateArgs} args - Arguments to create a Questionario.
     * @example
     * // Create one Questionario
     * const Questionario = await prisma.questionario.create({
     *   data: {
     *     // ... data to create a Questionario
     *   }
     * })
     * 
    **/
    create<T extends questionarioCreateArgs<ExtArgs>>(
      args: SelectSubset<T, questionarioCreateArgs<ExtArgs>>
    ): Prisma__questionarioClient<$Result.GetResult<Prisma.$questionarioPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Questionarios.
     *     @param {questionarioCreateManyArgs} args - Arguments to create many Questionarios.
     *     @example
     *     // Create many Questionarios
     *     const questionario = await prisma.questionario.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends questionarioCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, questionarioCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Questionario.
     * @param {questionarioDeleteArgs} args - Arguments to delete one Questionario.
     * @example
     * // Delete one Questionario
     * const Questionario = await prisma.questionario.delete({
     *   where: {
     *     // ... filter to delete one Questionario
     *   }
     * })
     * 
    **/
    delete<T extends questionarioDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, questionarioDeleteArgs<ExtArgs>>
    ): Prisma__questionarioClient<$Result.GetResult<Prisma.$questionarioPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Questionario.
     * @param {questionarioUpdateArgs} args - Arguments to update one Questionario.
     * @example
     * // Update one Questionario
     * const questionario = await prisma.questionario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends questionarioUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, questionarioUpdateArgs<ExtArgs>>
    ): Prisma__questionarioClient<$Result.GetResult<Prisma.$questionarioPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Questionarios.
     * @param {questionarioDeleteManyArgs} args - Arguments to filter Questionarios to delete.
     * @example
     * // Delete a few Questionarios
     * const { count } = await prisma.questionario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends questionarioDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, questionarioDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questionarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questionarios
     * const questionario = await prisma.questionario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends questionarioUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, questionarioUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Questionario.
     * @param {questionarioUpsertArgs} args - Arguments to update or create a Questionario.
     * @example
     * // Update or create a Questionario
     * const questionario = await prisma.questionario.upsert({
     *   create: {
     *     // ... data to create a Questionario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Questionario we want to update
     *   }
     * })
    **/
    upsert<T extends questionarioUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, questionarioUpsertArgs<ExtArgs>>
    ): Prisma__questionarioClient<$Result.GetResult<Prisma.$questionarioPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Questionarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionarioCountArgs} args - Arguments to filter Questionarios to count.
     * @example
     * // Count the number of Questionarios
     * const count = await prisma.questionario.count({
     *   where: {
     *     // ... the filter for the Questionarios we want to count
     *   }
     * })
    **/
    count<T extends questionarioCountArgs>(
      args?: Subset<T, questionarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Questionario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionarioAggregateArgs>(args: Subset<T, QuestionarioAggregateArgs>): Prisma.PrismaPromise<GetQuestionarioAggregateType<T>>

    /**
     * Group by Questionario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends questionarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: questionarioGroupByArgs['orderBy'] }
        : { orderBy?: questionarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, questionarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the questionario model
   */
  readonly fields: questionarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for questionario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__questionarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    contas<T extends questionario$contasArgs<ExtArgs> = {}>(args?: Subset<T, questionario$contasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contasPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the questionario model
   */ 
  interface questionarioFieldRefs {
    readonly idQuestionario: FieldRef<"questionario", 'Int'>
    readonly questao1: FieldRef<"questionario", 'String'>
    readonly questao2: FieldRef<"questionario", 'String'>
    readonly questao3: FieldRef<"questionario", 'String'>
    readonly questao4: FieldRef<"questionario", 'String'>
    readonly questao5: FieldRef<"questionario", 'String'>
    readonly questao6: FieldRef<"questionario", 'String'>
  }
    

  // Custom InputTypes

  /**
   * questionario findUnique
   */
  export type questionarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionario
     */
    select?: questionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: questionarioInclude<ExtArgs> | null
    /**
     * Filter, which questionario to fetch.
     */
    where: questionarioWhereUniqueInput
  }


  /**
   * questionario findUniqueOrThrow
   */
  export type questionarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionario
     */
    select?: questionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: questionarioInclude<ExtArgs> | null
    /**
     * Filter, which questionario to fetch.
     */
    where: questionarioWhereUniqueInput
  }


  /**
   * questionario findFirst
   */
  export type questionarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionario
     */
    select?: questionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: questionarioInclude<ExtArgs> | null
    /**
     * Filter, which questionario to fetch.
     */
    where?: questionarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questionarios to fetch.
     */
    orderBy?: questionarioOrderByWithRelationInput | questionarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questionarios.
     */
    cursor?: questionarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questionarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questionarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questionarios.
     */
    distinct?: QuestionarioScalarFieldEnum | QuestionarioScalarFieldEnum[]
  }


  /**
   * questionario findFirstOrThrow
   */
  export type questionarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionario
     */
    select?: questionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: questionarioInclude<ExtArgs> | null
    /**
     * Filter, which questionario to fetch.
     */
    where?: questionarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questionarios to fetch.
     */
    orderBy?: questionarioOrderByWithRelationInput | questionarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questionarios.
     */
    cursor?: questionarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questionarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questionarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questionarios.
     */
    distinct?: QuestionarioScalarFieldEnum | QuestionarioScalarFieldEnum[]
  }


  /**
   * questionario findMany
   */
  export type questionarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionario
     */
    select?: questionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: questionarioInclude<ExtArgs> | null
    /**
     * Filter, which questionarios to fetch.
     */
    where?: questionarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questionarios to fetch.
     */
    orderBy?: questionarioOrderByWithRelationInput | questionarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing questionarios.
     */
    cursor?: questionarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questionarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questionarios.
     */
    skip?: number
    distinct?: QuestionarioScalarFieldEnum | QuestionarioScalarFieldEnum[]
  }


  /**
   * questionario create
   */
  export type questionarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionario
     */
    select?: questionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: questionarioInclude<ExtArgs> | null
    /**
     * The data needed to create a questionario.
     */
    data?: XOR<questionarioCreateInput, questionarioUncheckedCreateInput>
  }


  /**
   * questionario createMany
   */
  export type questionarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many questionarios.
     */
    data: questionarioCreateManyInput | questionarioCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * questionario update
   */
  export type questionarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionario
     */
    select?: questionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: questionarioInclude<ExtArgs> | null
    /**
     * The data needed to update a questionario.
     */
    data: XOR<questionarioUpdateInput, questionarioUncheckedUpdateInput>
    /**
     * Choose, which questionario to update.
     */
    where: questionarioWhereUniqueInput
  }


  /**
   * questionario updateMany
   */
  export type questionarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update questionarios.
     */
    data: XOR<questionarioUpdateManyMutationInput, questionarioUncheckedUpdateManyInput>
    /**
     * Filter which questionarios to update
     */
    where?: questionarioWhereInput
  }


  /**
   * questionario upsert
   */
  export type questionarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionario
     */
    select?: questionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: questionarioInclude<ExtArgs> | null
    /**
     * The filter to search for the questionario to update in case it exists.
     */
    where: questionarioWhereUniqueInput
    /**
     * In case the questionario found by the `where` argument doesn't exist, create a new questionario with this data.
     */
    create: XOR<questionarioCreateInput, questionarioUncheckedCreateInput>
    /**
     * In case the questionario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<questionarioUpdateInput, questionarioUncheckedUpdateInput>
  }


  /**
   * questionario delete
   */
  export type questionarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionario
     */
    select?: questionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: questionarioInclude<ExtArgs> | null
    /**
     * Filter which questionario to delete.
     */
    where: questionarioWhereUniqueInput
  }


  /**
   * questionario deleteMany
   */
  export type questionarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which questionarios to delete
     */
    where?: questionarioWhereInput
  }


  /**
   * questionario.contas
   */
  export type questionario$contasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contas
     */
    select?: contasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contasInclude<ExtArgs> | null
    where?: contasWhereInput
    orderBy?: contasOrderByWithRelationInput | contasOrderByWithRelationInput[]
    cursor?: contasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContasScalarFieldEnum | ContasScalarFieldEnum[]
  }


  /**
   * questionario without action
   */
  export type questionarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionario
     */
    select?: questionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: questionarioInclude<ExtArgs> | null
  }



  /**
   * Model geral
   */

  export type AggregateGeral = {
    _count: GeralCountAggregateOutputType | null
    _avg: GeralAvgAggregateOutputType | null
    _sum: GeralSumAggregateOutputType | null
    _min: GeralMinAggregateOutputType | null
    _max: GeralMaxAggregateOutputType | null
  }

  export type GeralAvgAggregateOutputType = {
    idGeral: number | null
  }

  export type GeralSumAggregateOutputType = {
    idGeral: number | null
  }

  export type GeralMinAggregateOutputType = {
    idGeral: number | null
    emailContato: string | null
    emailMedico: string | null
    numeroContato: string | null
  }

  export type GeralMaxAggregateOutputType = {
    idGeral: number | null
    emailContato: string | null
    emailMedico: string | null
    numeroContato: string | null
  }

  export type GeralCountAggregateOutputType = {
    idGeral: number
    emailContato: number
    emailMedico: number
    numeroContato: number
    _all: number
  }


  export type GeralAvgAggregateInputType = {
    idGeral?: true
  }

  export type GeralSumAggregateInputType = {
    idGeral?: true
  }

  export type GeralMinAggregateInputType = {
    idGeral?: true
    emailContato?: true
    emailMedico?: true
    numeroContato?: true
  }

  export type GeralMaxAggregateInputType = {
    idGeral?: true
    emailContato?: true
    emailMedico?: true
    numeroContato?: true
  }

  export type GeralCountAggregateInputType = {
    idGeral?: true
    emailContato?: true
    emailMedico?: true
    numeroContato?: true
    _all?: true
  }

  export type GeralAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which geral to aggregate.
     */
    where?: geralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gerals to fetch.
     */
    orderBy?: geralOrderByWithRelationInput | geralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: geralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gerals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gerals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned gerals
    **/
    _count?: true | GeralCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GeralAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GeralSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GeralMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GeralMaxAggregateInputType
  }

  export type GetGeralAggregateType<T extends GeralAggregateArgs> = {
        [P in keyof T & keyof AggregateGeral]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGeral[P]>
      : GetScalarType<T[P], AggregateGeral[P]>
  }




  export type geralGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: geralWhereInput
    orderBy?: geralOrderByWithAggregationInput | geralOrderByWithAggregationInput[]
    by: GeralScalarFieldEnum[] | GeralScalarFieldEnum
    having?: geralScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GeralCountAggregateInputType | true
    _avg?: GeralAvgAggregateInputType
    _sum?: GeralSumAggregateInputType
    _min?: GeralMinAggregateInputType
    _max?: GeralMaxAggregateInputType
  }

  export type GeralGroupByOutputType = {
    idGeral: number
    emailContato: string
    emailMedico: string
    numeroContato: string
    _count: GeralCountAggregateOutputType | null
    _avg: GeralAvgAggregateOutputType | null
    _sum: GeralSumAggregateOutputType | null
    _min: GeralMinAggregateOutputType | null
    _max: GeralMaxAggregateOutputType | null
  }

  type GetGeralGroupByPayload<T extends geralGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GeralGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GeralGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GeralGroupByOutputType[P]>
            : GetScalarType<T[P], GeralGroupByOutputType[P]>
        }
      >
    >


  export type geralSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idGeral?: boolean
    emailContato?: boolean
    emailMedico?: boolean
    numeroContato?: boolean
  }, ExtArgs["result"]["geral"]>

  export type geralSelectScalar = {
    idGeral?: boolean
    emailContato?: boolean
    emailMedico?: boolean
    numeroContato?: boolean
  }


  export type $geralPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "geral"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      idGeral: number
      emailContato: string
      emailMedico: string
      numeroContato: string
    }, ExtArgs["result"]["geral"]>
    composites: {}
  }


  type geralGetPayload<S extends boolean | null | undefined | geralDefaultArgs> = $Result.GetResult<Prisma.$geralPayload, S>

  type geralCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<geralFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GeralCountAggregateInputType | true
    }

  export interface geralDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['geral'], meta: { name: 'geral' } }
    /**
     * Find zero or one Geral that matches the filter.
     * @param {geralFindUniqueArgs} args - Arguments to find a Geral
     * @example
     * // Get one Geral
     * const geral = await prisma.geral.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends geralFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, geralFindUniqueArgs<ExtArgs>>
    ): Prisma__geralClient<$Result.GetResult<Prisma.$geralPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Geral that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {geralFindUniqueOrThrowArgs} args - Arguments to find a Geral
     * @example
     * // Get one Geral
     * const geral = await prisma.geral.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends geralFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, geralFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__geralClient<$Result.GetResult<Prisma.$geralPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Geral that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {geralFindFirstArgs} args - Arguments to find a Geral
     * @example
     * // Get one Geral
     * const geral = await prisma.geral.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends geralFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, geralFindFirstArgs<ExtArgs>>
    ): Prisma__geralClient<$Result.GetResult<Prisma.$geralPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Geral that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {geralFindFirstOrThrowArgs} args - Arguments to find a Geral
     * @example
     * // Get one Geral
     * const geral = await prisma.geral.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends geralFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, geralFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__geralClient<$Result.GetResult<Prisma.$geralPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Gerals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {geralFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gerals
     * const gerals = await prisma.geral.findMany()
     * 
     * // Get first 10 Gerals
     * const gerals = await prisma.geral.findMany({ take: 10 })
     * 
     * // Only select the `idGeral`
     * const geralWithIdGeralOnly = await prisma.geral.findMany({ select: { idGeral: true } })
     * 
    **/
    findMany<T extends geralFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, geralFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$geralPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Geral.
     * @param {geralCreateArgs} args - Arguments to create a Geral.
     * @example
     * // Create one Geral
     * const Geral = await prisma.geral.create({
     *   data: {
     *     // ... data to create a Geral
     *   }
     * })
     * 
    **/
    create<T extends geralCreateArgs<ExtArgs>>(
      args: SelectSubset<T, geralCreateArgs<ExtArgs>>
    ): Prisma__geralClient<$Result.GetResult<Prisma.$geralPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Gerals.
     *     @param {geralCreateManyArgs} args - Arguments to create many Gerals.
     *     @example
     *     // Create many Gerals
     *     const geral = await prisma.geral.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends geralCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, geralCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Geral.
     * @param {geralDeleteArgs} args - Arguments to delete one Geral.
     * @example
     * // Delete one Geral
     * const Geral = await prisma.geral.delete({
     *   where: {
     *     // ... filter to delete one Geral
     *   }
     * })
     * 
    **/
    delete<T extends geralDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, geralDeleteArgs<ExtArgs>>
    ): Prisma__geralClient<$Result.GetResult<Prisma.$geralPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Geral.
     * @param {geralUpdateArgs} args - Arguments to update one Geral.
     * @example
     * // Update one Geral
     * const geral = await prisma.geral.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends geralUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, geralUpdateArgs<ExtArgs>>
    ): Prisma__geralClient<$Result.GetResult<Prisma.$geralPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Gerals.
     * @param {geralDeleteManyArgs} args - Arguments to filter Gerals to delete.
     * @example
     * // Delete a few Gerals
     * const { count } = await prisma.geral.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends geralDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, geralDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gerals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {geralUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gerals
     * const geral = await prisma.geral.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends geralUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, geralUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Geral.
     * @param {geralUpsertArgs} args - Arguments to update or create a Geral.
     * @example
     * // Update or create a Geral
     * const geral = await prisma.geral.upsert({
     *   create: {
     *     // ... data to create a Geral
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Geral we want to update
     *   }
     * })
    **/
    upsert<T extends geralUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, geralUpsertArgs<ExtArgs>>
    ): Prisma__geralClient<$Result.GetResult<Prisma.$geralPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Gerals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {geralCountArgs} args - Arguments to filter Gerals to count.
     * @example
     * // Count the number of Gerals
     * const count = await prisma.geral.count({
     *   where: {
     *     // ... the filter for the Gerals we want to count
     *   }
     * })
    **/
    count<T extends geralCountArgs>(
      args?: Subset<T, geralCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GeralCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Geral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeralAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GeralAggregateArgs>(args: Subset<T, GeralAggregateArgs>): Prisma.PrismaPromise<GetGeralAggregateType<T>>

    /**
     * Group by Geral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {geralGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends geralGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: geralGroupByArgs['orderBy'] }
        : { orderBy?: geralGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, geralGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGeralGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the geral model
   */
  readonly fields: geralFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for geral.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__geralClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the geral model
   */ 
  interface geralFieldRefs {
    readonly idGeral: FieldRef<"geral", 'Int'>
    readonly emailContato: FieldRef<"geral", 'String'>
    readonly emailMedico: FieldRef<"geral", 'String'>
    readonly numeroContato: FieldRef<"geral", 'String'>
  }
    

  // Custom InputTypes

  /**
   * geral findUnique
   */
  export type geralFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the geral
     */
    select?: geralSelect<ExtArgs> | null
    /**
     * Filter, which geral to fetch.
     */
    where: geralWhereUniqueInput
  }


  /**
   * geral findUniqueOrThrow
   */
  export type geralFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the geral
     */
    select?: geralSelect<ExtArgs> | null
    /**
     * Filter, which geral to fetch.
     */
    where: geralWhereUniqueInput
  }


  /**
   * geral findFirst
   */
  export type geralFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the geral
     */
    select?: geralSelect<ExtArgs> | null
    /**
     * Filter, which geral to fetch.
     */
    where?: geralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gerals to fetch.
     */
    orderBy?: geralOrderByWithRelationInput | geralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gerals.
     */
    cursor?: geralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gerals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gerals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gerals.
     */
    distinct?: GeralScalarFieldEnum | GeralScalarFieldEnum[]
  }


  /**
   * geral findFirstOrThrow
   */
  export type geralFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the geral
     */
    select?: geralSelect<ExtArgs> | null
    /**
     * Filter, which geral to fetch.
     */
    where?: geralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gerals to fetch.
     */
    orderBy?: geralOrderByWithRelationInput | geralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gerals.
     */
    cursor?: geralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gerals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gerals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gerals.
     */
    distinct?: GeralScalarFieldEnum | GeralScalarFieldEnum[]
  }


  /**
   * geral findMany
   */
  export type geralFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the geral
     */
    select?: geralSelect<ExtArgs> | null
    /**
     * Filter, which gerals to fetch.
     */
    where?: geralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gerals to fetch.
     */
    orderBy?: geralOrderByWithRelationInput | geralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing gerals.
     */
    cursor?: geralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gerals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gerals.
     */
    skip?: number
    distinct?: GeralScalarFieldEnum | GeralScalarFieldEnum[]
  }


  /**
   * geral create
   */
  export type geralCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the geral
     */
    select?: geralSelect<ExtArgs> | null
    /**
     * The data needed to create a geral.
     */
    data: XOR<geralCreateInput, geralUncheckedCreateInput>
  }


  /**
   * geral createMany
   */
  export type geralCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many gerals.
     */
    data: geralCreateManyInput | geralCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * geral update
   */
  export type geralUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the geral
     */
    select?: geralSelect<ExtArgs> | null
    /**
     * The data needed to update a geral.
     */
    data: XOR<geralUpdateInput, geralUncheckedUpdateInput>
    /**
     * Choose, which geral to update.
     */
    where: geralWhereUniqueInput
  }


  /**
   * geral updateMany
   */
  export type geralUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update gerals.
     */
    data: XOR<geralUpdateManyMutationInput, geralUncheckedUpdateManyInput>
    /**
     * Filter which gerals to update
     */
    where?: geralWhereInput
  }


  /**
   * geral upsert
   */
  export type geralUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the geral
     */
    select?: geralSelect<ExtArgs> | null
    /**
     * The filter to search for the geral to update in case it exists.
     */
    where: geralWhereUniqueInput
    /**
     * In case the geral found by the `where` argument doesn't exist, create a new geral with this data.
     */
    create: XOR<geralCreateInput, geralUncheckedCreateInput>
    /**
     * In case the geral was found with the provided `where` argument, update it with this data.
     */
    update: XOR<geralUpdateInput, geralUncheckedUpdateInput>
  }


  /**
   * geral delete
   */
  export type geralDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the geral
     */
    select?: geralSelect<ExtArgs> | null
    /**
     * Filter which geral to delete.
     */
    where: geralWhereUniqueInput
  }


  /**
   * geral deleteMany
   */
  export type geralDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which gerals to delete
     */
    where?: geralWhereInput
  }


  /**
   * geral without action
   */
  export type geralDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the geral
     */
    select?: geralSelect<ExtArgs> | null
  }



  /**
   * Model grupos
   */

  export type AggregateGrupos = {
    _count: GruposCountAggregateOutputType | null
    _avg: GruposAvgAggregateOutputType | null
    _sum: GruposSumAggregateOutputType | null
    _min: GruposMinAggregateOutputType | null
    _max: GruposMaxAggregateOutputType | null
  }

  export type GruposAvgAggregateOutputType = {
    idGrupo: number | null
    idPlanos: number | null
  }

  export type GruposSumAggregateOutputType = {
    idGrupo: number | null
    idPlanos: number | null
  }

  export type GruposMinAggregateOutputType = {
    idGrupo: number | null
    dataInicio: Date | null
    dataFinal: Date | null
    link: string | null
    idPlanos: number | null
  }

  export type GruposMaxAggregateOutputType = {
    idGrupo: number | null
    dataInicio: Date | null
    dataFinal: Date | null
    link: string | null
    idPlanos: number | null
  }

  export type GruposCountAggregateOutputType = {
    idGrupo: number
    dataInicio: number
    dataFinal: number
    link: number
    idPlanos: number
    _all: number
  }


  export type GruposAvgAggregateInputType = {
    idGrupo?: true
    idPlanos?: true
  }

  export type GruposSumAggregateInputType = {
    idGrupo?: true
    idPlanos?: true
  }

  export type GruposMinAggregateInputType = {
    idGrupo?: true
    dataInicio?: true
    dataFinal?: true
    link?: true
    idPlanos?: true
  }

  export type GruposMaxAggregateInputType = {
    idGrupo?: true
    dataInicio?: true
    dataFinal?: true
    link?: true
    idPlanos?: true
  }

  export type GruposCountAggregateInputType = {
    idGrupo?: true
    dataInicio?: true
    dataFinal?: true
    link?: true
    idPlanos?: true
    _all?: true
  }

  export type GruposAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which grupos to aggregate.
     */
    where?: gruposWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grupos to fetch.
     */
    orderBy?: gruposOrderByWithRelationInput | gruposOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: gruposWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grupos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grupos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned grupos
    **/
    _count?: true | GruposCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GruposAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GruposSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GruposMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GruposMaxAggregateInputType
  }

  export type GetGruposAggregateType<T extends GruposAggregateArgs> = {
        [P in keyof T & keyof AggregateGrupos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGrupos[P]>
      : GetScalarType<T[P], AggregateGrupos[P]>
  }




  export type gruposGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gruposWhereInput
    orderBy?: gruposOrderByWithAggregationInput | gruposOrderByWithAggregationInput[]
    by: GruposScalarFieldEnum[] | GruposScalarFieldEnum
    having?: gruposScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GruposCountAggregateInputType | true
    _avg?: GruposAvgAggregateInputType
    _sum?: GruposSumAggregateInputType
    _min?: GruposMinAggregateInputType
    _max?: GruposMaxAggregateInputType
  }

  export type GruposGroupByOutputType = {
    idGrupo: number
    dataInicio: Date
    dataFinal: Date
    link: string | null
    idPlanos: number
    _count: GruposCountAggregateOutputType | null
    _avg: GruposAvgAggregateOutputType | null
    _sum: GruposSumAggregateOutputType | null
    _min: GruposMinAggregateOutputType | null
    _max: GruposMaxAggregateOutputType | null
  }

  type GetGruposGroupByPayload<T extends gruposGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GruposGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GruposGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GruposGroupByOutputType[P]>
            : GetScalarType<T[P], GruposGroupByOutputType[P]>
        }
      >
    >


  export type gruposSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idGrupo?: boolean
    dataInicio?: boolean
    dataFinal?: boolean
    link?: boolean
    idPlanos?: boolean
    planos?: boolean | planosDefaultArgs<ExtArgs>
    datas?: boolean | grupos$datasArgs<ExtArgs>
    _count?: boolean | GruposCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grupos"]>

  export type gruposSelectScalar = {
    idGrupo?: boolean
    dataInicio?: boolean
    dataFinal?: boolean
    link?: boolean
    idPlanos?: boolean
  }

  export type gruposInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planos?: boolean | planosDefaultArgs<ExtArgs>
    datas?: boolean | grupos$datasArgs<ExtArgs>
    _count?: boolean | GruposCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $gruposPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "grupos"
    objects: {
      planos: Prisma.$planosPayload<ExtArgs>
      datas: Prisma.$datasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idGrupo: number
      dataInicio: Date
      dataFinal: Date
      link: string | null
      idPlanos: number
    }, ExtArgs["result"]["grupos"]>
    composites: {}
  }


  type gruposGetPayload<S extends boolean | null | undefined | gruposDefaultArgs> = $Result.GetResult<Prisma.$gruposPayload, S>

  type gruposCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<gruposFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GruposCountAggregateInputType | true
    }

  export interface gruposDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['grupos'], meta: { name: 'grupos' } }
    /**
     * Find zero or one Grupos that matches the filter.
     * @param {gruposFindUniqueArgs} args - Arguments to find a Grupos
     * @example
     * // Get one Grupos
     * const grupos = await prisma.grupos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends gruposFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, gruposFindUniqueArgs<ExtArgs>>
    ): Prisma__gruposClient<$Result.GetResult<Prisma.$gruposPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Grupos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {gruposFindUniqueOrThrowArgs} args - Arguments to find a Grupos
     * @example
     * // Get one Grupos
     * const grupos = await prisma.grupos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends gruposFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, gruposFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__gruposClient<$Result.GetResult<Prisma.$gruposPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Grupos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gruposFindFirstArgs} args - Arguments to find a Grupos
     * @example
     * // Get one Grupos
     * const grupos = await prisma.grupos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends gruposFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, gruposFindFirstArgs<ExtArgs>>
    ): Prisma__gruposClient<$Result.GetResult<Prisma.$gruposPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Grupos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gruposFindFirstOrThrowArgs} args - Arguments to find a Grupos
     * @example
     * // Get one Grupos
     * const grupos = await prisma.grupos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends gruposFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, gruposFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__gruposClient<$Result.GetResult<Prisma.$gruposPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Grupos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gruposFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Grupos
     * const grupos = await prisma.grupos.findMany()
     * 
     * // Get first 10 Grupos
     * const grupos = await prisma.grupos.findMany({ take: 10 })
     * 
     * // Only select the `idGrupo`
     * const gruposWithIdGrupoOnly = await prisma.grupos.findMany({ select: { idGrupo: true } })
     * 
    **/
    findMany<T extends gruposFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, gruposFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gruposPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Grupos.
     * @param {gruposCreateArgs} args - Arguments to create a Grupos.
     * @example
     * // Create one Grupos
     * const Grupos = await prisma.grupos.create({
     *   data: {
     *     // ... data to create a Grupos
     *   }
     * })
     * 
    **/
    create<T extends gruposCreateArgs<ExtArgs>>(
      args: SelectSubset<T, gruposCreateArgs<ExtArgs>>
    ): Prisma__gruposClient<$Result.GetResult<Prisma.$gruposPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Grupos.
     *     @param {gruposCreateManyArgs} args - Arguments to create many Grupos.
     *     @example
     *     // Create many Grupos
     *     const grupos = await prisma.grupos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends gruposCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, gruposCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Grupos.
     * @param {gruposDeleteArgs} args - Arguments to delete one Grupos.
     * @example
     * // Delete one Grupos
     * const Grupos = await prisma.grupos.delete({
     *   where: {
     *     // ... filter to delete one Grupos
     *   }
     * })
     * 
    **/
    delete<T extends gruposDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, gruposDeleteArgs<ExtArgs>>
    ): Prisma__gruposClient<$Result.GetResult<Prisma.$gruposPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Grupos.
     * @param {gruposUpdateArgs} args - Arguments to update one Grupos.
     * @example
     * // Update one Grupos
     * const grupos = await prisma.grupos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends gruposUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, gruposUpdateArgs<ExtArgs>>
    ): Prisma__gruposClient<$Result.GetResult<Prisma.$gruposPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Grupos.
     * @param {gruposDeleteManyArgs} args - Arguments to filter Grupos to delete.
     * @example
     * // Delete a few Grupos
     * const { count } = await prisma.grupos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends gruposDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, gruposDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grupos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gruposUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Grupos
     * const grupos = await prisma.grupos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends gruposUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, gruposUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Grupos.
     * @param {gruposUpsertArgs} args - Arguments to update or create a Grupos.
     * @example
     * // Update or create a Grupos
     * const grupos = await prisma.grupos.upsert({
     *   create: {
     *     // ... data to create a Grupos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Grupos we want to update
     *   }
     * })
    **/
    upsert<T extends gruposUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, gruposUpsertArgs<ExtArgs>>
    ): Prisma__gruposClient<$Result.GetResult<Prisma.$gruposPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Grupos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gruposCountArgs} args - Arguments to filter Grupos to count.
     * @example
     * // Count the number of Grupos
     * const count = await prisma.grupos.count({
     *   where: {
     *     // ... the filter for the Grupos we want to count
     *   }
     * })
    **/
    count<T extends gruposCountArgs>(
      args?: Subset<T, gruposCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GruposCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Grupos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GruposAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GruposAggregateArgs>(args: Subset<T, GruposAggregateArgs>): Prisma.PrismaPromise<GetGruposAggregateType<T>>

    /**
     * Group by Grupos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gruposGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends gruposGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: gruposGroupByArgs['orderBy'] }
        : { orderBy?: gruposGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, gruposGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGruposGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the grupos model
   */
  readonly fields: gruposFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for grupos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__gruposClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    planos<T extends planosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, planosDefaultArgs<ExtArgs>>): Prisma__planosClient<$Result.GetResult<Prisma.$planosPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    datas<T extends grupos$datasArgs<ExtArgs> = {}>(args?: Subset<T, grupos$datasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$datasPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the grupos model
   */ 
  interface gruposFieldRefs {
    readonly idGrupo: FieldRef<"grupos", 'Int'>
    readonly dataInicio: FieldRef<"grupos", 'DateTime'>
    readonly dataFinal: FieldRef<"grupos", 'DateTime'>
    readonly link: FieldRef<"grupos", 'String'>
    readonly idPlanos: FieldRef<"grupos", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * grupos findUnique
   */
  export type gruposFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupos
     */
    select?: gruposSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: gruposInclude<ExtArgs> | null
    /**
     * Filter, which grupos to fetch.
     */
    where: gruposWhereUniqueInput
  }


  /**
   * grupos findUniqueOrThrow
   */
  export type gruposFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupos
     */
    select?: gruposSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: gruposInclude<ExtArgs> | null
    /**
     * Filter, which grupos to fetch.
     */
    where: gruposWhereUniqueInput
  }


  /**
   * grupos findFirst
   */
  export type gruposFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupos
     */
    select?: gruposSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: gruposInclude<ExtArgs> | null
    /**
     * Filter, which grupos to fetch.
     */
    where?: gruposWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grupos to fetch.
     */
    orderBy?: gruposOrderByWithRelationInput | gruposOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for grupos.
     */
    cursor?: gruposWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grupos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grupos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of grupos.
     */
    distinct?: GruposScalarFieldEnum | GruposScalarFieldEnum[]
  }


  /**
   * grupos findFirstOrThrow
   */
  export type gruposFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupos
     */
    select?: gruposSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: gruposInclude<ExtArgs> | null
    /**
     * Filter, which grupos to fetch.
     */
    where?: gruposWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grupos to fetch.
     */
    orderBy?: gruposOrderByWithRelationInput | gruposOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for grupos.
     */
    cursor?: gruposWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grupos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grupos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of grupos.
     */
    distinct?: GruposScalarFieldEnum | GruposScalarFieldEnum[]
  }


  /**
   * grupos findMany
   */
  export type gruposFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupos
     */
    select?: gruposSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: gruposInclude<ExtArgs> | null
    /**
     * Filter, which grupos to fetch.
     */
    where?: gruposWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grupos to fetch.
     */
    orderBy?: gruposOrderByWithRelationInput | gruposOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing grupos.
     */
    cursor?: gruposWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grupos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grupos.
     */
    skip?: number
    distinct?: GruposScalarFieldEnum | GruposScalarFieldEnum[]
  }


  /**
   * grupos create
   */
  export type gruposCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupos
     */
    select?: gruposSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: gruposInclude<ExtArgs> | null
    /**
     * The data needed to create a grupos.
     */
    data: XOR<gruposCreateInput, gruposUncheckedCreateInput>
  }


  /**
   * grupos createMany
   */
  export type gruposCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many grupos.
     */
    data: gruposCreateManyInput | gruposCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * grupos update
   */
  export type gruposUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupos
     */
    select?: gruposSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: gruposInclude<ExtArgs> | null
    /**
     * The data needed to update a grupos.
     */
    data: XOR<gruposUpdateInput, gruposUncheckedUpdateInput>
    /**
     * Choose, which grupos to update.
     */
    where: gruposWhereUniqueInput
  }


  /**
   * grupos updateMany
   */
  export type gruposUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update grupos.
     */
    data: XOR<gruposUpdateManyMutationInput, gruposUncheckedUpdateManyInput>
    /**
     * Filter which grupos to update
     */
    where?: gruposWhereInput
  }


  /**
   * grupos upsert
   */
  export type gruposUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupos
     */
    select?: gruposSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: gruposInclude<ExtArgs> | null
    /**
     * The filter to search for the grupos to update in case it exists.
     */
    where: gruposWhereUniqueInput
    /**
     * In case the grupos found by the `where` argument doesn't exist, create a new grupos with this data.
     */
    create: XOR<gruposCreateInput, gruposUncheckedCreateInput>
    /**
     * In case the grupos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<gruposUpdateInput, gruposUncheckedUpdateInput>
  }


  /**
   * grupos delete
   */
  export type gruposDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupos
     */
    select?: gruposSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: gruposInclude<ExtArgs> | null
    /**
     * Filter which grupos to delete.
     */
    where: gruposWhereUniqueInput
  }


  /**
   * grupos deleteMany
   */
  export type gruposDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which grupos to delete
     */
    where?: gruposWhereInput
  }


  /**
   * grupos.datas
   */
  export type grupos$datasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datas
     */
    select?: datasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: datasInclude<ExtArgs> | null
    where?: datasWhereInput
    orderBy?: datasOrderByWithRelationInput | datasOrderByWithRelationInput[]
    cursor?: datasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DatasScalarFieldEnum | DatasScalarFieldEnum[]
  }


  /**
   * grupos without action
   */
  export type gruposDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupos
     */
    select?: gruposSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: gruposInclude<ExtArgs> | null
  }



  /**
   * Model grupoConta
   */

  export type AggregateGrupoConta = {
    _count: GrupoContaCountAggregateOutputType | null
    _avg: GrupoContaAvgAggregateOutputType | null
    _sum: GrupoContaSumAggregateOutputType | null
    _min: GrupoContaMinAggregateOutputType | null
    _max: GrupoContaMaxAggregateOutputType | null
  }

  export type GrupoContaAvgAggregateOutputType = {
    idGrupoConta: number | null
    idGrupo: number | null
    idConta: number | null
  }

  export type GrupoContaSumAggregateOutputType = {
    idGrupoConta: number | null
    idGrupo: number | null
    idConta: number | null
  }

  export type GrupoContaMinAggregateOutputType = {
    idGrupoConta: number | null
    idGrupo: number | null
    idConta: number | null
  }

  export type GrupoContaMaxAggregateOutputType = {
    idGrupoConta: number | null
    idGrupo: number | null
    idConta: number | null
  }

  export type GrupoContaCountAggregateOutputType = {
    idGrupoConta: number
    idGrupo: number
    idConta: number
    _all: number
  }


  export type GrupoContaAvgAggregateInputType = {
    idGrupoConta?: true
    idGrupo?: true
    idConta?: true
  }

  export type GrupoContaSumAggregateInputType = {
    idGrupoConta?: true
    idGrupo?: true
    idConta?: true
  }

  export type GrupoContaMinAggregateInputType = {
    idGrupoConta?: true
    idGrupo?: true
    idConta?: true
  }

  export type GrupoContaMaxAggregateInputType = {
    idGrupoConta?: true
    idGrupo?: true
    idConta?: true
  }

  export type GrupoContaCountAggregateInputType = {
    idGrupoConta?: true
    idGrupo?: true
    idConta?: true
    _all?: true
  }

  export type GrupoContaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which grupoConta to aggregate.
     */
    where?: grupoContaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grupoContas to fetch.
     */
    orderBy?: grupoContaOrderByWithRelationInput | grupoContaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: grupoContaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grupoContas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grupoContas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned grupoContas
    **/
    _count?: true | GrupoContaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GrupoContaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GrupoContaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GrupoContaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GrupoContaMaxAggregateInputType
  }

  export type GetGrupoContaAggregateType<T extends GrupoContaAggregateArgs> = {
        [P in keyof T & keyof AggregateGrupoConta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGrupoConta[P]>
      : GetScalarType<T[P], AggregateGrupoConta[P]>
  }




  export type grupoContaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: grupoContaWhereInput
    orderBy?: grupoContaOrderByWithAggregationInput | grupoContaOrderByWithAggregationInput[]
    by: GrupoContaScalarFieldEnum[] | GrupoContaScalarFieldEnum
    having?: grupoContaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GrupoContaCountAggregateInputType | true
    _avg?: GrupoContaAvgAggregateInputType
    _sum?: GrupoContaSumAggregateInputType
    _min?: GrupoContaMinAggregateInputType
    _max?: GrupoContaMaxAggregateInputType
  }

  export type GrupoContaGroupByOutputType = {
    idGrupoConta: number
    idGrupo: number
    idConta: number
    _count: GrupoContaCountAggregateOutputType | null
    _avg: GrupoContaAvgAggregateOutputType | null
    _sum: GrupoContaSumAggregateOutputType | null
    _min: GrupoContaMinAggregateOutputType | null
    _max: GrupoContaMaxAggregateOutputType | null
  }

  type GetGrupoContaGroupByPayload<T extends grupoContaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GrupoContaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GrupoContaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GrupoContaGroupByOutputType[P]>
            : GetScalarType<T[P], GrupoContaGroupByOutputType[P]>
        }
      >
    >


  export type grupoContaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idGrupoConta?: boolean
    idGrupo?: boolean
    idConta?: boolean
  }, ExtArgs["result"]["grupoConta"]>

  export type grupoContaSelectScalar = {
    idGrupoConta?: boolean
    idGrupo?: boolean
    idConta?: boolean
  }


  export type $grupoContaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "grupoConta"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      idGrupoConta: number
      idGrupo: number
      idConta: number
    }, ExtArgs["result"]["grupoConta"]>
    composites: {}
  }


  type grupoContaGetPayload<S extends boolean | null | undefined | grupoContaDefaultArgs> = $Result.GetResult<Prisma.$grupoContaPayload, S>

  type grupoContaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<grupoContaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GrupoContaCountAggregateInputType | true
    }

  export interface grupoContaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['grupoConta'], meta: { name: 'grupoConta' } }
    /**
     * Find zero or one GrupoConta that matches the filter.
     * @param {grupoContaFindUniqueArgs} args - Arguments to find a GrupoConta
     * @example
     * // Get one GrupoConta
     * const grupoConta = await prisma.grupoConta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends grupoContaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, grupoContaFindUniqueArgs<ExtArgs>>
    ): Prisma__grupoContaClient<$Result.GetResult<Prisma.$grupoContaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one GrupoConta that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {grupoContaFindUniqueOrThrowArgs} args - Arguments to find a GrupoConta
     * @example
     * // Get one GrupoConta
     * const grupoConta = await prisma.grupoConta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends grupoContaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, grupoContaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__grupoContaClient<$Result.GetResult<Prisma.$grupoContaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first GrupoConta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grupoContaFindFirstArgs} args - Arguments to find a GrupoConta
     * @example
     * // Get one GrupoConta
     * const grupoConta = await prisma.grupoConta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends grupoContaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, grupoContaFindFirstArgs<ExtArgs>>
    ): Prisma__grupoContaClient<$Result.GetResult<Prisma.$grupoContaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first GrupoConta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grupoContaFindFirstOrThrowArgs} args - Arguments to find a GrupoConta
     * @example
     * // Get one GrupoConta
     * const grupoConta = await prisma.grupoConta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends grupoContaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, grupoContaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__grupoContaClient<$Result.GetResult<Prisma.$grupoContaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more GrupoContas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grupoContaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GrupoContas
     * const grupoContas = await prisma.grupoConta.findMany()
     * 
     * // Get first 10 GrupoContas
     * const grupoContas = await prisma.grupoConta.findMany({ take: 10 })
     * 
     * // Only select the `idGrupoConta`
     * const grupoContaWithIdGrupoContaOnly = await prisma.grupoConta.findMany({ select: { idGrupoConta: true } })
     * 
    **/
    findMany<T extends grupoContaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, grupoContaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$grupoContaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a GrupoConta.
     * @param {grupoContaCreateArgs} args - Arguments to create a GrupoConta.
     * @example
     * // Create one GrupoConta
     * const GrupoConta = await prisma.grupoConta.create({
     *   data: {
     *     // ... data to create a GrupoConta
     *   }
     * })
     * 
    **/
    create<T extends grupoContaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, grupoContaCreateArgs<ExtArgs>>
    ): Prisma__grupoContaClient<$Result.GetResult<Prisma.$grupoContaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many GrupoContas.
     *     @param {grupoContaCreateManyArgs} args - Arguments to create many GrupoContas.
     *     @example
     *     // Create many GrupoContas
     *     const grupoConta = await prisma.grupoConta.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends grupoContaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, grupoContaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GrupoConta.
     * @param {grupoContaDeleteArgs} args - Arguments to delete one GrupoConta.
     * @example
     * // Delete one GrupoConta
     * const GrupoConta = await prisma.grupoConta.delete({
     *   where: {
     *     // ... filter to delete one GrupoConta
     *   }
     * })
     * 
    **/
    delete<T extends grupoContaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, grupoContaDeleteArgs<ExtArgs>>
    ): Prisma__grupoContaClient<$Result.GetResult<Prisma.$grupoContaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one GrupoConta.
     * @param {grupoContaUpdateArgs} args - Arguments to update one GrupoConta.
     * @example
     * // Update one GrupoConta
     * const grupoConta = await prisma.grupoConta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends grupoContaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, grupoContaUpdateArgs<ExtArgs>>
    ): Prisma__grupoContaClient<$Result.GetResult<Prisma.$grupoContaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more GrupoContas.
     * @param {grupoContaDeleteManyArgs} args - Arguments to filter GrupoContas to delete.
     * @example
     * // Delete a few GrupoContas
     * const { count } = await prisma.grupoConta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends grupoContaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, grupoContaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GrupoContas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grupoContaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GrupoContas
     * const grupoConta = await prisma.grupoConta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends grupoContaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, grupoContaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GrupoConta.
     * @param {grupoContaUpsertArgs} args - Arguments to update or create a GrupoConta.
     * @example
     * // Update or create a GrupoConta
     * const grupoConta = await prisma.grupoConta.upsert({
     *   create: {
     *     // ... data to create a GrupoConta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GrupoConta we want to update
     *   }
     * })
    **/
    upsert<T extends grupoContaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, grupoContaUpsertArgs<ExtArgs>>
    ): Prisma__grupoContaClient<$Result.GetResult<Prisma.$grupoContaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of GrupoContas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grupoContaCountArgs} args - Arguments to filter GrupoContas to count.
     * @example
     * // Count the number of GrupoContas
     * const count = await prisma.grupoConta.count({
     *   where: {
     *     // ... the filter for the GrupoContas we want to count
     *   }
     * })
    **/
    count<T extends grupoContaCountArgs>(
      args?: Subset<T, grupoContaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GrupoContaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GrupoConta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrupoContaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GrupoContaAggregateArgs>(args: Subset<T, GrupoContaAggregateArgs>): Prisma.PrismaPromise<GetGrupoContaAggregateType<T>>

    /**
     * Group by GrupoConta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grupoContaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends grupoContaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: grupoContaGroupByArgs['orderBy'] }
        : { orderBy?: grupoContaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, grupoContaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGrupoContaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the grupoConta model
   */
  readonly fields: grupoContaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for grupoConta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__grupoContaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the grupoConta model
   */ 
  interface grupoContaFieldRefs {
    readonly idGrupoConta: FieldRef<"grupoConta", 'Int'>
    readonly idGrupo: FieldRef<"grupoConta", 'Int'>
    readonly idConta: FieldRef<"grupoConta", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * grupoConta findUnique
   */
  export type grupoContaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupoConta
     */
    select?: grupoContaSelect<ExtArgs> | null
    /**
     * Filter, which grupoConta to fetch.
     */
    where: grupoContaWhereUniqueInput
  }


  /**
   * grupoConta findUniqueOrThrow
   */
  export type grupoContaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupoConta
     */
    select?: grupoContaSelect<ExtArgs> | null
    /**
     * Filter, which grupoConta to fetch.
     */
    where: grupoContaWhereUniqueInput
  }


  /**
   * grupoConta findFirst
   */
  export type grupoContaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupoConta
     */
    select?: grupoContaSelect<ExtArgs> | null
    /**
     * Filter, which grupoConta to fetch.
     */
    where?: grupoContaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grupoContas to fetch.
     */
    orderBy?: grupoContaOrderByWithRelationInput | grupoContaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for grupoContas.
     */
    cursor?: grupoContaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grupoContas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grupoContas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of grupoContas.
     */
    distinct?: GrupoContaScalarFieldEnum | GrupoContaScalarFieldEnum[]
  }


  /**
   * grupoConta findFirstOrThrow
   */
  export type grupoContaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupoConta
     */
    select?: grupoContaSelect<ExtArgs> | null
    /**
     * Filter, which grupoConta to fetch.
     */
    where?: grupoContaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grupoContas to fetch.
     */
    orderBy?: grupoContaOrderByWithRelationInput | grupoContaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for grupoContas.
     */
    cursor?: grupoContaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grupoContas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grupoContas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of grupoContas.
     */
    distinct?: GrupoContaScalarFieldEnum | GrupoContaScalarFieldEnum[]
  }


  /**
   * grupoConta findMany
   */
  export type grupoContaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupoConta
     */
    select?: grupoContaSelect<ExtArgs> | null
    /**
     * Filter, which grupoContas to fetch.
     */
    where?: grupoContaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grupoContas to fetch.
     */
    orderBy?: grupoContaOrderByWithRelationInput | grupoContaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing grupoContas.
     */
    cursor?: grupoContaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grupoContas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grupoContas.
     */
    skip?: number
    distinct?: GrupoContaScalarFieldEnum | GrupoContaScalarFieldEnum[]
  }


  /**
   * grupoConta create
   */
  export type grupoContaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupoConta
     */
    select?: grupoContaSelect<ExtArgs> | null
    /**
     * The data needed to create a grupoConta.
     */
    data: XOR<grupoContaCreateInput, grupoContaUncheckedCreateInput>
  }


  /**
   * grupoConta createMany
   */
  export type grupoContaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many grupoContas.
     */
    data: grupoContaCreateManyInput | grupoContaCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * grupoConta update
   */
  export type grupoContaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupoConta
     */
    select?: grupoContaSelect<ExtArgs> | null
    /**
     * The data needed to update a grupoConta.
     */
    data: XOR<grupoContaUpdateInput, grupoContaUncheckedUpdateInput>
    /**
     * Choose, which grupoConta to update.
     */
    where: grupoContaWhereUniqueInput
  }


  /**
   * grupoConta updateMany
   */
  export type grupoContaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update grupoContas.
     */
    data: XOR<grupoContaUpdateManyMutationInput, grupoContaUncheckedUpdateManyInput>
    /**
     * Filter which grupoContas to update
     */
    where?: grupoContaWhereInput
  }


  /**
   * grupoConta upsert
   */
  export type grupoContaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupoConta
     */
    select?: grupoContaSelect<ExtArgs> | null
    /**
     * The filter to search for the grupoConta to update in case it exists.
     */
    where: grupoContaWhereUniqueInput
    /**
     * In case the grupoConta found by the `where` argument doesn't exist, create a new grupoConta with this data.
     */
    create: XOR<grupoContaCreateInput, grupoContaUncheckedCreateInput>
    /**
     * In case the grupoConta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<grupoContaUpdateInput, grupoContaUncheckedUpdateInput>
  }


  /**
   * grupoConta delete
   */
  export type grupoContaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupoConta
     */
    select?: grupoContaSelect<ExtArgs> | null
    /**
     * Filter which grupoConta to delete.
     */
    where: grupoContaWhereUniqueInput
  }


  /**
   * grupoConta deleteMany
   */
  export type grupoContaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which grupoContas to delete
     */
    where?: grupoContaWhereInput
  }


  /**
   * grupoConta without action
   */
  export type grupoContaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupoConta
     */
    select?: grupoContaSelect<ExtArgs> | null
  }



  /**
   * Model datas
   */

  export type AggregateDatas = {
    _count: DatasCountAggregateOutputType | null
    _avg: DatasAvgAggregateOutputType | null
    _sum: DatasSumAggregateOutputType | null
    _min: DatasMinAggregateOutputType | null
    _max: DatasMaxAggregateOutputType | null
  }

  export type DatasAvgAggregateOutputType = {
    idData: number | null
    idGrupo: number | null
  }

  export type DatasSumAggregateOutputType = {
    idData: number | null
    idGrupo: number | null
  }

  export type DatasMinAggregateOutputType = {
    idData: number | null
    dia: $Enums.dias | null
    hora: string | null
    idGrupo: number | null
  }

  export type DatasMaxAggregateOutputType = {
    idData: number | null
    dia: $Enums.dias | null
    hora: string | null
    idGrupo: number | null
  }

  export type DatasCountAggregateOutputType = {
    idData: number
    dia: number
    hora: number
    idGrupo: number
    _all: number
  }


  export type DatasAvgAggregateInputType = {
    idData?: true
    idGrupo?: true
  }

  export type DatasSumAggregateInputType = {
    idData?: true
    idGrupo?: true
  }

  export type DatasMinAggregateInputType = {
    idData?: true
    dia?: true
    hora?: true
    idGrupo?: true
  }

  export type DatasMaxAggregateInputType = {
    idData?: true
    dia?: true
    hora?: true
    idGrupo?: true
  }

  export type DatasCountAggregateInputType = {
    idData?: true
    dia?: true
    hora?: true
    idGrupo?: true
    _all?: true
  }

  export type DatasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which datas to aggregate.
     */
    where?: datasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of datas to fetch.
     */
    orderBy?: datasOrderByWithRelationInput | datasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: datasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` datas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` datas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned datas
    **/
    _count?: true | DatasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DatasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DatasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DatasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DatasMaxAggregateInputType
  }

  export type GetDatasAggregateType<T extends DatasAggregateArgs> = {
        [P in keyof T & keyof AggregateDatas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDatas[P]>
      : GetScalarType<T[P], AggregateDatas[P]>
  }




  export type datasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: datasWhereInput
    orderBy?: datasOrderByWithAggregationInput | datasOrderByWithAggregationInput[]
    by: DatasScalarFieldEnum[] | DatasScalarFieldEnum
    having?: datasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DatasCountAggregateInputType | true
    _avg?: DatasAvgAggregateInputType
    _sum?: DatasSumAggregateInputType
    _min?: DatasMinAggregateInputType
    _max?: DatasMaxAggregateInputType
  }

  export type DatasGroupByOutputType = {
    idData: number
    dia: $Enums.dias
    hora: string
    idGrupo: number
    _count: DatasCountAggregateOutputType | null
    _avg: DatasAvgAggregateOutputType | null
    _sum: DatasSumAggregateOutputType | null
    _min: DatasMinAggregateOutputType | null
    _max: DatasMaxAggregateOutputType | null
  }

  type GetDatasGroupByPayload<T extends datasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DatasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DatasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DatasGroupByOutputType[P]>
            : GetScalarType<T[P], DatasGroupByOutputType[P]>
        }
      >
    >


  export type datasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idData?: boolean
    dia?: boolean
    hora?: boolean
    idGrupo?: boolean
    grupos?: boolean | gruposDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["datas"]>

  export type datasSelectScalar = {
    idData?: boolean
    dia?: boolean
    hora?: boolean
    idGrupo?: boolean
  }

  export type datasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grupos?: boolean | gruposDefaultArgs<ExtArgs>
  }


  export type $datasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "datas"
    objects: {
      grupos: Prisma.$gruposPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idData: number
      dia: $Enums.dias
      hora: string
      idGrupo: number
    }, ExtArgs["result"]["datas"]>
    composites: {}
  }


  type datasGetPayload<S extends boolean | null | undefined | datasDefaultArgs> = $Result.GetResult<Prisma.$datasPayload, S>

  type datasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<datasFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DatasCountAggregateInputType | true
    }

  export interface datasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['datas'], meta: { name: 'datas' } }
    /**
     * Find zero or one Datas that matches the filter.
     * @param {datasFindUniqueArgs} args - Arguments to find a Datas
     * @example
     * // Get one Datas
     * const datas = await prisma.datas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends datasFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, datasFindUniqueArgs<ExtArgs>>
    ): Prisma__datasClient<$Result.GetResult<Prisma.$datasPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Datas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {datasFindUniqueOrThrowArgs} args - Arguments to find a Datas
     * @example
     * // Get one Datas
     * const datas = await prisma.datas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends datasFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, datasFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__datasClient<$Result.GetResult<Prisma.$datasPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Datas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datasFindFirstArgs} args - Arguments to find a Datas
     * @example
     * // Get one Datas
     * const datas = await prisma.datas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends datasFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, datasFindFirstArgs<ExtArgs>>
    ): Prisma__datasClient<$Result.GetResult<Prisma.$datasPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Datas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datasFindFirstOrThrowArgs} args - Arguments to find a Datas
     * @example
     * // Get one Datas
     * const datas = await prisma.datas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends datasFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, datasFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__datasClient<$Result.GetResult<Prisma.$datasPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Datas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Datas
     * const datas = await prisma.datas.findMany()
     * 
     * // Get first 10 Datas
     * const datas = await prisma.datas.findMany({ take: 10 })
     * 
     * // Only select the `idData`
     * const datasWithIdDataOnly = await prisma.datas.findMany({ select: { idData: true } })
     * 
    **/
    findMany<T extends datasFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, datasFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$datasPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Datas.
     * @param {datasCreateArgs} args - Arguments to create a Datas.
     * @example
     * // Create one Datas
     * const Datas = await prisma.datas.create({
     *   data: {
     *     // ... data to create a Datas
     *   }
     * })
     * 
    **/
    create<T extends datasCreateArgs<ExtArgs>>(
      args: SelectSubset<T, datasCreateArgs<ExtArgs>>
    ): Prisma__datasClient<$Result.GetResult<Prisma.$datasPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Datas.
     *     @param {datasCreateManyArgs} args - Arguments to create many Datas.
     *     @example
     *     // Create many Datas
     *     const datas = await prisma.datas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends datasCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, datasCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Datas.
     * @param {datasDeleteArgs} args - Arguments to delete one Datas.
     * @example
     * // Delete one Datas
     * const Datas = await prisma.datas.delete({
     *   where: {
     *     // ... filter to delete one Datas
     *   }
     * })
     * 
    **/
    delete<T extends datasDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, datasDeleteArgs<ExtArgs>>
    ): Prisma__datasClient<$Result.GetResult<Prisma.$datasPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Datas.
     * @param {datasUpdateArgs} args - Arguments to update one Datas.
     * @example
     * // Update one Datas
     * const datas = await prisma.datas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends datasUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, datasUpdateArgs<ExtArgs>>
    ): Prisma__datasClient<$Result.GetResult<Prisma.$datasPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Datas.
     * @param {datasDeleteManyArgs} args - Arguments to filter Datas to delete.
     * @example
     * // Delete a few Datas
     * const { count } = await prisma.datas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends datasDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, datasDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Datas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Datas
     * const datas = await prisma.datas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends datasUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, datasUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Datas.
     * @param {datasUpsertArgs} args - Arguments to update or create a Datas.
     * @example
     * // Update or create a Datas
     * const datas = await prisma.datas.upsert({
     *   create: {
     *     // ... data to create a Datas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Datas we want to update
     *   }
     * })
    **/
    upsert<T extends datasUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, datasUpsertArgs<ExtArgs>>
    ): Prisma__datasClient<$Result.GetResult<Prisma.$datasPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Datas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datasCountArgs} args - Arguments to filter Datas to count.
     * @example
     * // Count the number of Datas
     * const count = await prisma.datas.count({
     *   where: {
     *     // ... the filter for the Datas we want to count
     *   }
     * })
    **/
    count<T extends datasCountArgs>(
      args?: Subset<T, datasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DatasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Datas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DatasAggregateArgs>(args: Subset<T, DatasAggregateArgs>): Prisma.PrismaPromise<GetDatasAggregateType<T>>

    /**
     * Group by Datas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends datasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: datasGroupByArgs['orderBy'] }
        : { orderBy?: datasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, datasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDatasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the datas model
   */
  readonly fields: datasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for datas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__datasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    grupos<T extends gruposDefaultArgs<ExtArgs> = {}>(args?: Subset<T, gruposDefaultArgs<ExtArgs>>): Prisma__gruposClient<$Result.GetResult<Prisma.$gruposPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the datas model
   */ 
  interface datasFieldRefs {
    readonly idData: FieldRef<"datas", 'Int'>
    readonly dia: FieldRef<"datas", 'dias'>
    readonly hora: FieldRef<"datas", 'String'>
    readonly idGrupo: FieldRef<"datas", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * datas findUnique
   */
  export type datasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datas
     */
    select?: datasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: datasInclude<ExtArgs> | null
    /**
     * Filter, which datas to fetch.
     */
    where: datasWhereUniqueInput
  }


  /**
   * datas findUniqueOrThrow
   */
  export type datasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datas
     */
    select?: datasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: datasInclude<ExtArgs> | null
    /**
     * Filter, which datas to fetch.
     */
    where: datasWhereUniqueInput
  }


  /**
   * datas findFirst
   */
  export type datasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datas
     */
    select?: datasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: datasInclude<ExtArgs> | null
    /**
     * Filter, which datas to fetch.
     */
    where?: datasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of datas to fetch.
     */
    orderBy?: datasOrderByWithRelationInput | datasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for datas.
     */
    cursor?: datasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` datas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` datas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of datas.
     */
    distinct?: DatasScalarFieldEnum | DatasScalarFieldEnum[]
  }


  /**
   * datas findFirstOrThrow
   */
  export type datasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datas
     */
    select?: datasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: datasInclude<ExtArgs> | null
    /**
     * Filter, which datas to fetch.
     */
    where?: datasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of datas to fetch.
     */
    orderBy?: datasOrderByWithRelationInput | datasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for datas.
     */
    cursor?: datasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` datas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` datas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of datas.
     */
    distinct?: DatasScalarFieldEnum | DatasScalarFieldEnum[]
  }


  /**
   * datas findMany
   */
  export type datasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datas
     */
    select?: datasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: datasInclude<ExtArgs> | null
    /**
     * Filter, which datas to fetch.
     */
    where?: datasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of datas to fetch.
     */
    orderBy?: datasOrderByWithRelationInput | datasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing datas.
     */
    cursor?: datasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` datas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` datas.
     */
    skip?: number
    distinct?: DatasScalarFieldEnum | DatasScalarFieldEnum[]
  }


  /**
   * datas create
   */
  export type datasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datas
     */
    select?: datasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: datasInclude<ExtArgs> | null
    /**
     * The data needed to create a datas.
     */
    data: XOR<datasCreateInput, datasUncheckedCreateInput>
  }


  /**
   * datas createMany
   */
  export type datasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many datas.
     */
    data: datasCreateManyInput | datasCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * datas update
   */
  export type datasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datas
     */
    select?: datasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: datasInclude<ExtArgs> | null
    /**
     * The data needed to update a datas.
     */
    data: XOR<datasUpdateInput, datasUncheckedUpdateInput>
    /**
     * Choose, which datas to update.
     */
    where: datasWhereUniqueInput
  }


  /**
   * datas updateMany
   */
  export type datasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update datas.
     */
    data: XOR<datasUpdateManyMutationInput, datasUncheckedUpdateManyInput>
    /**
     * Filter which datas to update
     */
    where?: datasWhereInput
  }


  /**
   * datas upsert
   */
  export type datasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datas
     */
    select?: datasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: datasInclude<ExtArgs> | null
    /**
     * The filter to search for the datas to update in case it exists.
     */
    where: datasWhereUniqueInput
    /**
     * In case the datas found by the `where` argument doesn't exist, create a new datas with this data.
     */
    create: XOR<datasCreateInput, datasUncheckedCreateInput>
    /**
     * In case the datas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<datasUpdateInput, datasUncheckedUpdateInput>
  }


  /**
   * datas delete
   */
  export type datasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datas
     */
    select?: datasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: datasInclude<ExtArgs> | null
    /**
     * Filter which datas to delete.
     */
    where: datasWhereUniqueInput
  }


  /**
   * datas deleteMany
   */
  export type datasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which datas to delete
     */
    where?: datasWhereInput
  }


  /**
   * datas without action
   */
  export type datasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datas
     */
    select?: datasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: datasInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AssinaturaScalarFieldEnum: {
    idAssinatura: 'idAssinatura',
    codPagamento: 'codPagamento',
    ativo: 'ativo',
    data_inicio: 'data_inicio',
    ultimo_update: 'ultimo_update',
    idPlanos: 'idPlanos',
    idConta: 'idConta'
  };

  export type AssinaturaScalarFieldEnum = (typeof AssinaturaScalarFieldEnum)[keyof typeof AssinaturaScalarFieldEnum]


  export const HistoricoPagamentoScalarFieldEnum: {
    idHistoricoPagamento: 'idHistoricoPagamento',
    nome: 'nome',
    descricao: 'descricao',
    pago: 'pago',
    valorTotal: 'valorTotal',
    data_inicio: 'data_inicio',
    idConta: 'idConta'
  };

  export type HistoricoPagamentoScalarFieldEnum = (typeof HistoricoPagamentoScalarFieldEnum)[keyof typeof HistoricoPagamentoScalarFieldEnum]


  export const PlanosScalarFieldEnum: {
    idPlanos: 'idPlanos',
    nome: 'nome',
    subtitulo: 'subtitulo',
    descricao: 'descricao',
    valorTotal: 'valorTotal',
    tipoFuncionalidade: 'tipoFuncionalidade',
    tipo: 'tipo',
    qtdePessoas: 'qtdePessoas',
    meses: 'meses',
    maxSessoes: 'maxSessoes'
  };

  export type PlanosScalarFieldEnum = (typeof PlanosScalarFieldEnum)[keyof typeof PlanosScalarFieldEnum]


  export const AutenticacaoScalarFieldEnum: {
    idAutenticacao: 'idAutenticacao',
    email: 'email',
    senha: 'senha',
    idConta: 'idConta'
  };

  export type AutenticacaoScalarFieldEnum = (typeof AutenticacaoScalarFieldEnum)[keyof typeof AutenticacaoScalarFieldEnum]


  export const ContasScalarFieldEnum: {
    idConta: 'idConta',
    nome: 'nome',
    data_nasc: 'data_nasc',
    foto: 'foto',
    celular: 'celular',
    fagerstrom: 'fagerstrom',
    perfil: 'perfil',
    idQuestionario: 'idQuestionario'
  };

  export type ContasScalarFieldEnum = (typeof ContasScalarFieldEnum)[keyof typeof ContasScalarFieldEnum]


  export const QuestionarioScalarFieldEnum: {
    idQuestionario: 'idQuestionario',
    questao1: 'questao1',
    questao2: 'questao2',
    questao3: 'questao3',
    questao4: 'questao4',
    questao5: 'questao5',
    questao6: 'questao6'
  };

  export type QuestionarioScalarFieldEnum = (typeof QuestionarioScalarFieldEnum)[keyof typeof QuestionarioScalarFieldEnum]


  export const GeralScalarFieldEnum: {
    idGeral: 'idGeral',
    emailContato: 'emailContato',
    emailMedico: 'emailMedico',
    numeroContato: 'numeroContato'
  };

  export type GeralScalarFieldEnum = (typeof GeralScalarFieldEnum)[keyof typeof GeralScalarFieldEnum]


  export const GruposScalarFieldEnum: {
    idGrupo: 'idGrupo',
    dataInicio: 'dataInicio',
    dataFinal: 'dataFinal',
    link: 'link',
    idPlanos: 'idPlanos'
  };

  export type GruposScalarFieldEnum = (typeof GruposScalarFieldEnum)[keyof typeof GruposScalarFieldEnum]


  export const GrupoContaScalarFieldEnum: {
    idGrupoConta: 'idGrupoConta',
    idGrupo: 'idGrupo',
    idConta: 'idConta'
  };

  export type GrupoContaScalarFieldEnum = (typeof GrupoContaScalarFieldEnum)[keyof typeof GrupoContaScalarFieldEnum]


  export const DatasScalarFieldEnum: {
    idData: 'idData',
    dia: 'dia',
    hora: 'hora',
    idGrupo: 'idGrupo'
  };

  export type DatasScalarFieldEnum = (typeof DatasScalarFieldEnum)[keyof typeof DatasScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'tipoFuncionalidade'
   */
  export type EnumtipoFuncionalidadeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'tipoFuncionalidade'>
    


  /**
   * Reference to a field of type 'tipoPlano'
   */
  export type EnumtipoPlanoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'tipoPlano'>
    


  /**
   * Reference to a field of type 'contas_perfil'
   */
  export type Enumcontas_perfilFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'contas_perfil'>
    


  /**
   * Reference to a field of type 'dias'
   */
  export type EnumdiasFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'dias'>
    
  /**
   * Deep Input Types
   */


  export type assinaturaWhereInput = {
    AND?: assinaturaWhereInput | assinaturaWhereInput[]
    OR?: assinaturaWhereInput[]
    NOT?: assinaturaWhereInput | assinaturaWhereInput[]
    idAssinatura?: IntFilter<"assinatura"> | number
    codPagamento?: StringNullableFilter<"assinatura"> | string | null
    ativo?: BoolNullableFilter<"assinatura"> | boolean | null
    data_inicio?: DateTimeNullableFilter<"assinatura"> | Date | string | null
    ultimo_update?: DateTimeNullableFilter<"assinatura"> | Date | string | null
    idPlanos?: IntFilter<"assinatura"> | number
    idConta?: IntFilter<"assinatura"> | number
    planos?: XOR<PlanosRelationFilter, planosWhereInput>
    contas?: XOR<ContasRelationFilter, contasWhereInput>
  }

  export type assinaturaOrderByWithRelationInput = {
    idAssinatura?: SortOrder
    codPagamento?: SortOrderInput | SortOrder
    ativo?: SortOrderInput | SortOrder
    data_inicio?: SortOrderInput | SortOrder
    ultimo_update?: SortOrderInput | SortOrder
    idPlanos?: SortOrder
    idConta?: SortOrder
    planos?: planosOrderByWithRelationInput
    contas?: contasOrderByWithRelationInput
  }

  export type assinaturaWhereUniqueInput = Prisma.AtLeast<{
    idAssinatura?: number
    AND?: assinaturaWhereInput | assinaturaWhereInput[]
    OR?: assinaturaWhereInput[]
    NOT?: assinaturaWhereInput | assinaturaWhereInput[]
    codPagamento?: StringNullableFilter<"assinatura"> | string | null
    ativo?: BoolNullableFilter<"assinatura"> | boolean | null
    data_inicio?: DateTimeNullableFilter<"assinatura"> | Date | string | null
    ultimo_update?: DateTimeNullableFilter<"assinatura"> | Date | string | null
    idPlanos?: IntFilter<"assinatura"> | number
    idConta?: IntFilter<"assinatura"> | number
    planos?: XOR<PlanosRelationFilter, planosWhereInput>
    contas?: XOR<ContasRelationFilter, contasWhereInput>
  }, "idAssinatura">

  export type assinaturaOrderByWithAggregationInput = {
    idAssinatura?: SortOrder
    codPagamento?: SortOrderInput | SortOrder
    ativo?: SortOrderInput | SortOrder
    data_inicio?: SortOrderInput | SortOrder
    ultimo_update?: SortOrderInput | SortOrder
    idPlanos?: SortOrder
    idConta?: SortOrder
    _count?: assinaturaCountOrderByAggregateInput
    _avg?: assinaturaAvgOrderByAggregateInput
    _max?: assinaturaMaxOrderByAggregateInput
    _min?: assinaturaMinOrderByAggregateInput
    _sum?: assinaturaSumOrderByAggregateInput
  }

  export type assinaturaScalarWhereWithAggregatesInput = {
    AND?: assinaturaScalarWhereWithAggregatesInput | assinaturaScalarWhereWithAggregatesInput[]
    OR?: assinaturaScalarWhereWithAggregatesInput[]
    NOT?: assinaturaScalarWhereWithAggregatesInput | assinaturaScalarWhereWithAggregatesInput[]
    idAssinatura?: IntWithAggregatesFilter<"assinatura"> | number
    codPagamento?: StringNullableWithAggregatesFilter<"assinatura"> | string | null
    ativo?: BoolNullableWithAggregatesFilter<"assinatura"> | boolean | null
    data_inicio?: DateTimeNullableWithAggregatesFilter<"assinatura"> | Date | string | null
    ultimo_update?: DateTimeNullableWithAggregatesFilter<"assinatura"> | Date | string | null
    idPlanos?: IntWithAggregatesFilter<"assinatura"> | number
    idConta?: IntWithAggregatesFilter<"assinatura"> | number
  }

  export type historicoPagamentoWhereInput = {
    AND?: historicoPagamentoWhereInput | historicoPagamentoWhereInput[]
    OR?: historicoPagamentoWhereInput[]
    NOT?: historicoPagamentoWhereInput | historicoPagamentoWhereInput[]
    idHistoricoPagamento?: IntFilter<"historicoPagamento"> | number
    nome?: StringFilter<"historicoPagamento"> | string
    descricao?: StringFilter<"historicoPagamento"> | string
    pago?: BoolFilter<"historicoPagamento"> | boolean
    valorTotal?: FloatFilter<"historicoPagamento"> | number
    data_inicio?: DateTimeNullableFilter<"historicoPagamento"> | Date | string | null
    idConta?: IntFilter<"historicoPagamento"> | number
    contas?: XOR<ContasRelationFilter, contasWhereInput>
  }

  export type historicoPagamentoOrderByWithRelationInput = {
    idHistoricoPagamento?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
    pago?: SortOrder
    valorTotal?: SortOrder
    data_inicio?: SortOrderInput | SortOrder
    idConta?: SortOrder
    contas?: contasOrderByWithRelationInput
  }

  export type historicoPagamentoWhereUniqueInput = Prisma.AtLeast<{
    idHistoricoPagamento?: number
    AND?: historicoPagamentoWhereInput | historicoPagamentoWhereInput[]
    OR?: historicoPagamentoWhereInput[]
    NOT?: historicoPagamentoWhereInput | historicoPagamentoWhereInput[]
    nome?: StringFilter<"historicoPagamento"> | string
    descricao?: StringFilter<"historicoPagamento"> | string
    pago?: BoolFilter<"historicoPagamento"> | boolean
    valorTotal?: FloatFilter<"historicoPagamento"> | number
    data_inicio?: DateTimeNullableFilter<"historicoPagamento"> | Date | string | null
    idConta?: IntFilter<"historicoPagamento"> | number
    contas?: XOR<ContasRelationFilter, contasWhereInput>
  }, "idHistoricoPagamento">

  export type historicoPagamentoOrderByWithAggregationInput = {
    idHistoricoPagamento?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
    pago?: SortOrder
    valorTotal?: SortOrder
    data_inicio?: SortOrderInput | SortOrder
    idConta?: SortOrder
    _count?: historicoPagamentoCountOrderByAggregateInput
    _avg?: historicoPagamentoAvgOrderByAggregateInput
    _max?: historicoPagamentoMaxOrderByAggregateInput
    _min?: historicoPagamentoMinOrderByAggregateInput
    _sum?: historicoPagamentoSumOrderByAggregateInput
  }

  export type historicoPagamentoScalarWhereWithAggregatesInput = {
    AND?: historicoPagamentoScalarWhereWithAggregatesInput | historicoPagamentoScalarWhereWithAggregatesInput[]
    OR?: historicoPagamentoScalarWhereWithAggregatesInput[]
    NOT?: historicoPagamentoScalarWhereWithAggregatesInput | historicoPagamentoScalarWhereWithAggregatesInput[]
    idHistoricoPagamento?: IntWithAggregatesFilter<"historicoPagamento"> | number
    nome?: StringWithAggregatesFilter<"historicoPagamento"> | string
    descricao?: StringWithAggregatesFilter<"historicoPagamento"> | string
    pago?: BoolWithAggregatesFilter<"historicoPagamento"> | boolean
    valorTotal?: FloatWithAggregatesFilter<"historicoPagamento"> | number
    data_inicio?: DateTimeNullableWithAggregatesFilter<"historicoPagamento"> | Date | string | null
    idConta?: IntWithAggregatesFilter<"historicoPagamento"> | number
  }

  export type planosWhereInput = {
    AND?: planosWhereInput | planosWhereInput[]
    OR?: planosWhereInput[]
    NOT?: planosWhereInput | planosWhereInput[]
    idPlanos?: IntFilter<"planos"> | number
    nome?: StringFilter<"planos"> | string
    subtitulo?: StringFilter<"planos"> | string
    descricao?: StringFilter<"planos"> | string
    valorTotal?: FloatFilter<"planos"> | number
    tipoFuncionalidade?: EnumtipoFuncionalidadeFilter<"planos"> | $Enums.tipoFuncionalidade
    tipo?: EnumtipoPlanoFilter<"planos"> | $Enums.tipoPlano
    qtdePessoas?: IntFilter<"planos"> | number
    meses?: IntFilter<"planos"> | number
    maxSessoes?: FloatFilter<"planos"> | number
    assinatura?: AssinaturaListRelationFilter
    grupos?: GruposListRelationFilter
  }

  export type planosOrderByWithRelationInput = {
    idPlanos?: SortOrder
    nome?: SortOrder
    subtitulo?: SortOrder
    descricao?: SortOrder
    valorTotal?: SortOrder
    tipoFuncionalidade?: SortOrder
    tipo?: SortOrder
    qtdePessoas?: SortOrder
    meses?: SortOrder
    maxSessoes?: SortOrder
    assinatura?: assinaturaOrderByRelationAggregateInput
    grupos?: gruposOrderByRelationAggregateInput
  }

  export type planosWhereUniqueInput = Prisma.AtLeast<{
    idPlanos?: number
    AND?: planosWhereInput | planosWhereInput[]
    OR?: planosWhereInput[]
    NOT?: planosWhereInput | planosWhereInput[]
    nome?: StringFilter<"planos"> | string
    subtitulo?: StringFilter<"planos"> | string
    descricao?: StringFilter<"planos"> | string
    valorTotal?: FloatFilter<"planos"> | number
    tipoFuncionalidade?: EnumtipoFuncionalidadeFilter<"planos"> | $Enums.tipoFuncionalidade
    tipo?: EnumtipoPlanoFilter<"planos"> | $Enums.tipoPlano
    qtdePessoas?: IntFilter<"planos"> | number
    meses?: IntFilter<"planos"> | number
    maxSessoes?: FloatFilter<"planos"> | number
    assinatura?: AssinaturaListRelationFilter
    grupos?: GruposListRelationFilter
  }, "idPlanos">

  export type planosOrderByWithAggregationInput = {
    idPlanos?: SortOrder
    nome?: SortOrder
    subtitulo?: SortOrder
    descricao?: SortOrder
    valorTotal?: SortOrder
    tipoFuncionalidade?: SortOrder
    tipo?: SortOrder
    qtdePessoas?: SortOrder
    meses?: SortOrder
    maxSessoes?: SortOrder
    _count?: planosCountOrderByAggregateInput
    _avg?: planosAvgOrderByAggregateInput
    _max?: planosMaxOrderByAggregateInput
    _min?: planosMinOrderByAggregateInput
    _sum?: planosSumOrderByAggregateInput
  }

  export type planosScalarWhereWithAggregatesInput = {
    AND?: planosScalarWhereWithAggregatesInput | planosScalarWhereWithAggregatesInput[]
    OR?: planosScalarWhereWithAggregatesInput[]
    NOT?: planosScalarWhereWithAggregatesInput | planosScalarWhereWithAggregatesInput[]
    idPlanos?: IntWithAggregatesFilter<"planos"> | number
    nome?: StringWithAggregatesFilter<"planos"> | string
    subtitulo?: StringWithAggregatesFilter<"planos"> | string
    descricao?: StringWithAggregatesFilter<"planos"> | string
    valorTotal?: FloatWithAggregatesFilter<"planos"> | number
    tipoFuncionalidade?: EnumtipoFuncionalidadeWithAggregatesFilter<"planos"> | $Enums.tipoFuncionalidade
    tipo?: EnumtipoPlanoWithAggregatesFilter<"planos"> | $Enums.tipoPlano
    qtdePessoas?: IntWithAggregatesFilter<"planos"> | number
    meses?: IntWithAggregatesFilter<"planos"> | number
    maxSessoes?: FloatWithAggregatesFilter<"planos"> | number
  }

  export type autenticacaoWhereInput = {
    AND?: autenticacaoWhereInput | autenticacaoWhereInput[]
    OR?: autenticacaoWhereInput[]
    NOT?: autenticacaoWhereInput | autenticacaoWhereInput[]
    idAutenticacao?: IntFilter<"autenticacao"> | number
    email?: StringFilter<"autenticacao"> | string
    senha?: StringFilter<"autenticacao"> | string
    idConta?: IntFilter<"autenticacao"> | number
    conta?: XOR<ContasRelationFilter, contasWhereInput>
  }

  export type autenticacaoOrderByWithRelationInput = {
    idAutenticacao?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    idConta?: SortOrder
    conta?: contasOrderByWithRelationInput
  }

  export type autenticacaoWhereUniqueInput = Prisma.AtLeast<{
    idAutenticacao?: number
    AND?: autenticacaoWhereInput | autenticacaoWhereInput[]
    OR?: autenticacaoWhereInput[]
    NOT?: autenticacaoWhereInput | autenticacaoWhereInput[]
    email?: StringFilter<"autenticacao"> | string
    senha?: StringFilter<"autenticacao"> | string
    idConta?: IntFilter<"autenticacao"> | number
    conta?: XOR<ContasRelationFilter, contasWhereInput>
  }, "idAutenticacao">

  export type autenticacaoOrderByWithAggregationInput = {
    idAutenticacao?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    idConta?: SortOrder
    _count?: autenticacaoCountOrderByAggregateInput
    _avg?: autenticacaoAvgOrderByAggregateInput
    _max?: autenticacaoMaxOrderByAggregateInput
    _min?: autenticacaoMinOrderByAggregateInput
    _sum?: autenticacaoSumOrderByAggregateInput
  }

  export type autenticacaoScalarWhereWithAggregatesInput = {
    AND?: autenticacaoScalarWhereWithAggregatesInput | autenticacaoScalarWhereWithAggregatesInput[]
    OR?: autenticacaoScalarWhereWithAggregatesInput[]
    NOT?: autenticacaoScalarWhereWithAggregatesInput | autenticacaoScalarWhereWithAggregatesInput[]
    idAutenticacao?: IntWithAggregatesFilter<"autenticacao"> | number
    email?: StringWithAggregatesFilter<"autenticacao"> | string
    senha?: StringWithAggregatesFilter<"autenticacao"> | string
    idConta?: IntWithAggregatesFilter<"autenticacao"> | number
  }

  export type contasWhereInput = {
    AND?: contasWhereInput | contasWhereInput[]
    OR?: contasWhereInput[]
    NOT?: contasWhereInput | contasWhereInput[]
    idConta?: IntFilter<"contas"> | number
    nome?: StringFilter<"contas"> | string
    data_nasc?: DateTimeFilter<"contas"> | Date | string
    foto?: StringNullableFilter<"contas"> | string | null
    celular?: StringFilter<"contas"> | string
    fagerstrom?: BoolFilter<"contas"> | boolean
    perfil?: Enumcontas_perfilFilter<"contas"> | $Enums.contas_perfil
    idQuestionario?: IntNullableFilter<"contas"> | number | null
    autenticacao?: AutenticacaoListRelationFilter
    historicoPagamento?: HistoricoPagamentoListRelationFilter
    assinaturas?: AssinaturaListRelationFilter
    questionario?: XOR<QuestionarioNullableRelationFilter, questionarioWhereInput> | null
  }

  export type contasOrderByWithRelationInput = {
    idConta?: SortOrder
    nome?: SortOrder
    data_nasc?: SortOrder
    foto?: SortOrderInput | SortOrder
    celular?: SortOrder
    fagerstrom?: SortOrder
    perfil?: SortOrder
    idQuestionario?: SortOrderInput | SortOrder
    autenticacao?: autenticacaoOrderByRelationAggregateInput
    historicoPagamento?: historicoPagamentoOrderByRelationAggregateInput
    assinaturas?: assinaturaOrderByRelationAggregateInput
    questionario?: questionarioOrderByWithRelationInput
  }

  export type contasWhereUniqueInput = Prisma.AtLeast<{
    idConta?: number
    AND?: contasWhereInput | contasWhereInput[]
    OR?: contasWhereInput[]
    NOT?: contasWhereInput | contasWhereInput[]
    nome?: StringFilter<"contas"> | string
    data_nasc?: DateTimeFilter<"contas"> | Date | string
    foto?: StringNullableFilter<"contas"> | string | null
    celular?: StringFilter<"contas"> | string
    fagerstrom?: BoolFilter<"contas"> | boolean
    perfil?: Enumcontas_perfilFilter<"contas"> | $Enums.contas_perfil
    idQuestionario?: IntNullableFilter<"contas"> | number | null
    autenticacao?: AutenticacaoListRelationFilter
    historicoPagamento?: HistoricoPagamentoListRelationFilter
    assinaturas?: AssinaturaListRelationFilter
    questionario?: XOR<QuestionarioNullableRelationFilter, questionarioWhereInput> | null
  }, "idConta">

  export type contasOrderByWithAggregationInput = {
    idConta?: SortOrder
    nome?: SortOrder
    data_nasc?: SortOrder
    foto?: SortOrderInput | SortOrder
    celular?: SortOrder
    fagerstrom?: SortOrder
    perfil?: SortOrder
    idQuestionario?: SortOrderInput | SortOrder
    _count?: contasCountOrderByAggregateInput
    _avg?: contasAvgOrderByAggregateInput
    _max?: contasMaxOrderByAggregateInput
    _min?: contasMinOrderByAggregateInput
    _sum?: contasSumOrderByAggregateInput
  }

  export type contasScalarWhereWithAggregatesInput = {
    AND?: contasScalarWhereWithAggregatesInput | contasScalarWhereWithAggregatesInput[]
    OR?: contasScalarWhereWithAggregatesInput[]
    NOT?: contasScalarWhereWithAggregatesInput | contasScalarWhereWithAggregatesInput[]
    idConta?: IntWithAggregatesFilter<"contas"> | number
    nome?: StringWithAggregatesFilter<"contas"> | string
    data_nasc?: DateTimeWithAggregatesFilter<"contas"> | Date | string
    foto?: StringNullableWithAggregatesFilter<"contas"> | string | null
    celular?: StringWithAggregatesFilter<"contas"> | string
    fagerstrom?: BoolWithAggregatesFilter<"contas"> | boolean
    perfil?: Enumcontas_perfilWithAggregatesFilter<"contas"> | $Enums.contas_perfil
    idQuestionario?: IntNullableWithAggregatesFilter<"contas"> | number | null
  }

  export type questionarioWhereInput = {
    AND?: questionarioWhereInput | questionarioWhereInput[]
    OR?: questionarioWhereInput[]
    NOT?: questionarioWhereInput | questionarioWhereInput[]
    idQuestionario?: IntFilter<"questionario"> | number
    questao1?: StringNullableFilter<"questionario"> | string | null
    questao2?: StringNullableFilter<"questionario"> | string | null
    questao3?: StringNullableFilter<"questionario"> | string | null
    questao4?: StringNullableFilter<"questionario"> | string | null
    questao5?: StringNullableFilter<"questionario"> | string | null
    questao6?: StringNullableFilter<"questionario"> | string | null
    contas?: ContasListRelationFilter
  }

  export type questionarioOrderByWithRelationInput = {
    idQuestionario?: SortOrder
    questao1?: SortOrderInput | SortOrder
    questao2?: SortOrderInput | SortOrder
    questao3?: SortOrderInput | SortOrder
    questao4?: SortOrderInput | SortOrder
    questao5?: SortOrderInput | SortOrder
    questao6?: SortOrderInput | SortOrder
    contas?: contasOrderByRelationAggregateInput
  }

  export type questionarioWhereUniqueInput = Prisma.AtLeast<{
    idQuestionario?: number
    AND?: questionarioWhereInput | questionarioWhereInput[]
    OR?: questionarioWhereInput[]
    NOT?: questionarioWhereInput | questionarioWhereInput[]
    questao1?: StringNullableFilter<"questionario"> | string | null
    questao2?: StringNullableFilter<"questionario"> | string | null
    questao3?: StringNullableFilter<"questionario"> | string | null
    questao4?: StringNullableFilter<"questionario"> | string | null
    questao5?: StringNullableFilter<"questionario"> | string | null
    questao6?: StringNullableFilter<"questionario"> | string | null
    contas?: ContasListRelationFilter
  }, "idQuestionario">

  export type questionarioOrderByWithAggregationInput = {
    idQuestionario?: SortOrder
    questao1?: SortOrderInput | SortOrder
    questao2?: SortOrderInput | SortOrder
    questao3?: SortOrderInput | SortOrder
    questao4?: SortOrderInput | SortOrder
    questao5?: SortOrderInput | SortOrder
    questao6?: SortOrderInput | SortOrder
    _count?: questionarioCountOrderByAggregateInput
    _avg?: questionarioAvgOrderByAggregateInput
    _max?: questionarioMaxOrderByAggregateInput
    _min?: questionarioMinOrderByAggregateInput
    _sum?: questionarioSumOrderByAggregateInput
  }

  export type questionarioScalarWhereWithAggregatesInput = {
    AND?: questionarioScalarWhereWithAggregatesInput | questionarioScalarWhereWithAggregatesInput[]
    OR?: questionarioScalarWhereWithAggregatesInput[]
    NOT?: questionarioScalarWhereWithAggregatesInput | questionarioScalarWhereWithAggregatesInput[]
    idQuestionario?: IntWithAggregatesFilter<"questionario"> | number
    questao1?: StringNullableWithAggregatesFilter<"questionario"> | string | null
    questao2?: StringNullableWithAggregatesFilter<"questionario"> | string | null
    questao3?: StringNullableWithAggregatesFilter<"questionario"> | string | null
    questao4?: StringNullableWithAggregatesFilter<"questionario"> | string | null
    questao5?: StringNullableWithAggregatesFilter<"questionario"> | string | null
    questao6?: StringNullableWithAggregatesFilter<"questionario"> | string | null
  }

  export type geralWhereInput = {
    AND?: geralWhereInput | geralWhereInput[]
    OR?: geralWhereInput[]
    NOT?: geralWhereInput | geralWhereInput[]
    idGeral?: IntFilter<"geral"> | number
    emailContato?: StringFilter<"geral"> | string
    emailMedico?: StringFilter<"geral"> | string
    numeroContato?: StringFilter<"geral"> | string
  }

  export type geralOrderByWithRelationInput = {
    idGeral?: SortOrder
    emailContato?: SortOrder
    emailMedico?: SortOrder
    numeroContato?: SortOrder
  }

  export type geralWhereUniqueInput = Prisma.AtLeast<{
    idGeral?: number
    AND?: geralWhereInput | geralWhereInput[]
    OR?: geralWhereInput[]
    NOT?: geralWhereInput | geralWhereInput[]
    emailContato?: StringFilter<"geral"> | string
    emailMedico?: StringFilter<"geral"> | string
    numeroContato?: StringFilter<"geral"> | string
  }, "idGeral">

  export type geralOrderByWithAggregationInput = {
    idGeral?: SortOrder
    emailContato?: SortOrder
    emailMedico?: SortOrder
    numeroContato?: SortOrder
    _count?: geralCountOrderByAggregateInput
    _avg?: geralAvgOrderByAggregateInput
    _max?: geralMaxOrderByAggregateInput
    _min?: geralMinOrderByAggregateInput
    _sum?: geralSumOrderByAggregateInput
  }

  export type geralScalarWhereWithAggregatesInput = {
    AND?: geralScalarWhereWithAggregatesInput | geralScalarWhereWithAggregatesInput[]
    OR?: geralScalarWhereWithAggregatesInput[]
    NOT?: geralScalarWhereWithAggregatesInput | geralScalarWhereWithAggregatesInput[]
    idGeral?: IntWithAggregatesFilter<"geral"> | number
    emailContato?: StringWithAggregatesFilter<"geral"> | string
    emailMedico?: StringWithAggregatesFilter<"geral"> | string
    numeroContato?: StringWithAggregatesFilter<"geral"> | string
  }

  export type gruposWhereInput = {
    AND?: gruposWhereInput | gruposWhereInput[]
    OR?: gruposWhereInput[]
    NOT?: gruposWhereInput | gruposWhereInput[]
    idGrupo?: IntFilter<"grupos"> | number
    dataInicio?: DateTimeFilter<"grupos"> | Date | string
    dataFinal?: DateTimeFilter<"grupos"> | Date | string
    link?: StringNullableFilter<"grupos"> | string | null
    idPlanos?: IntFilter<"grupos"> | number
    planos?: XOR<PlanosRelationFilter, planosWhereInput>
    datas?: DatasListRelationFilter
  }

  export type gruposOrderByWithRelationInput = {
    idGrupo?: SortOrder
    dataInicio?: SortOrder
    dataFinal?: SortOrder
    link?: SortOrderInput | SortOrder
    idPlanos?: SortOrder
    planos?: planosOrderByWithRelationInput
    datas?: datasOrderByRelationAggregateInput
  }

  export type gruposWhereUniqueInput = Prisma.AtLeast<{
    idGrupo?: number
    AND?: gruposWhereInput | gruposWhereInput[]
    OR?: gruposWhereInput[]
    NOT?: gruposWhereInput | gruposWhereInput[]
    dataInicio?: DateTimeFilter<"grupos"> | Date | string
    dataFinal?: DateTimeFilter<"grupos"> | Date | string
    link?: StringNullableFilter<"grupos"> | string | null
    idPlanos?: IntFilter<"grupos"> | number
    planos?: XOR<PlanosRelationFilter, planosWhereInput>
    datas?: DatasListRelationFilter
  }, "idGrupo">

  export type gruposOrderByWithAggregationInput = {
    idGrupo?: SortOrder
    dataInicio?: SortOrder
    dataFinal?: SortOrder
    link?: SortOrderInput | SortOrder
    idPlanos?: SortOrder
    _count?: gruposCountOrderByAggregateInput
    _avg?: gruposAvgOrderByAggregateInput
    _max?: gruposMaxOrderByAggregateInput
    _min?: gruposMinOrderByAggregateInput
    _sum?: gruposSumOrderByAggregateInput
  }

  export type gruposScalarWhereWithAggregatesInput = {
    AND?: gruposScalarWhereWithAggregatesInput | gruposScalarWhereWithAggregatesInput[]
    OR?: gruposScalarWhereWithAggregatesInput[]
    NOT?: gruposScalarWhereWithAggregatesInput | gruposScalarWhereWithAggregatesInput[]
    idGrupo?: IntWithAggregatesFilter<"grupos"> | number
    dataInicio?: DateTimeWithAggregatesFilter<"grupos"> | Date | string
    dataFinal?: DateTimeWithAggregatesFilter<"grupos"> | Date | string
    link?: StringNullableWithAggregatesFilter<"grupos"> | string | null
    idPlanos?: IntWithAggregatesFilter<"grupos"> | number
  }

  export type grupoContaWhereInput = {
    AND?: grupoContaWhereInput | grupoContaWhereInput[]
    OR?: grupoContaWhereInput[]
    NOT?: grupoContaWhereInput | grupoContaWhereInput[]
    idGrupoConta?: IntFilter<"grupoConta"> | number
    idGrupo?: IntFilter<"grupoConta"> | number
    idConta?: IntFilter<"grupoConta"> | number
  }

  export type grupoContaOrderByWithRelationInput = {
    idGrupoConta?: SortOrder
    idGrupo?: SortOrder
    idConta?: SortOrder
  }

  export type grupoContaWhereUniqueInput = Prisma.AtLeast<{
    idGrupoConta?: number
    AND?: grupoContaWhereInput | grupoContaWhereInput[]
    OR?: grupoContaWhereInput[]
    NOT?: grupoContaWhereInput | grupoContaWhereInput[]
    idGrupo?: IntFilter<"grupoConta"> | number
    idConta?: IntFilter<"grupoConta"> | number
  }, "idGrupoConta">

  export type grupoContaOrderByWithAggregationInput = {
    idGrupoConta?: SortOrder
    idGrupo?: SortOrder
    idConta?: SortOrder
    _count?: grupoContaCountOrderByAggregateInput
    _avg?: grupoContaAvgOrderByAggregateInput
    _max?: grupoContaMaxOrderByAggregateInput
    _min?: grupoContaMinOrderByAggregateInput
    _sum?: grupoContaSumOrderByAggregateInput
  }

  export type grupoContaScalarWhereWithAggregatesInput = {
    AND?: grupoContaScalarWhereWithAggregatesInput | grupoContaScalarWhereWithAggregatesInput[]
    OR?: grupoContaScalarWhereWithAggregatesInput[]
    NOT?: grupoContaScalarWhereWithAggregatesInput | grupoContaScalarWhereWithAggregatesInput[]
    idGrupoConta?: IntWithAggregatesFilter<"grupoConta"> | number
    idGrupo?: IntWithAggregatesFilter<"grupoConta"> | number
    idConta?: IntWithAggregatesFilter<"grupoConta"> | number
  }

  export type datasWhereInput = {
    AND?: datasWhereInput | datasWhereInput[]
    OR?: datasWhereInput[]
    NOT?: datasWhereInput | datasWhereInput[]
    idData?: IntFilter<"datas"> | number
    dia?: EnumdiasFilter<"datas"> | $Enums.dias
    hora?: StringFilter<"datas"> | string
    idGrupo?: IntFilter<"datas"> | number
    grupos?: XOR<GruposRelationFilter, gruposWhereInput>
  }

  export type datasOrderByWithRelationInput = {
    idData?: SortOrder
    dia?: SortOrder
    hora?: SortOrder
    idGrupo?: SortOrder
    grupos?: gruposOrderByWithRelationInput
  }

  export type datasWhereUniqueInput = Prisma.AtLeast<{
    idData?: number
    AND?: datasWhereInput | datasWhereInput[]
    OR?: datasWhereInput[]
    NOT?: datasWhereInput | datasWhereInput[]
    dia?: EnumdiasFilter<"datas"> | $Enums.dias
    hora?: StringFilter<"datas"> | string
    idGrupo?: IntFilter<"datas"> | number
    grupos?: XOR<GruposRelationFilter, gruposWhereInput>
  }, "idData">

  export type datasOrderByWithAggregationInput = {
    idData?: SortOrder
    dia?: SortOrder
    hora?: SortOrder
    idGrupo?: SortOrder
    _count?: datasCountOrderByAggregateInput
    _avg?: datasAvgOrderByAggregateInput
    _max?: datasMaxOrderByAggregateInput
    _min?: datasMinOrderByAggregateInput
    _sum?: datasSumOrderByAggregateInput
  }

  export type datasScalarWhereWithAggregatesInput = {
    AND?: datasScalarWhereWithAggregatesInput | datasScalarWhereWithAggregatesInput[]
    OR?: datasScalarWhereWithAggregatesInput[]
    NOT?: datasScalarWhereWithAggregatesInput | datasScalarWhereWithAggregatesInput[]
    idData?: IntWithAggregatesFilter<"datas"> | number
    dia?: EnumdiasWithAggregatesFilter<"datas"> | $Enums.dias
    hora?: StringWithAggregatesFilter<"datas"> | string
    idGrupo?: IntWithAggregatesFilter<"datas"> | number
  }

  export type assinaturaCreateInput = {
    codPagamento?: string | null
    ativo?: boolean | null
    data_inicio?: Date | string | null
    ultimo_update?: Date | string | null
    planos: planosCreateNestedOneWithoutAssinaturaInput
    contas: contasCreateNestedOneWithoutAssinaturasInput
  }

  export type assinaturaUncheckedCreateInput = {
    idAssinatura?: number
    codPagamento?: string | null
    ativo?: boolean | null
    data_inicio?: Date | string | null
    ultimo_update?: Date | string | null
    idPlanos: number
    idConta: number
  }

  export type assinaturaUpdateInput = {
    codPagamento?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    data_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimo_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planos?: planosUpdateOneRequiredWithoutAssinaturaNestedInput
    contas?: contasUpdateOneRequiredWithoutAssinaturasNestedInput
  }

  export type assinaturaUncheckedUpdateInput = {
    idAssinatura?: IntFieldUpdateOperationsInput | number
    codPagamento?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    data_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimo_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idPlanos?: IntFieldUpdateOperationsInput | number
    idConta?: IntFieldUpdateOperationsInput | number
  }

  export type assinaturaCreateManyInput = {
    idAssinatura?: number
    codPagamento?: string | null
    ativo?: boolean | null
    data_inicio?: Date | string | null
    ultimo_update?: Date | string | null
    idPlanos: number
    idConta: number
  }

  export type assinaturaUpdateManyMutationInput = {
    codPagamento?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    data_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimo_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type assinaturaUncheckedUpdateManyInput = {
    idAssinatura?: IntFieldUpdateOperationsInput | number
    codPagamento?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    data_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimo_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idPlanos?: IntFieldUpdateOperationsInput | number
    idConta?: IntFieldUpdateOperationsInput | number
  }

  export type historicoPagamentoCreateInput = {
    nome: string
    descricao: string
    pago: boolean
    valorTotal: number
    data_inicio?: Date | string | null
    contas: contasCreateNestedOneWithoutHistoricoPagamentoInput
  }

  export type historicoPagamentoUncheckedCreateInput = {
    idHistoricoPagamento?: number
    nome: string
    descricao: string
    pago: boolean
    valorTotal: number
    data_inicio?: Date | string | null
    idConta: number
  }

  export type historicoPagamentoUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    pago?: BoolFieldUpdateOperationsInput | boolean
    valorTotal?: FloatFieldUpdateOperationsInput | number
    data_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contas?: contasUpdateOneRequiredWithoutHistoricoPagamentoNestedInput
  }

  export type historicoPagamentoUncheckedUpdateInput = {
    idHistoricoPagamento?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    pago?: BoolFieldUpdateOperationsInput | boolean
    valorTotal?: FloatFieldUpdateOperationsInput | number
    data_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idConta?: IntFieldUpdateOperationsInput | number
  }

  export type historicoPagamentoCreateManyInput = {
    idHistoricoPagamento?: number
    nome: string
    descricao: string
    pago: boolean
    valorTotal: number
    data_inicio?: Date | string | null
    idConta: number
  }

  export type historicoPagamentoUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    pago?: BoolFieldUpdateOperationsInput | boolean
    valorTotal?: FloatFieldUpdateOperationsInput | number
    data_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type historicoPagamentoUncheckedUpdateManyInput = {
    idHistoricoPagamento?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    pago?: BoolFieldUpdateOperationsInput | boolean
    valorTotal?: FloatFieldUpdateOperationsInput | number
    data_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idConta?: IntFieldUpdateOperationsInput | number
  }

  export type planosCreateInput = {
    nome: string
    subtitulo: string
    descricao: string
    valorTotal: number
    tipoFuncionalidade: $Enums.tipoFuncionalidade
    tipo: $Enums.tipoPlano
    qtdePessoas: number
    meses: number
    maxSessoes: number
    assinatura?: assinaturaCreateNestedManyWithoutPlanosInput
    grupos?: gruposCreateNestedManyWithoutPlanosInput
  }

  export type planosUncheckedCreateInput = {
    idPlanos?: number
    nome: string
    subtitulo: string
    descricao: string
    valorTotal: number
    tipoFuncionalidade: $Enums.tipoFuncionalidade
    tipo: $Enums.tipoPlano
    qtdePessoas: number
    meses: number
    maxSessoes: number
    assinatura?: assinaturaUncheckedCreateNestedManyWithoutPlanosInput
    grupos?: gruposUncheckedCreateNestedManyWithoutPlanosInput
  }

  export type planosUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    subtitulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    valorTotal?: FloatFieldUpdateOperationsInput | number
    tipoFuncionalidade?: EnumtipoFuncionalidadeFieldUpdateOperationsInput | $Enums.tipoFuncionalidade
    tipo?: EnumtipoPlanoFieldUpdateOperationsInput | $Enums.tipoPlano
    qtdePessoas?: IntFieldUpdateOperationsInput | number
    meses?: IntFieldUpdateOperationsInput | number
    maxSessoes?: FloatFieldUpdateOperationsInput | number
    assinatura?: assinaturaUpdateManyWithoutPlanosNestedInput
    grupos?: gruposUpdateManyWithoutPlanosNestedInput
  }

  export type planosUncheckedUpdateInput = {
    idPlanos?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    subtitulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    valorTotal?: FloatFieldUpdateOperationsInput | number
    tipoFuncionalidade?: EnumtipoFuncionalidadeFieldUpdateOperationsInput | $Enums.tipoFuncionalidade
    tipo?: EnumtipoPlanoFieldUpdateOperationsInput | $Enums.tipoPlano
    qtdePessoas?: IntFieldUpdateOperationsInput | number
    meses?: IntFieldUpdateOperationsInput | number
    maxSessoes?: FloatFieldUpdateOperationsInput | number
    assinatura?: assinaturaUncheckedUpdateManyWithoutPlanosNestedInput
    grupos?: gruposUncheckedUpdateManyWithoutPlanosNestedInput
  }

  export type planosCreateManyInput = {
    idPlanos?: number
    nome: string
    subtitulo: string
    descricao: string
    valorTotal: number
    tipoFuncionalidade: $Enums.tipoFuncionalidade
    tipo: $Enums.tipoPlano
    qtdePessoas: number
    meses: number
    maxSessoes: number
  }

  export type planosUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    subtitulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    valorTotal?: FloatFieldUpdateOperationsInput | number
    tipoFuncionalidade?: EnumtipoFuncionalidadeFieldUpdateOperationsInput | $Enums.tipoFuncionalidade
    tipo?: EnumtipoPlanoFieldUpdateOperationsInput | $Enums.tipoPlano
    qtdePessoas?: IntFieldUpdateOperationsInput | number
    meses?: IntFieldUpdateOperationsInput | number
    maxSessoes?: FloatFieldUpdateOperationsInput | number
  }

  export type planosUncheckedUpdateManyInput = {
    idPlanos?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    subtitulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    valorTotal?: FloatFieldUpdateOperationsInput | number
    tipoFuncionalidade?: EnumtipoFuncionalidadeFieldUpdateOperationsInput | $Enums.tipoFuncionalidade
    tipo?: EnumtipoPlanoFieldUpdateOperationsInput | $Enums.tipoPlano
    qtdePessoas?: IntFieldUpdateOperationsInput | number
    meses?: IntFieldUpdateOperationsInput | number
    maxSessoes?: FloatFieldUpdateOperationsInput | number
  }

  export type autenticacaoCreateInput = {
    email: string
    senha: string
    conta: contasCreateNestedOneWithoutAutenticacaoInput
  }

  export type autenticacaoUncheckedCreateInput = {
    idAutenticacao?: number
    email: string
    senha: string
    idConta: number
  }

  export type autenticacaoUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    conta?: contasUpdateOneRequiredWithoutAutenticacaoNestedInput
  }

  export type autenticacaoUncheckedUpdateInput = {
    idAutenticacao?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    idConta?: IntFieldUpdateOperationsInput | number
  }

  export type autenticacaoCreateManyInput = {
    idAutenticacao?: number
    email: string
    senha: string
    idConta: number
  }

  export type autenticacaoUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
  }

  export type autenticacaoUncheckedUpdateManyInput = {
    idAutenticacao?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    idConta?: IntFieldUpdateOperationsInput | number
  }

  export type contasCreateInput = {
    nome: string
    data_nasc: Date | string
    foto?: string | null
    celular: string
    fagerstrom?: boolean
    perfil: $Enums.contas_perfil
    autenticacao?: autenticacaoCreateNestedManyWithoutContaInput
    historicoPagamento?: historicoPagamentoCreateNestedManyWithoutContasInput
    assinaturas?: assinaturaCreateNestedManyWithoutContasInput
    questionario?: questionarioCreateNestedOneWithoutContasInput
  }

  export type contasUncheckedCreateInput = {
    idConta?: number
    nome: string
    data_nasc: Date | string
    foto?: string | null
    celular: string
    fagerstrom?: boolean
    perfil: $Enums.contas_perfil
    idQuestionario?: number | null
    autenticacao?: autenticacaoUncheckedCreateNestedManyWithoutContaInput
    historicoPagamento?: historicoPagamentoUncheckedCreateNestedManyWithoutContasInput
    assinaturas?: assinaturaUncheckedCreateNestedManyWithoutContasInput
  }

  export type contasUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    data_nasc?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: StringFieldUpdateOperationsInput | string
    fagerstrom?: BoolFieldUpdateOperationsInput | boolean
    perfil?: Enumcontas_perfilFieldUpdateOperationsInput | $Enums.contas_perfil
    autenticacao?: autenticacaoUpdateManyWithoutContaNestedInput
    historicoPagamento?: historicoPagamentoUpdateManyWithoutContasNestedInput
    assinaturas?: assinaturaUpdateManyWithoutContasNestedInput
    questionario?: questionarioUpdateOneWithoutContasNestedInput
  }

  export type contasUncheckedUpdateInput = {
    idConta?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    data_nasc?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: StringFieldUpdateOperationsInput | string
    fagerstrom?: BoolFieldUpdateOperationsInput | boolean
    perfil?: Enumcontas_perfilFieldUpdateOperationsInput | $Enums.contas_perfil
    idQuestionario?: NullableIntFieldUpdateOperationsInput | number | null
    autenticacao?: autenticacaoUncheckedUpdateManyWithoutContaNestedInput
    historicoPagamento?: historicoPagamentoUncheckedUpdateManyWithoutContasNestedInput
    assinaturas?: assinaturaUncheckedUpdateManyWithoutContasNestedInput
  }

  export type contasCreateManyInput = {
    idConta?: number
    nome: string
    data_nasc: Date | string
    foto?: string | null
    celular: string
    fagerstrom?: boolean
    perfil: $Enums.contas_perfil
    idQuestionario?: number | null
  }

  export type contasUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    data_nasc?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: StringFieldUpdateOperationsInput | string
    fagerstrom?: BoolFieldUpdateOperationsInput | boolean
    perfil?: Enumcontas_perfilFieldUpdateOperationsInput | $Enums.contas_perfil
  }

  export type contasUncheckedUpdateManyInput = {
    idConta?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    data_nasc?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: StringFieldUpdateOperationsInput | string
    fagerstrom?: BoolFieldUpdateOperationsInput | boolean
    perfil?: Enumcontas_perfilFieldUpdateOperationsInput | $Enums.contas_perfil
    idQuestionario?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type questionarioCreateInput = {
    questao1?: string | null
    questao2?: string | null
    questao3?: string | null
    questao4?: string | null
    questao5?: string | null
    questao6?: string | null
    contas?: contasCreateNestedManyWithoutQuestionarioInput
  }

  export type questionarioUncheckedCreateInput = {
    idQuestionario?: number
    questao1?: string | null
    questao2?: string | null
    questao3?: string | null
    questao4?: string | null
    questao5?: string | null
    questao6?: string | null
    contas?: contasUncheckedCreateNestedManyWithoutQuestionarioInput
  }

  export type questionarioUpdateInput = {
    questao1?: NullableStringFieldUpdateOperationsInput | string | null
    questao2?: NullableStringFieldUpdateOperationsInput | string | null
    questao3?: NullableStringFieldUpdateOperationsInput | string | null
    questao4?: NullableStringFieldUpdateOperationsInput | string | null
    questao5?: NullableStringFieldUpdateOperationsInput | string | null
    questao6?: NullableStringFieldUpdateOperationsInput | string | null
    contas?: contasUpdateManyWithoutQuestionarioNestedInput
  }

  export type questionarioUncheckedUpdateInput = {
    idQuestionario?: IntFieldUpdateOperationsInput | number
    questao1?: NullableStringFieldUpdateOperationsInput | string | null
    questao2?: NullableStringFieldUpdateOperationsInput | string | null
    questao3?: NullableStringFieldUpdateOperationsInput | string | null
    questao4?: NullableStringFieldUpdateOperationsInput | string | null
    questao5?: NullableStringFieldUpdateOperationsInput | string | null
    questao6?: NullableStringFieldUpdateOperationsInput | string | null
    contas?: contasUncheckedUpdateManyWithoutQuestionarioNestedInput
  }

  export type questionarioCreateManyInput = {
    idQuestionario?: number
    questao1?: string | null
    questao2?: string | null
    questao3?: string | null
    questao4?: string | null
    questao5?: string | null
    questao6?: string | null
  }

  export type questionarioUpdateManyMutationInput = {
    questao1?: NullableStringFieldUpdateOperationsInput | string | null
    questao2?: NullableStringFieldUpdateOperationsInput | string | null
    questao3?: NullableStringFieldUpdateOperationsInput | string | null
    questao4?: NullableStringFieldUpdateOperationsInput | string | null
    questao5?: NullableStringFieldUpdateOperationsInput | string | null
    questao6?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type questionarioUncheckedUpdateManyInput = {
    idQuestionario?: IntFieldUpdateOperationsInput | number
    questao1?: NullableStringFieldUpdateOperationsInput | string | null
    questao2?: NullableStringFieldUpdateOperationsInput | string | null
    questao3?: NullableStringFieldUpdateOperationsInput | string | null
    questao4?: NullableStringFieldUpdateOperationsInput | string | null
    questao5?: NullableStringFieldUpdateOperationsInput | string | null
    questao6?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type geralCreateInput = {
    emailContato: string
    emailMedico: string
    numeroContato: string
  }

  export type geralUncheckedCreateInput = {
    idGeral?: number
    emailContato: string
    emailMedico: string
    numeroContato: string
  }

  export type geralUpdateInput = {
    emailContato?: StringFieldUpdateOperationsInput | string
    emailMedico?: StringFieldUpdateOperationsInput | string
    numeroContato?: StringFieldUpdateOperationsInput | string
  }

  export type geralUncheckedUpdateInput = {
    idGeral?: IntFieldUpdateOperationsInput | number
    emailContato?: StringFieldUpdateOperationsInput | string
    emailMedico?: StringFieldUpdateOperationsInput | string
    numeroContato?: StringFieldUpdateOperationsInput | string
  }

  export type geralCreateManyInput = {
    idGeral?: number
    emailContato: string
    emailMedico: string
    numeroContato: string
  }

  export type geralUpdateManyMutationInput = {
    emailContato?: StringFieldUpdateOperationsInput | string
    emailMedico?: StringFieldUpdateOperationsInput | string
    numeroContato?: StringFieldUpdateOperationsInput | string
  }

  export type geralUncheckedUpdateManyInput = {
    idGeral?: IntFieldUpdateOperationsInput | number
    emailContato?: StringFieldUpdateOperationsInput | string
    emailMedico?: StringFieldUpdateOperationsInput | string
    numeroContato?: StringFieldUpdateOperationsInput | string
  }

  export type gruposCreateInput = {
    dataInicio: Date | string
    dataFinal: Date | string
    link?: string | null
    planos: planosCreateNestedOneWithoutGruposInput
    datas?: datasCreateNestedManyWithoutGruposInput
  }

  export type gruposUncheckedCreateInput = {
    idGrupo?: number
    dataInicio: Date | string
    dataFinal: Date | string
    link?: string | null
    idPlanos: number
    datas?: datasUncheckedCreateNestedManyWithoutGruposInput
  }

  export type gruposUpdateInput = {
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFinal?: DateTimeFieldUpdateOperationsInput | Date | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    planos?: planosUpdateOneRequiredWithoutGruposNestedInput
    datas?: datasUpdateManyWithoutGruposNestedInput
  }

  export type gruposUncheckedUpdateInput = {
    idGrupo?: IntFieldUpdateOperationsInput | number
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFinal?: DateTimeFieldUpdateOperationsInput | Date | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    idPlanos?: IntFieldUpdateOperationsInput | number
    datas?: datasUncheckedUpdateManyWithoutGruposNestedInput
  }

  export type gruposCreateManyInput = {
    idGrupo?: number
    dataInicio: Date | string
    dataFinal: Date | string
    link?: string | null
    idPlanos: number
  }

  export type gruposUpdateManyMutationInput = {
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFinal?: DateTimeFieldUpdateOperationsInput | Date | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gruposUncheckedUpdateManyInput = {
    idGrupo?: IntFieldUpdateOperationsInput | number
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFinal?: DateTimeFieldUpdateOperationsInput | Date | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    idPlanos?: IntFieldUpdateOperationsInput | number
  }

  export type grupoContaCreateInput = {
    idGrupo: number
    idConta: number
  }

  export type grupoContaUncheckedCreateInput = {
    idGrupoConta?: number
    idGrupo: number
    idConta: number
  }

  export type grupoContaUpdateInput = {
    idGrupo?: IntFieldUpdateOperationsInput | number
    idConta?: IntFieldUpdateOperationsInput | number
  }

  export type grupoContaUncheckedUpdateInput = {
    idGrupoConta?: IntFieldUpdateOperationsInput | number
    idGrupo?: IntFieldUpdateOperationsInput | number
    idConta?: IntFieldUpdateOperationsInput | number
  }

  export type grupoContaCreateManyInput = {
    idGrupoConta?: number
    idGrupo: number
    idConta: number
  }

  export type grupoContaUpdateManyMutationInput = {
    idGrupo?: IntFieldUpdateOperationsInput | number
    idConta?: IntFieldUpdateOperationsInput | number
  }

  export type grupoContaUncheckedUpdateManyInput = {
    idGrupoConta?: IntFieldUpdateOperationsInput | number
    idGrupo?: IntFieldUpdateOperationsInput | number
    idConta?: IntFieldUpdateOperationsInput | number
  }

  export type datasCreateInput = {
    dia: $Enums.dias
    hora: string
    grupos: gruposCreateNestedOneWithoutDatasInput
  }

  export type datasUncheckedCreateInput = {
    idData?: number
    dia: $Enums.dias
    hora: string
    idGrupo: number
  }

  export type datasUpdateInput = {
    dia?: EnumdiasFieldUpdateOperationsInput | $Enums.dias
    hora?: StringFieldUpdateOperationsInput | string
    grupos?: gruposUpdateOneRequiredWithoutDatasNestedInput
  }

  export type datasUncheckedUpdateInput = {
    idData?: IntFieldUpdateOperationsInput | number
    dia?: EnumdiasFieldUpdateOperationsInput | $Enums.dias
    hora?: StringFieldUpdateOperationsInput | string
    idGrupo?: IntFieldUpdateOperationsInput | number
  }

  export type datasCreateManyInput = {
    idData?: number
    dia: $Enums.dias
    hora: string
    idGrupo: number
  }

  export type datasUpdateManyMutationInput = {
    dia?: EnumdiasFieldUpdateOperationsInput | $Enums.dias
    hora?: StringFieldUpdateOperationsInput | string
  }

  export type datasUncheckedUpdateManyInput = {
    idData?: IntFieldUpdateOperationsInput | number
    dia?: EnumdiasFieldUpdateOperationsInput | $Enums.dias
    hora?: StringFieldUpdateOperationsInput | string
    idGrupo?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type PlanosRelationFilter = {
    is?: planosWhereInput
    isNot?: planosWhereInput
  }

  export type ContasRelationFilter = {
    is?: contasWhereInput
    isNot?: contasWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type assinaturaCountOrderByAggregateInput = {
    idAssinatura?: SortOrder
    codPagamento?: SortOrder
    ativo?: SortOrder
    data_inicio?: SortOrder
    ultimo_update?: SortOrder
    idPlanos?: SortOrder
    idConta?: SortOrder
  }

  export type assinaturaAvgOrderByAggregateInput = {
    idAssinatura?: SortOrder
    idPlanos?: SortOrder
    idConta?: SortOrder
  }

  export type assinaturaMaxOrderByAggregateInput = {
    idAssinatura?: SortOrder
    codPagamento?: SortOrder
    ativo?: SortOrder
    data_inicio?: SortOrder
    ultimo_update?: SortOrder
    idPlanos?: SortOrder
    idConta?: SortOrder
  }

  export type assinaturaMinOrderByAggregateInput = {
    idAssinatura?: SortOrder
    codPagamento?: SortOrder
    ativo?: SortOrder
    data_inicio?: SortOrder
    ultimo_update?: SortOrder
    idPlanos?: SortOrder
    idConta?: SortOrder
  }

  export type assinaturaSumOrderByAggregateInput = {
    idAssinatura?: SortOrder
    idPlanos?: SortOrder
    idConta?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type historicoPagamentoCountOrderByAggregateInput = {
    idHistoricoPagamento?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
    pago?: SortOrder
    valorTotal?: SortOrder
    data_inicio?: SortOrder
    idConta?: SortOrder
  }

  export type historicoPagamentoAvgOrderByAggregateInput = {
    idHistoricoPagamento?: SortOrder
    valorTotal?: SortOrder
    idConta?: SortOrder
  }

  export type historicoPagamentoMaxOrderByAggregateInput = {
    idHistoricoPagamento?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
    pago?: SortOrder
    valorTotal?: SortOrder
    data_inicio?: SortOrder
    idConta?: SortOrder
  }

  export type historicoPagamentoMinOrderByAggregateInput = {
    idHistoricoPagamento?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
    pago?: SortOrder
    valorTotal?: SortOrder
    data_inicio?: SortOrder
    idConta?: SortOrder
  }

  export type historicoPagamentoSumOrderByAggregateInput = {
    idHistoricoPagamento?: SortOrder
    valorTotal?: SortOrder
    idConta?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumtipoFuncionalidadeFilter<$PrismaModel = never> = {
    equals?: $Enums.tipoFuncionalidade | EnumtipoFuncionalidadeFieldRefInput<$PrismaModel>
    in?: $Enums.tipoFuncionalidade[]
    notIn?: $Enums.tipoFuncionalidade[]
    not?: NestedEnumtipoFuncionalidadeFilter<$PrismaModel> | $Enums.tipoFuncionalidade
  }

  export type EnumtipoPlanoFilter<$PrismaModel = never> = {
    equals?: $Enums.tipoPlano | EnumtipoPlanoFieldRefInput<$PrismaModel>
    in?: $Enums.tipoPlano[]
    notIn?: $Enums.tipoPlano[]
    not?: NestedEnumtipoPlanoFilter<$PrismaModel> | $Enums.tipoPlano
  }

  export type AssinaturaListRelationFilter = {
    every?: assinaturaWhereInput
    some?: assinaturaWhereInput
    none?: assinaturaWhereInput
  }

  export type GruposListRelationFilter = {
    every?: gruposWhereInput
    some?: gruposWhereInput
    none?: gruposWhereInput
  }

  export type assinaturaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type gruposOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type planosCountOrderByAggregateInput = {
    idPlanos?: SortOrder
    nome?: SortOrder
    subtitulo?: SortOrder
    descricao?: SortOrder
    valorTotal?: SortOrder
    tipoFuncionalidade?: SortOrder
    tipo?: SortOrder
    qtdePessoas?: SortOrder
    meses?: SortOrder
    maxSessoes?: SortOrder
  }

  export type planosAvgOrderByAggregateInput = {
    idPlanos?: SortOrder
    valorTotal?: SortOrder
    qtdePessoas?: SortOrder
    meses?: SortOrder
    maxSessoes?: SortOrder
  }

  export type planosMaxOrderByAggregateInput = {
    idPlanos?: SortOrder
    nome?: SortOrder
    subtitulo?: SortOrder
    descricao?: SortOrder
    valorTotal?: SortOrder
    tipoFuncionalidade?: SortOrder
    tipo?: SortOrder
    qtdePessoas?: SortOrder
    meses?: SortOrder
    maxSessoes?: SortOrder
  }

  export type planosMinOrderByAggregateInput = {
    idPlanos?: SortOrder
    nome?: SortOrder
    subtitulo?: SortOrder
    descricao?: SortOrder
    valorTotal?: SortOrder
    tipoFuncionalidade?: SortOrder
    tipo?: SortOrder
    qtdePessoas?: SortOrder
    meses?: SortOrder
    maxSessoes?: SortOrder
  }

  export type planosSumOrderByAggregateInput = {
    idPlanos?: SortOrder
    valorTotal?: SortOrder
    qtdePessoas?: SortOrder
    meses?: SortOrder
    maxSessoes?: SortOrder
  }

  export type EnumtipoFuncionalidadeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.tipoFuncionalidade | EnumtipoFuncionalidadeFieldRefInput<$PrismaModel>
    in?: $Enums.tipoFuncionalidade[]
    notIn?: $Enums.tipoFuncionalidade[]
    not?: NestedEnumtipoFuncionalidadeWithAggregatesFilter<$PrismaModel> | $Enums.tipoFuncionalidade
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtipoFuncionalidadeFilter<$PrismaModel>
    _max?: NestedEnumtipoFuncionalidadeFilter<$PrismaModel>
  }

  export type EnumtipoPlanoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.tipoPlano | EnumtipoPlanoFieldRefInput<$PrismaModel>
    in?: $Enums.tipoPlano[]
    notIn?: $Enums.tipoPlano[]
    not?: NestedEnumtipoPlanoWithAggregatesFilter<$PrismaModel> | $Enums.tipoPlano
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtipoPlanoFilter<$PrismaModel>
    _max?: NestedEnumtipoPlanoFilter<$PrismaModel>
  }

  export type autenticacaoCountOrderByAggregateInput = {
    idAutenticacao?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    idConta?: SortOrder
  }

  export type autenticacaoAvgOrderByAggregateInput = {
    idAutenticacao?: SortOrder
    idConta?: SortOrder
  }

  export type autenticacaoMaxOrderByAggregateInput = {
    idAutenticacao?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    idConta?: SortOrder
  }

  export type autenticacaoMinOrderByAggregateInput = {
    idAutenticacao?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    idConta?: SortOrder
  }

  export type autenticacaoSumOrderByAggregateInput = {
    idAutenticacao?: SortOrder
    idConta?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type Enumcontas_perfilFilter<$PrismaModel = never> = {
    equals?: $Enums.contas_perfil | Enumcontas_perfilFieldRefInput<$PrismaModel>
    in?: $Enums.contas_perfil[]
    notIn?: $Enums.contas_perfil[]
    not?: NestedEnumcontas_perfilFilter<$PrismaModel> | $Enums.contas_perfil
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type AutenticacaoListRelationFilter = {
    every?: autenticacaoWhereInput
    some?: autenticacaoWhereInput
    none?: autenticacaoWhereInput
  }

  export type HistoricoPagamentoListRelationFilter = {
    every?: historicoPagamentoWhereInput
    some?: historicoPagamentoWhereInput
    none?: historicoPagamentoWhereInput
  }

  export type QuestionarioNullableRelationFilter = {
    is?: questionarioWhereInput | null
    isNot?: questionarioWhereInput | null
  }

  export type autenticacaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type historicoPagamentoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type contasCountOrderByAggregateInput = {
    idConta?: SortOrder
    nome?: SortOrder
    data_nasc?: SortOrder
    foto?: SortOrder
    celular?: SortOrder
    fagerstrom?: SortOrder
    perfil?: SortOrder
    idQuestionario?: SortOrder
  }

  export type contasAvgOrderByAggregateInput = {
    idConta?: SortOrder
    idQuestionario?: SortOrder
  }

  export type contasMaxOrderByAggregateInput = {
    idConta?: SortOrder
    nome?: SortOrder
    data_nasc?: SortOrder
    foto?: SortOrder
    celular?: SortOrder
    fagerstrom?: SortOrder
    perfil?: SortOrder
    idQuestionario?: SortOrder
  }

  export type contasMinOrderByAggregateInput = {
    idConta?: SortOrder
    nome?: SortOrder
    data_nasc?: SortOrder
    foto?: SortOrder
    celular?: SortOrder
    fagerstrom?: SortOrder
    perfil?: SortOrder
    idQuestionario?: SortOrder
  }

  export type contasSumOrderByAggregateInput = {
    idConta?: SortOrder
    idQuestionario?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type Enumcontas_perfilWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.contas_perfil | Enumcontas_perfilFieldRefInput<$PrismaModel>
    in?: $Enums.contas_perfil[]
    notIn?: $Enums.contas_perfil[]
    not?: NestedEnumcontas_perfilWithAggregatesFilter<$PrismaModel> | $Enums.contas_perfil
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcontas_perfilFilter<$PrismaModel>
    _max?: NestedEnumcontas_perfilFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ContasListRelationFilter = {
    every?: contasWhereInput
    some?: contasWhereInput
    none?: contasWhereInput
  }

  export type contasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type questionarioCountOrderByAggregateInput = {
    idQuestionario?: SortOrder
    questao1?: SortOrder
    questao2?: SortOrder
    questao3?: SortOrder
    questao4?: SortOrder
    questao5?: SortOrder
    questao6?: SortOrder
  }

  export type questionarioAvgOrderByAggregateInput = {
    idQuestionario?: SortOrder
  }

  export type questionarioMaxOrderByAggregateInput = {
    idQuestionario?: SortOrder
    questao1?: SortOrder
    questao2?: SortOrder
    questao3?: SortOrder
    questao4?: SortOrder
    questao5?: SortOrder
    questao6?: SortOrder
  }

  export type questionarioMinOrderByAggregateInput = {
    idQuestionario?: SortOrder
    questao1?: SortOrder
    questao2?: SortOrder
    questao3?: SortOrder
    questao4?: SortOrder
    questao5?: SortOrder
    questao6?: SortOrder
  }

  export type questionarioSumOrderByAggregateInput = {
    idQuestionario?: SortOrder
  }

  export type geralCountOrderByAggregateInput = {
    idGeral?: SortOrder
    emailContato?: SortOrder
    emailMedico?: SortOrder
    numeroContato?: SortOrder
  }

  export type geralAvgOrderByAggregateInput = {
    idGeral?: SortOrder
  }

  export type geralMaxOrderByAggregateInput = {
    idGeral?: SortOrder
    emailContato?: SortOrder
    emailMedico?: SortOrder
    numeroContato?: SortOrder
  }

  export type geralMinOrderByAggregateInput = {
    idGeral?: SortOrder
    emailContato?: SortOrder
    emailMedico?: SortOrder
    numeroContato?: SortOrder
  }

  export type geralSumOrderByAggregateInput = {
    idGeral?: SortOrder
  }

  export type DatasListRelationFilter = {
    every?: datasWhereInput
    some?: datasWhereInput
    none?: datasWhereInput
  }

  export type datasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type gruposCountOrderByAggregateInput = {
    idGrupo?: SortOrder
    dataInicio?: SortOrder
    dataFinal?: SortOrder
    link?: SortOrder
    idPlanos?: SortOrder
  }

  export type gruposAvgOrderByAggregateInput = {
    idGrupo?: SortOrder
    idPlanos?: SortOrder
  }

  export type gruposMaxOrderByAggregateInput = {
    idGrupo?: SortOrder
    dataInicio?: SortOrder
    dataFinal?: SortOrder
    link?: SortOrder
    idPlanos?: SortOrder
  }

  export type gruposMinOrderByAggregateInput = {
    idGrupo?: SortOrder
    dataInicio?: SortOrder
    dataFinal?: SortOrder
    link?: SortOrder
    idPlanos?: SortOrder
  }

  export type gruposSumOrderByAggregateInput = {
    idGrupo?: SortOrder
    idPlanos?: SortOrder
  }

  export type grupoContaCountOrderByAggregateInput = {
    idGrupoConta?: SortOrder
    idGrupo?: SortOrder
    idConta?: SortOrder
  }

  export type grupoContaAvgOrderByAggregateInput = {
    idGrupoConta?: SortOrder
    idGrupo?: SortOrder
    idConta?: SortOrder
  }

  export type grupoContaMaxOrderByAggregateInput = {
    idGrupoConta?: SortOrder
    idGrupo?: SortOrder
    idConta?: SortOrder
  }

  export type grupoContaMinOrderByAggregateInput = {
    idGrupoConta?: SortOrder
    idGrupo?: SortOrder
    idConta?: SortOrder
  }

  export type grupoContaSumOrderByAggregateInput = {
    idGrupoConta?: SortOrder
    idGrupo?: SortOrder
    idConta?: SortOrder
  }

  export type EnumdiasFilter<$PrismaModel = never> = {
    equals?: $Enums.dias | EnumdiasFieldRefInput<$PrismaModel>
    in?: $Enums.dias[]
    notIn?: $Enums.dias[]
    not?: NestedEnumdiasFilter<$PrismaModel> | $Enums.dias
  }

  export type GruposRelationFilter = {
    is?: gruposWhereInput
    isNot?: gruposWhereInput
  }

  export type datasCountOrderByAggregateInput = {
    idData?: SortOrder
    dia?: SortOrder
    hora?: SortOrder
    idGrupo?: SortOrder
  }

  export type datasAvgOrderByAggregateInput = {
    idData?: SortOrder
    idGrupo?: SortOrder
  }

  export type datasMaxOrderByAggregateInput = {
    idData?: SortOrder
    dia?: SortOrder
    hora?: SortOrder
    idGrupo?: SortOrder
  }

  export type datasMinOrderByAggregateInput = {
    idData?: SortOrder
    dia?: SortOrder
    hora?: SortOrder
    idGrupo?: SortOrder
  }

  export type datasSumOrderByAggregateInput = {
    idData?: SortOrder
    idGrupo?: SortOrder
  }

  export type EnumdiasWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.dias | EnumdiasFieldRefInput<$PrismaModel>
    in?: $Enums.dias[]
    notIn?: $Enums.dias[]
    not?: NestedEnumdiasWithAggregatesFilter<$PrismaModel> | $Enums.dias
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumdiasFilter<$PrismaModel>
    _max?: NestedEnumdiasFilter<$PrismaModel>
  }

  export type planosCreateNestedOneWithoutAssinaturaInput = {
    create?: XOR<planosCreateWithoutAssinaturaInput, planosUncheckedCreateWithoutAssinaturaInput>
    connectOrCreate?: planosCreateOrConnectWithoutAssinaturaInput
    connect?: planosWhereUniqueInput
  }

  export type contasCreateNestedOneWithoutAssinaturasInput = {
    create?: XOR<contasCreateWithoutAssinaturasInput, contasUncheckedCreateWithoutAssinaturasInput>
    connectOrCreate?: contasCreateOrConnectWithoutAssinaturasInput
    connect?: contasWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type planosUpdateOneRequiredWithoutAssinaturaNestedInput = {
    create?: XOR<planosCreateWithoutAssinaturaInput, planosUncheckedCreateWithoutAssinaturaInput>
    connectOrCreate?: planosCreateOrConnectWithoutAssinaturaInput
    upsert?: planosUpsertWithoutAssinaturaInput
    connect?: planosWhereUniqueInput
    update?: XOR<XOR<planosUpdateToOneWithWhereWithoutAssinaturaInput, planosUpdateWithoutAssinaturaInput>, planosUncheckedUpdateWithoutAssinaturaInput>
  }

  export type contasUpdateOneRequiredWithoutAssinaturasNestedInput = {
    create?: XOR<contasCreateWithoutAssinaturasInput, contasUncheckedCreateWithoutAssinaturasInput>
    connectOrCreate?: contasCreateOrConnectWithoutAssinaturasInput
    upsert?: contasUpsertWithoutAssinaturasInput
    connect?: contasWhereUniqueInput
    update?: XOR<XOR<contasUpdateToOneWithWhereWithoutAssinaturasInput, contasUpdateWithoutAssinaturasInput>, contasUncheckedUpdateWithoutAssinaturasInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type contasCreateNestedOneWithoutHistoricoPagamentoInput = {
    create?: XOR<contasCreateWithoutHistoricoPagamentoInput, contasUncheckedCreateWithoutHistoricoPagamentoInput>
    connectOrCreate?: contasCreateOrConnectWithoutHistoricoPagamentoInput
    connect?: contasWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type contasUpdateOneRequiredWithoutHistoricoPagamentoNestedInput = {
    create?: XOR<contasCreateWithoutHistoricoPagamentoInput, contasUncheckedCreateWithoutHistoricoPagamentoInput>
    connectOrCreate?: contasCreateOrConnectWithoutHistoricoPagamentoInput
    upsert?: contasUpsertWithoutHistoricoPagamentoInput
    connect?: contasWhereUniqueInput
    update?: XOR<XOR<contasUpdateToOneWithWhereWithoutHistoricoPagamentoInput, contasUpdateWithoutHistoricoPagamentoInput>, contasUncheckedUpdateWithoutHistoricoPagamentoInput>
  }

  export type assinaturaCreateNestedManyWithoutPlanosInput = {
    create?: XOR<assinaturaCreateWithoutPlanosInput, assinaturaUncheckedCreateWithoutPlanosInput> | assinaturaCreateWithoutPlanosInput[] | assinaturaUncheckedCreateWithoutPlanosInput[]
    connectOrCreate?: assinaturaCreateOrConnectWithoutPlanosInput | assinaturaCreateOrConnectWithoutPlanosInput[]
    createMany?: assinaturaCreateManyPlanosInputEnvelope
    connect?: assinaturaWhereUniqueInput | assinaturaWhereUniqueInput[]
  }

  export type gruposCreateNestedManyWithoutPlanosInput = {
    create?: XOR<gruposCreateWithoutPlanosInput, gruposUncheckedCreateWithoutPlanosInput> | gruposCreateWithoutPlanosInput[] | gruposUncheckedCreateWithoutPlanosInput[]
    connectOrCreate?: gruposCreateOrConnectWithoutPlanosInput | gruposCreateOrConnectWithoutPlanosInput[]
    createMany?: gruposCreateManyPlanosInputEnvelope
    connect?: gruposWhereUniqueInput | gruposWhereUniqueInput[]
  }

  export type assinaturaUncheckedCreateNestedManyWithoutPlanosInput = {
    create?: XOR<assinaturaCreateWithoutPlanosInput, assinaturaUncheckedCreateWithoutPlanosInput> | assinaturaCreateWithoutPlanosInput[] | assinaturaUncheckedCreateWithoutPlanosInput[]
    connectOrCreate?: assinaturaCreateOrConnectWithoutPlanosInput | assinaturaCreateOrConnectWithoutPlanosInput[]
    createMany?: assinaturaCreateManyPlanosInputEnvelope
    connect?: assinaturaWhereUniqueInput | assinaturaWhereUniqueInput[]
  }

  export type gruposUncheckedCreateNestedManyWithoutPlanosInput = {
    create?: XOR<gruposCreateWithoutPlanosInput, gruposUncheckedCreateWithoutPlanosInput> | gruposCreateWithoutPlanosInput[] | gruposUncheckedCreateWithoutPlanosInput[]
    connectOrCreate?: gruposCreateOrConnectWithoutPlanosInput | gruposCreateOrConnectWithoutPlanosInput[]
    createMany?: gruposCreateManyPlanosInputEnvelope
    connect?: gruposWhereUniqueInput | gruposWhereUniqueInput[]
  }

  export type EnumtipoFuncionalidadeFieldUpdateOperationsInput = {
    set?: $Enums.tipoFuncionalidade
  }

  export type EnumtipoPlanoFieldUpdateOperationsInput = {
    set?: $Enums.tipoPlano
  }

  export type assinaturaUpdateManyWithoutPlanosNestedInput = {
    create?: XOR<assinaturaCreateWithoutPlanosInput, assinaturaUncheckedCreateWithoutPlanosInput> | assinaturaCreateWithoutPlanosInput[] | assinaturaUncheckedCreateWithoutPlanosInput[]
    connectOrCreate?: assinaturaCreateOrConnectWithoutPlanosInput | assinaturaCreateOrConnectWithoutPlanosInput[]
    upsert?: assinaturaUpsertWithWhereUniqueWithoutPlanosInput | assinaturaUpsertWithWhereUniqueWithoutPlanosInput[]
    createMany?: assinaturaCreateManyPlanosInputEnvelope
    set?: assinaturaWhereUniqueInput | assinaturaWhereUniqueInput[]
    disconnect?: assinaturaWhereUniqueInput | assinaturaWhereUniqueInput[]
    delete?: assinaturaWhereUniqueInput | assinaturaWhereUniqueInput[]
    connect?: assinaturaWhereUniqueInput | assinaturaWhereUniqueInput[]
    update?: assinaturaUpdateWithWhereUniqueWithoutPlanosInput | assinaturaUpdateWithWhereUniqueWithoutPlanosInput[]
    updateMany?: assinaturaUpdateManyWithWhereWithoutPlanosInput | assinaturaUpdateManyWithWhereWithoutPlanosInput[]
    deleteMany?: assinaturaScalarWhereInput | assinaturaScalarWhereInput[]
  }

  export type gruposUpdateManyWithoutPlanosNestedInput = {
    create?: XOR<gruposCreateWithoutPlanosInput, gruposUncheckedCreateWithoutPlanosInput> | gruposCreateWithoutPlanosInput[] | gruposUncheckedCreateWithoutPlanosInput[]
    connectOrCreate?: gruposCreateOrConnectWithoutPlanosInput | gruposCreateOrConnectWithoutPlanosInput[]
    upsert?: gruposUpsertWithWhereUniqueWithoutPlanosInput | gruposUpsertWithWhereUniqueWithoutPlanosInput[]
    createMany?: gruposCreateManyPlanosInputEnvelope
    set?: gruposWhereUniqueInput | gruposWhereUniqueInput[]
    disconnect?: gruposWhereUniqueInput | gruposWhereUniqueInput[]
    delete?: gruposWhereUniqueInput | gruposWhereUniqueInput[]
    connect?: gruposWhereUniqueInput | gruposWhereUniqueInput[]
    update?: gruposUpdateWithWhereUniqueWithoutPlanosInput | gruposUpdateWithWhereUniqueWithoutPlanosInput[]
    updateMany?: gruposUpdateManyWithWhereWithoutPlanosInput | gruposUpdateManyWithWhereWithoutPlanosInput[]
    deleteMany?: gruposScalarWhereInput | gruposScalarWhereInput[]
  }

  export type assinaturaUncheckedUpdateManyWithoutPlanosNestedInput = {
    create?: XOR<assinaturaCreateWithoutPlanosInput, assinaturaUncheckedCreateWithoutPlanosInput> | assinaturaCreateWithoutPlanosInput[] | assinaturaUncheckedCreateWithoutPlanosInput[]
    connectOrCreate?: assinaturaCreateOrConnectWithoutPlanosInput | assinaturaCreateOrConnectWithoutPlanosInput[]
    upsert?: assinaturaUpsertWithWhereUniqueWithoutPlanosInput | assinaturaUpsertWithWhereUniqueWithoutPlanosInput[]
    createMany?: assinaturaCreateManyPlanosInputEnvelope
    set?: assinaturaWhereUniqueInput | assinaturaWhereUniqueInput[]
    disconnect?: assinaturaWhereUniqueInput | assinaturaWhereUniqueInput[]
    delete?: assinaturaWhereUniqueInput | assinaturaWhereUniqueInput[]
    connect?: assinaturaWhereUniqueInput | assinaturaWhereUniqueInput[]
    update?: assinaturaUpdateWithWhereUniqueWithoutPlanosInput | assinaturaUpdateWithWhereUniqueWithoutPlanosInput[]
    updateMany?: assinaturaUpdateManyWithWhereWithoutPlanosInput | assinaturaUpdateManyWithWhereWithoutPlanosInput[]
    deleteMany?: assinaturaScalarWhereInput | assinaturaScalarWhereInput[]
  }

  export type gruposUncheckedUpdateManyWithoutPlanosNestedInput = {
    create?: XOR<gruposCreateWithoutPlanosInput, gruposUncheckedCreateWithoutPlanosInput> | gruposCreateWithoutPlanosInput[] | gruposUncheckedCreateWithoutPlanosInput[]
    connectOrCreate?: gruposCreateOrConnectWithoutPlanosInput | gruposCreateOrConnectWithoutPlanosInput[]
    upsert?: gruposUpsertWithWhereUniqueWithoutPlanosInput | gruposUpsertWithWhereUniqueWithoutPlanosInput[]
    createMany?: gruposCreateManyPlanosInputEnvelope
    set?: gruposWhereUniqueInput | gruposWhereUniqueInput[]
    disconnect?: gruposWhereUniqueInput | gruposWhereUniqueInput[]
    delete?: gruposWhereUniqueInput | gruposWhereUniqueInput[]
    connect?: gruposWhereUniqueInput | gruposWhereUniqueInput[]
    update?: gruposUpdateWithWhereUniqueWithoutPlanosInput | gruposUpdateWithWhereUniqueWithoutPlanosInput[]
    updateMany?: gruposUpdateManyWithWhereWithoutPlanosInput | gruposUpdateManyWithWhereWithoutPlanosInput[]
    deleteMany?: gruposScalarWhereInput | gruposScalarWhereInput[]
  }

  export type contasCreateNestedOneWithoutAutenticacaoInput = {
    create?: XOR<contasCreateWithoutAutenticacaoInput, contasUncheckedCreateWithoutAutenticacaoInput>
    connectOrCreate?: contasCreateOrConnectWithoutAutenticacaoInput
    connect?: contasWhereUniqueInput
  }

  export type contasUpdateOneRequiredWithoutAutenticacaoNestedInput = {
    create?: XOR<contasCreateWithoutAutenticacaoInput, contasUncheckedCreateWithoutAutenticacaoInput>
    connectOrCreate?: contasCreateOrConnectWithoutAutenticacaoInput
    upsert?: contasUpsertWithoutAutenticacaoInput
    connect?: contasWhereUniqueInput
    update?: XOR<XOR<contasUpdateToOneWithWhereWithoutAutenticacaoInput, contasUpdateWithoutAutenticacaoInput>, contasUncheckedUpdateWithoutAutenticacaoInput>
  }

  export type autenticacaoCreateNestedManyWithoutContaInput = {
    create?: XOR<autenticacaoCreateWithoutContaInput, autenticacaoUncheckedCreateWithoutContaInput> | autenticacaoCreateWithoutContaInput[] | autenticacaoUncheckedCreateWithoutContaInput[]
    connectOrCreate?: autenticacaoCreateOrConnectWithoutContaInput | autenticacaoCreateOrConnectWithoutContaInput[]
    createMany?: autenticacaoCreateManyContaInputEnvelope
    connect?: autenticacaoWhereUniqueInput | autenticacaoWhereUniqueInput[]
  }

  export type historicoPagamentoCreateNestedManyWithoutContasInput = {
    create?: XOR<historicoPagamentoCreateWithoutContasInput, historicoPagamentoUncheckedCreateWithoutContasInput> | historicoPagamentoCreateWithoutContasInput[] | historicoPagamentoUncheckedCreateWithoutContasInput[]
    connectOrCreate?: historicoPagamentoCreateOrConnectWithoutContasInput | historicoPagamentoCreateOrConnectWithoutContasInput[]
    createMany?: historicoPagamentoCreateManyContasInputEnvelope
    connect?: historicoPagamentoWhereUniqueInput | historicoPagamentoWhereUniqueInput[]
  }

  export type assinaturaCreateNestedManyWithoutContasInput = {
    create?: XOR<assinaturaCreateWithoutContasInput, assinaturaUncheckedCreateWithoutContasInput> | assinaturaCreateWithoutContasInput[] | assinaturaUncheckedCreateWithoutContasInput[]
    connectOrCreate?: assinaturaCreateOrConnectWithoutContasInput | assinaturaCreateOrConnectWithoutContasInput[]
    createMany?: assinaturaCreateManyContasInputEnvelope
    connect?: assinaturaWhereUniqueInput | assinaturaWhereUniqueInput[]
  }

  export type questionarioCreateNestedOneWithoutContasInput = {
    create?: XOR<questionarioCreateWithoutContasInput, questionarioUncheckedCreateWithoutContasInput>
    connectOrCreate?: questionarioCreateOrConnectWithoutContasInput
    connect?: questionarioWhereUniqueInput
  }

  export type autenticacaoUncheckedCreateNestedManyWithoutContaInput = {
    create?: XOR<autenticacaoCreateWithoutContaInput, autenticacaoUncheckedCreateWithoutContaInput> | autenticacaoCreateWithoutContaInput[] | autenticacaoUncheckedCreateWithoutContaInput[]
    connectOrCreate?: autenticacaoCreateOrConnectWithoutContaInput | autenticacaoCreateOrConnectWithoutContaInput[]
    createMany?: autenticacaoCreateManyContaInputEnvelope
    connect?: autenticacaoWhereUniqueInput | autenticacaoWhereUniqueInput[]
  }

  export type historicoPagamentoUncheckedCreateNestedManyWithoutContasInput = {
    create?: XOR<historicoPagamentoCreateWithoutContasInput, historicoPagamentoUncheckedCreateWithoutContasInput> | historicoPagamentoCreateWithoutContasInput[] | historicoPagamentoUncheckedCreateWithoutContasInput[]
    connectOrCreate?: historicoPagamentoCreateOrConnectWithoutContasInput | historicoPagamentoCreateOrConnectWithoutContasInput[]
    createMany?: historicoPagamentoCreateManyContasInputEnvelope
    connect?: historicoPagamentoWhereUniqueInput | historicoPagamentoWhereUniqueInput[]
  }

  export type assinaturaUncheckedCreateNestedManyWithoutContasInput = {
    create?: XOR<assinaturaCreateWithoutContasInput, assinaturaUncheckedCreateWithoutContasInput> | assinaturaCreateWithoutContasInput[] | assinaturaUncheckedCreateWithoutContasInput[]
    connectOrCreate?: assinaturaCreateOrConnectWithoutContasInput | assinaturaCreateOrConnectWithoutContasInput[]
    createMany?: assinaturaCreateManyContasInputEnvelope
    connect?: assinaturaWhereUniqueInput | assinaturaWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type Enumcontas_perfilFieldUpdateOperationsInput = {
    set?: $Enums.contas_perfil
  }

  export type autenticacaoUpdateManyWithoutContaNestedInput = {
    create?: XOR<autenticacaoCreateWithoutContaInput, autenticacaoUncheckedCreateWithoutContaInput> | autenticacaoCreateWithoutContaInput[] | autenticacaoUncheckedCreateWithoutContaInput[]
    connectOrCreate?: autenticacaoCreateOrConnectWithoutContaInput | autenticacaoCreateOrConnectWithoutContaInput[]
    upsert?: autenticacaoUpsertWithWhereUniqueWithoutContaInput | autenticacaoUpsertWithWhereUniqueWithoutContaInput[]
    createMany?: autenticacaoCreateManyContaInputEnvelope
    set?: autenticacaoWhereUniqueInput | autenticacaoWhereUniqueInput[]
    disconnect?: autenticacaoWhereUniqueInput | autenticacaoWhereUniqueInput[]
    delete?: autenticacaoWhereUniqueInput | autenticacaoWhereUniqueInput[]
    connect?: autenticacaoWhereUniqueInput | autenticacaoWhereUniqueInput[]
    update?: autenticacaoUpdateWithWhereUniqueWithoutContaInput | autenticacaoUpdateWithWhereUniqueWithoutContaInput[]
    updateMany?: autenticacaoUpdateManyWithWhereWithoutContaInput | autenticacaoUpdateManyWithWhereWithoutContaInput[]
    deleteMany?: autenticacaoScalarWhereInput | autenticacaoScalarWhereInput[]
  }

  export type historicoPagamentoUpdateManyWithoutContasNestedInput = {
    create?: XOR<historicoPagamentoCreateWithoutContasInput, historicoPagamentoUncheckedCreateWithoutContasInput> | historicoPagamentoCreateWithoutContasInput[] | historicoPagamentoUncheckedCreateWithoutContasInput[]
    connectOrCreate?: historicoPagamentoCreateOrConnectWithoutContasInput | historicoPagamentoCreateOrConnectWithoutContasInput[]
    upsert?: historicoPagamentoUpsertWithWhereUniqueWithoutContasInput | historicoPagamentoUpsertWithWhereUniqueWithoutContasInput[]
    createMany?: historicoPagamentoCreateManyContasInputEnvelope
    set?: historicoPagamentoWhereUniqueInput | historicoPagamentoWhereUniqueInput[]
    disconnect?: historicoPagamentoWhereUniqueInput | historicoPagamentoWhereUniqueInput[]
    delete?: historicoPagamentoWhereUniqueInput | historicoPagamentoWhereUniqueInput[]
    connect?: historicoPagamentoWhereUniqueInput | historicoPagamentoWhereUniqueInput[]
    update?: historicoPagamentoUpdateWithWhereUniqueWithoutContasInput | historicoPagamentoUpdateWithWhereUniqueWithoutContasInput[]
    updateMany?: historicoPagamentoUpdateManyWithWhereWithoutContasInput | historicoPagamentoUpdateManyWithWhereWithoutContasInput[]
    deleteMany?: historicoPagamentoScalarWhereInput | historicoPagamentoScalarWhereInput[]
  }

  export type assinaturaUpdateManyWithoutContasNestedInput = {
    create?: XOR<assinaturaCreateWithoutContasInput, assinaturaUncheckedCreateWithoutContasInput> | assinaturaCreateWithoutContasInput[] | assinaturaUncheckedCreateWithoutContasInput[]
    connectOrCreate?: assinaturaCreateOrConnectWithoutContasInput | assinaturaCreateOrConnectWithoutContasInput[]
    upsert?: assinaturaUpsertWithWhereUniqueWithoutContasInput | assinaturaUpsertWithWhereUniqueWithoutContasInput[]
    createMany?: assinaturaCreateManyContasInputEnvelope
    set?: assinaturaWhereUniqueInput | assinaturaWhereUniqueInput[]
    disconnect?: assinaturaWhereUniqueInput | assinaturaWhereUniqueInput[]
    delete?: assinaturaWhereUniqueInput | assinaturaWhereUniqueInput[]
    connect?: assinaturaWhereUniqueInput | assinaturaWhereUniqueInput[]
    update?: assinaturaUpdateWithWhereUniqueWithoutContasInput | assinaturaUpdateWithWhereUniqueWithoutContasInput[]
    updateMany?: assinaturaUpdateManyWithWhereWithoutContasInput | assinaturaUpdateManyWithWhereWithoutContasInput[]
    deleteMany?: assinaturaScalarWhereInput | assinaturaScalarWhereInput[]
  }

  export type questionarioUpdateOneWithoutContasNestedInput = {
    create?: XOR<questionarioCreateWithoutContasInput, questionarioUncheckedCreateWithoutContasInput>
    connectOrCreate?: questionarioCreateOrConnectWithoutContasInput
    upsert?: questionarioUpsertWithoutContasInput
    disconnect?: questionarioWhereInput | boolean
    delete?: questionarioWhereInput | boolean
    connect?: questionarioWhereUniqueInput
    update?: XOR<XOR<questionarioUpdateToOneWithWhereWithoutContasInput, questionarioUpdateWithoutContasInput>, questionarioUncheckedUpdateWithoutContasInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type autenticacaoUncheckedUpdateManyWithoutContaNestedInput = {
    create?: XOR<autenticacaoCreateWithoutContaInput, autenticacaoUncheckedCreateWithoutContaInput> | autenticacaoCreateWithoutContaInput[] | autenticacaoUncheckedCreateWithoutContaInput[]
    connectOrCreate?: autenticacaoCreateOrConnectWithoutContaInput | autenticacaoCreateOrConnectWithoutContaInput[]
    upsert?: autenticacaoUpsertWithWhereUniqueWithoutContaInput | autenticacaoUpsertWithWhereUniqueWithoutContaInput[]
    createMany?: autenticacaoCreateManyContaInputEnvelope
    set?: autenticacaoWhereUniqueInput | autenticacaoWhereUniqueInput[]
    disconnect?: autenticacaoWhereUniqueInput | autenticacaoWhereUniqueInput[]
    delete?: autenticacaoWhereUniqueInput | autenticacaoWhereUniqueInput[]
    connect?: autenticacaoWhereUniqueInput | autenticacaoWhereUniqueInput[]
    update?: autenticacaoUpdateWithWhereUniqueWithoutContaInput | autenticacaoUpdateWithWhereUniqueWithoutContaInput[]
    updateMany?: autenticacaoUpdateManyWithWhereWithoutContaInput | autenticacaoUpdateManyWithWhereWithoutContaInput[]
    deleteMany?: autenticacaoScalarWhereInput | autenticacaoScalarWhereInput[]
  }

  export type historicoPagamentoUncheckedUpdateManyWithoutContasNestedInput = {
    create?: XOR<historicoPagamentoCreateWithoutContasInput, historicoPagamentoUncheckedCreateWithoutContasInput> | historicoPagamentoCreateWithoutContasInput[] | historicoPagamentoUncheckedCreateWithoutContasInput[]
    connectOrCreate?: historicoPagamentoCreateOrConnectWithoutContasInput | historicoPagamentoCreateOrConnectWithoutContasInput[]
    upsert?: historicoPagamentoUpsertWithWhereUniqueWithoutContasInput | historicoPagamentoUpsertWithWhereUniqueWithoutContasInput[]
    createMany?: historicoPagamentoCreateManyContasInputEnvelope
    set?: historicoPagamentoWhereUniqueInput | historicoPagamentoWhereUniqueInput[]
    disconnect?: historicoPagamentoWhereUniqueInput | historicoPagamentoWhereUniqueInput[]
    delete?: historicoPagamentoWhereUniqueInput | historicoPagamentoWhereUniqueInput[]
    connect?: historicoPagamentoWhereUniqueInput | historicoPagamentoWhereUniqueInput[]
    update?: historicoPagamentoUpdateWithWhereUniqueWithoutContasInput | historicoPagamentoUpdateWithWhereUniqueWithoutContasInput[]
    updateMany?: historicoPagamentoUpdateManyWithWhereWithoutContasInput | historicoPagamentoUpdateManyWithWhereWithoutContasInput[]
    deleteMany?: historicoPagamentoScalarWhereInput | historicoPagamentoScalarWhereInput[]
  }

  export type assinaturaUncheckedUpdateManyWithoutContasNestedInput = {
    create?: XOR<assinaturaCreateWithoutContasInput, assinaturaUncheckedCreateWithoutContasInput> | assinaturaCreateWithoutContasInput[] | assinaturaUncheckedCreateWithoutContasInput[]
    connectOrCreate?: assinaturaCreateOrConnectWithoutContasInput | assinaturaCreateOrConnectWithoutContasInput[]
    upsert?: assinaturaUpsertWithWhereUniqueWithoutContasInput | assinaturaUpsertWithWhereUniqueWithoutContasInput[]
    createMany?: assinaturaCreateManyContasInputEnvelope
    set?: assinaturaWhereUniqueInput | assinaturaWhereUniqueInput[]
    disconnect?: assinaturaWhereUniqueInput | assinaturaWhereUniqueInput[]
    delete?: assinaturaWhereUniqueInput | assinaturaWhereUniqueInput[]
    connect?: assinaturaWhereUniqueInput | assinaturaWhereUniqueInput[]
    update?: assinaturaUpdateWithWhereUniqueWithoutContasInput | assinaturaUpdateWithWhereUniqueWithoutContasInput[]
    updateMany?: assinaturaUpdateManyWithWhereWithoutContasInput | assinaturaUpdateManyWithWhereWithoutContasInput[]
    deleteMany?: assinaturaScalarWhereInput | assinaturaScalarWhereInput[]
  }

  export type contasCreateNestedManyWithoutQuestionarioInput = {
    create?: XOR<contasCreateWithoutQuestionarioInput, contasUncheckedCreateWithoutQuestionarioInput> | contasCreateWithoutQuestionarioInput[] | contasUncheckedCreateWithoutQuestionarioInput[]
    connectOrCreate?: contasCreateOrConnectWithoutQuestionarioInput | contasCreateOrConnectWithoutQuestionarioInput[]
    createMany?: contasCreateManyQuestionarioInputEnvelope
    connect?: contasWhereUniqueInput | contasWhereUniqueInput[]
  }

  export type contasUncheckedCreateNestedManyWithoutQuestionarioInput = {
    create?: XOR<contasCreateWithoutQuestionarioInput, contasUncheckedCreateWithoutQuestionarioInput> | contasCreateWithoutQuestionarioInput[] | contasUncheckedCreateWithoutQuestionarioInput[]
    connectOrCreate?: contasCreateOrConnectWithoutQuestionarioInput | contasCreateOrConnectWithoutQuestionarioInput[]
    createMany?: contasCreateManyQuestionarioInputEnvelope
    connect?: contasWhereUniqueInput | contasWhereUniqueInput[]
  }

  export type contasUpdateManyWithoutQuestionarioNestedInput = {
    create?: XOR<contasCreateWithoutQuestionarioInput, contasUncheckedCreateWithoutQuestionarioInput> | contasCreateWithoutQuestionarioInput[] | contasUncheckedCreateWithoutQuestionarioInput[]
    connectOrCreate?: contasCreateOrConnectWithoutQuestionarioInput | contasCreateOrConnectWithoutQuestionarioInput[]
    upsert?: contasUpsertWithWhereUniqueWithoutQuestionarioInput | contasUpsertWithWhereUniqueWithoutQuestionarioInput[]
    createMany?: contasCreateManyQuestionarioInputEnvelope
    set?: contasWhereUniqueInput | contasWhereUniqueInput[]
    disconnect?: contasWhereUniqueInput | contasWhereUniqueInput[]
    delete?: contasWhereUniqueInput | contasWhereUniqueInput[]
    connect?: contasWhereUniqueInput | contasWhereUniqueInput[]
    update?: contasUpdateWithWhereUniqueWithoutQuestionarioInput | contasUpdateWithWhereUniqueWithoutQuestionarioInput[]
    updateMany?: contasUpdateManyWithWhereWithoutQuestionarioInput | contasUpdateManyWithWhereWithoutQuestionarioInput[]
    deleteMany?: contasScalarWhereInput | contasScalarWhereInput[]
  }

  export type contasUncheckedUpdateManyWithoutQuestionarioNestedInput = {
    create?: XOR<contasCreateWithoutQuestionarioInput, contasUncheckedCreateWithoutQuestionarioInput> | contasCreateWithoutQuestionarioInput[] | contasUncheckedCreateWithoutQuestionarioInput[]
    connectOrCreate?: contasCreateOrConnectWithoutQuestionarioInput | contasCreateOrConnectWithoutQuestionarioInput[]
    upsert?: contasUpsertWithWhereUniqueWithoutQuestionarioInput | contasUpsertWithWhereUniqueWithoutQuestionarioInput[]
    createMany?: contasCreateManyQuestionarioInputEnvelope
    set?: contasWhereUniqueInput | contasWhereUniqueInput[]
    disconnect?: contasWhereUniqueInput | contasWhereUniqueInput[]
    delete?: contasWhereUniqueInput | contasWhereUniqueInput[]
    connect?: contasWhereUniqueInput | contasWhereUniqueInput[]
    update?: contasUpdateWithWhereUniqueWithoutQuestionarioInput | contasUpdateWithWhereUniqueWithoutQuestionarioInput[]
    updateMany?: contasUpdateManyWithWhereWithoutQuestionarioInput | contasUpdateManyWithWhereWithoutQuestionarioInput[]
    deleteMany?: contasScalarWhereInput | contasScalarWhereInput[]
  }

  export type planosCreateNestedOneWithoutGruposInput = {
    create?: XOR<planosCreateWithoutGruposInput, planosUncheckedCreateWithoutGruposInput>
    connectOrCreate?: planosCreateOrConnectWithoutGruposInput
    connect?: planosWhereUniqueInput
  }

  export type datasCreateNestedManyWithoutGruposInput = {
    create?: XOR<datasCreateWithoutGruposInput, datasUncheckedCreateWithoutGruposInput> | datasCreateWithoutGruposInput[] | datasUncheckedCreateWithoutGruposInput[]
    connectOrCreate?: datasCreateOrConnectWithoutGruposInput | datasCreateOrConnectWithoutGruposInput[]
    createMany?: datasCreateManyGruposInputEnvelope
    connect?: datasWhereUniqueInput | datasWhereUniqueInput[]
  }

  export type datasUncheckedCreateNestedManyWithoutGruposInput = {
    create?: XOR<datasCreateWithoutGruposInput, datasUncheckedCreateWithoutGruposInput> | datasCreateWithoutGruposInput[] | datasUncheckedCreateWithoutGruposInput[]
    connectOrCreate?: datasCreateOrConnectWithoutGruposInput | datasCreateOrConnectWithoutGruposInput[]
    createMany?: datasCreateManyGruposInputEnvelope
    connect?: datasWhereUniqueInput | datasWhereUniqueInput[]
  }

  export type planosUpdateOneRequiredWithoutGruposNestedInput = {
    create?: XOR<planosCreateWithoutGruposInput, planosUncheckedCreateWithoutGruposInput>
    connectOrCreate?: planosCreateOrConnectWithoutGruposInput
    upsert?: planosUpsertWithoutGruposInput
    connect?: planosWhereUniqueInput
    update?: XOR<XOR<planosUpdateToOneWithWhereWithoutGruposInput, planosUpdateWithoutGruposInput>, planosUncheckedUpdateWithoutGruposInput>
  }

  export type datasUpdateManyWithoutGruposNestedInput = {
    create?: XOR<datasCreateWithoutGruposInput, datasUncheckedCreateWithoutGruposInput> | datasCreateWithoutGruposInput[] | datasUncheckedCreateWithoutGruposInput[]
    connectOrCreate?: datasCreateOrConnectWithoutGruposInput | datasCreateOrConnectWithoutGruposInput[]
    upsert?: datasUpsertWithWhereUniqueWithoutGruposInput | datasUpsertWithWhereUniqueWithoutGruposInput[]
    createMany?: datasCreateManyGruposInputEnvelope
    set?: datasWhereUniqueInput | datasWhereUniqueInput[]
    disconnect?: datasWhereUniqueInput | datasWhereUniqueInput[]
    delete?: datasWhereUniqueInput | datasWhereUniqueInput[]
    connect?: datasWhereUniqueInput | datasWhereUniqueInput[]
    update?: datasUpdateWithWhereUniqueWithoutGruposInput | datasUpdateWithWhereUniqueWithoutGruposInput[]
    updateMany?: datasUpdateManyWithWhereWithoutGruposInput | datasUpdateManyWithWhereWithoutGruposInput[]
    deleteMany?: datasScalarWhereInput | datasScalarWhereInput[]
  }

  export type datasUncheckedUpdateManyWithoutGruposNestedInput = {
    create?: XOR<datasCreateWithoutGruposInput, datasUncheckedCreateWithoutGruposInput> | datasCreateWithoutGruposInput[] | datasUncheckedCreateWithoutGruposInput[]
    connectOrCreate?: datasCreateOrConnectWithoutGruposInput | datasCreateOrConnectWithoutGruposInput[]
    upsert?: datasUpsertWithWhereUniqueWithoutGruposInput | datasUpsertWithWhereUniqueWithoutGruposInput[]
    createMany?: datasCreateManyGruposInputEnvelope
    set?: datasWhereUniqueInput | datasWhereUniqueInput[]
    disconnect?: datasWhereUniqueInput | datasWhereUniqueInput[]
    delete?: datasWhereUniqueInput | datasWhereUniqueInput[]
    connect?: datasWhereUniqueInput | datasWhereUniqueInput[]
    update?: datasUpdateWithWhereUniqueWithoutGruposInput | datasUpdateWithWhereUniqueWithoutGruposInput[]
    updateMany?: datasUpdateManyWithWhereWithoutGruposInput | datasUpdateManyWithWhereWithoutGruposInput[]
    deleteMany?: datasScalarWhereInput | datasScalarWhereInput[]
  }

  export type gruposCreateNestedOneWithoutDatasInput = {
    create?: XOR<gruposCreateWithoutDatasInput, gruposUncheckedCreateWithoutDatasInput>
    connectOrCreate?: gruposCreateOrConnectWithoutDatasInput
    connect?: gruposWhereUniqueInput
  }

  export type EnumdiasFieldUpdateOperationsInput = {
    set?: $Enums.dias
  }

  export type gruposUpdateOneRequiredWithoutDatasNestedInput = {
    create?: XOR<gruposCreateWithoutDatasInput, gruposUncheckedCreateWithoutDatasInput>
    connectOrCreate?: gruposCreateOrConnectWithoutDatasInput
    upsert?: gruposUpsertWithoutDatasInput
    connect?: gruposWhereUniqueInput
    update?: XOR<XOR<gruposUpdateToOneWithWhereWithoutDatasInput, gruposUpdateWithoutDatasInput>, gruposUncheckedUpdateWithoutDatasInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumtipoFuncionalidadeFilter<$PrismaModel = never> = {
    equals?: $Enums.tipoFuncionalidade | EnumtipoFuncionalidadeFieldRefInput<$PrismaModel>
    in?: $Enums.tipoFuncionalidade[]
    notIn?: $Enums.tipoFuncionalidade[]
    not?: NestedEnumtipoFuncionalidadeFilter<$PrismaModel> | $Enums.tipoFuncionalidade
  }

  export type NestedEnumtipoPlanoFilter<$PrismaModel = never> = {
    equals?: $Enums.tipoPlano | EnumtipoPlanoFieldRefInput<$PrismaModel>
    in?: $Enums.tipoPlano[]
    notIn?: $Enums.tipoPlano[]
    not?: NestedEnumtipoPlanoFilter<$PrismaModel> | $Enums.tipoPlano
  }

  export type NestedEnumtipoFuncionalidadeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.tipoFuncionalidade | EnumtipoFuncionalidadeFieldRefInput<$PrismaModel>
    in?: $Enums.tipoFuncionalidade[]
    notIn?: $Enums.tipoFuncionalidade[]
    not?: NestedEnumtipoFuncionalidadeWithAggregatesFilter<$PrismaModel> | $Enums.tipoFuncionalidade
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtipoFuncionalidadeFilter<$PrismaModel>
    _max?: NestedEnumtipoFuncionalidadeFilter<$PrismaModel>
  }

  export type NestedEnumtipoPlanoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.tipoPlano | EnumtipoPlanoFieldRefInput<$PrismaModel>
    in?: $Enums.tipoPlano[]
    notIn?: $Enums.tipoPlano[]
    not?: NestedEnumtipoPlanoWithAggregatesFilter<$PrismaModel> | $Enums.tipoPlano
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtipoPlanoFilter<$PrismaModel>
    _max?: NestedEnumtipoPlanoFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumcontas_perfilFilter<$PrismaModel = never> = {
    equals?: $Enums.contas_perfil | Enumcontas_perfilFieldRefInput<$PrismaModel>
    in?: $Enums.contas_perfil[]
    notIn?: $Enums.contas_perfil[]
    not?: NestedEnumcontas_perfilFilter<$PrismaModel> | $Enums.contas_perfil
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumcontas_perfilWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.contas_perfil | Enumcontas_perfilFieldRefInput<$PrismaModel>
    in?: $Enums.contas_perfil[]
    notIn?: $Enums.contas_perfil[]
    not?: NestedEnumcontas_perfilWithAggregatesFilter<$PrismaModel> | $Enums.contas_perfil
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcontas_perfilFilter<$PrismaModel>
    _max?: NestedEnumcontas_perfilFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumdiasFilter<$PrismaModel = never> = {
    equals?: $Enums.dias | EnumdiasFieldRefInput<$PrismaModel>
    in?: $Enums.dias[]
    notIn?: $Enums.dias[]
    not?: NestedEnumdiasFilter<$PrismaModel> | $Enums.dias
  }

  export type NestedEnumdiasWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.dias | EnumdiasFieldRefInput<$PrismaModel>
    in?: $Enums.dias[]
    notIn?: $Enums.dias[]
    not?: NestedEnumdiasWithAggregatesFilter<$PrismaModel> | $Enums.dias
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumdiasFilter<$PrismaModel>
    _max?: NestedEnumdiasFilter<$PrismaModel>
  }

  export type planosCreateWithoutAssinaturaInput = {
    nome: string
    subtitulo: string
    descricao: string
    valorTotal: number
    tipoFuncionalidade: $Enums.tipoFuncionalidade
    tipo: $Enums.tipoPlano
    qtdePessoas: number
    meses: number
    maxSessoes: number
    grupos?: gruposCreateNestedManyWithoutPlanosInput
  }

  export type planosUncheckedCreateWithoutAssinaturaInput = {
    idPlanos?: number
    nome: string
    subtitulo: string
    descricao: string
    valorTotal: number
    tipoFuncionalidade: $Enums.tipoFuncionalidade
    tipo: $Enums.tipoPlano
    qtdePessoas: number
    meses: number
    maxSessoes: number
    grupos?: gruposUncheckedCreateNestedManyWithoutPlanosInput
  }

  export type planosCreateOrConnectWithoutAssinaturaInput = {
    where: planosWhereUniqueInput
    create: XOR<planosCreateWithoutAssinaturaInput, planosUncheckedCreateWithoutAssinaturaInput>
  }

  export type contasCreateWithoutAssinaturasInput = {
    nome: string
    data_nasc: Date | string
    foto?: string | null
    celular: string
    fagerstrom?: boolean
    perfil: $Enums.contas_perfil
    autenticacao?: autenticacaoCreateNestedManyWithoutContaInput
    historicoPagamento?: historicoPagamentoCreateNestedManyWithoutContasInput
    questionario?: questionarioCreateNestedOneWithoutContasInput
  }

  export type contasUncheckedCreateWithoutAssinaturasInput = {
    idConta?: number
    nome: string
    data_nasc: Date | string
    foto?: string | null
    celular: string
    fagerstrom?: boolean
    perfil: $Enums.contas_perfil
    idQuestionario?: number | null
    autenticacao?: autenticacaoUncheckedCreateNestedManyWithoutContaInput
    historicoPagamento?: historicoPagamentoUncheckedCreateNestedManyWithoutContasInput
  }

  export type contasCreateOrConnectWithoutAssinaturasInput = {
    where: contasWhereUniqueInput
    create: XOR<contasCreateWithoutAssinaturasInput, contasUncheckedCreateWithoutAssinaturasInput>
  }

  export type planosUpsertWithoutAssinaturaInput = {
    update: XOR<planosUpdateWithoutAssinaturaInput, planosUncheckedUpdateWithoutAssinaturaInput>
    create: XOR<planosCreateWithoutAssinaturaInput, planosUncheckedCreateWithoutAssinaturaInput>
    where?: planosWhereInput
  }

  export type planosUpdateToOneWithWhereWithoutAssinaturaInput = {
    where?: planosWhereInput
    data: XOR<planosUpdateWithoutAssinaturaInput, planosUncheckedUpdateWithoutAssinaturaInput>
  }

  export type planosUpdateWithoutAssinaturaInput = {
    nome?: StringFieldUpdateOperationsInput | string
    subtitulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    valorTotal?: FloatFieldUpdateOperationsInput | number
    tipoFuncionalidade?: EnumtipoFuncionalidadeFieldUpdateOperationsInput | $Enums.tipoFuncionalidade
    tipo?: EnumtipoPlanoFieldUpdateOperationsInput | $Enums.tipoPlano
    qtdePessoas?: IntFieldUpdateOperationsInput | number
    meses?: IntFieldUpdateOperationsInput | number
    maxSessoes?: FloatFieldUpdateOperationsInput | number
    grupos?: gruposUpdateManyWithoutPlanosNestedInput
  }

  export type planosUncheckedUpdateWithoutAssinaturaInput = {
    idPlanos?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    subtitulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    valorTotal?: FloatFieldUpdateOperationsInput | number
    tipoFuncionalidade?: EnumtipoFuncionalidadeFieldUpdateOperationsInput | $Enums.tipoFuncionalidade
    tipo?: EnumtipoPlanoFieldUpdateOperationsInput | $Enums.tipoPlano
    qtdePessoas?: IntFieldUpdateOperationsInput | number
    meses?: IntFieldUpdateOperationsInput | number
    maxSessoes?: FloatFieldUpdateOperationsInput | number
    grupos?: gruposUncheckedUpdateManyWithoutPlanosNestedInput
  }

  export type contasUpsertWithoutAssinaturasInput = {
    update: XOR<contasUpdateWithoutAssinaturasInput, contasUncheckedUpdateWithoutAssinaturasInput>
    create: XOR<contasCreateWithoutAssinaturasInput, contasUncheckedCreateWithoutAssinaturasInput>
    where?: contasWhereInput
  }

  export type contasUpdateToOneWithWhereWithoutAssinaturasInput = {
    where?: contasWhereInput
    data: XOR<contasUpdateWithoutAssinaturasInput, contasUncheckedUpdateWithoutAssinaturasInput>
  }

  export type contasUpdateWithoutAssinaturasInput = {
    nome?: StringFieldUpdateOperationsInput | string
    data_nasc?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: StringFieldUpdateOperationsInput | string
    fagerstrom?: BoolFieldUpdateOperationsInput | boolean
    perfil?: Enumcontas_perfilFieldUpdateOperationsInput | $Enums.contas_perfil
    autenticacao?: autenticacaoUpdateManyWithoutContaNestedInput
    historicoPagamento?: historicoPagamentoUpdateManyWithoutContasNestedInput
    questionario?: questionarioUpdateOneWithoutContasNestedInput
  }

  export type contasUncheckedUpdateWithoutAssinaturasInput = {
    idConta?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    data_nasc?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: StringFieldUpdateOperationsInput | string
    fagerstrom?: BoolFieldUpdateOperationsInput | boolean
    perfil?: Enumcontas_perfilFieldUpdateOperationsInput | $Enums.contas_perfil
    idQuestionario?: NullableIntFieldUpdateOperationsInput | number | null
    autenticacao?: autenticacaoUncheckedUpdateManyWithoutContaNestedInput
    historicoPagamento?: historicoPagamentoUncheckedUpdateManyWithoutContasNestedInput
  }

  export type contasCreateWithoutHistoricoPagamentoInput = {
    nome: string
    data_nasc: Date | string
    foto?: string | null
    celular: string
    fagerstrom?: boolean
    perfil: $Enums.contas_perfil
    autenticacao?: autenticacaoCreateNestedManyWithoutContaInput
    assinaturas?: assinaturaCreateNestedManyWithoutContasInput
    questionario?: questionarioCreateNestedOneWithoutContasInput
  }

  export type contasUncheckedCreateWithoutHistoricoPagamentoInput = {
    idConta?: number
    nome: string
    data_nasc: Date | string
    foto?: string | null
    celular: string
    fagerstrom?: boolean
    perfil: $Enums.contas_perfil
    idQuestionario?: number | null
    autenticacao?: autenticacaoUncheckedCreateNestedManyWithoutContaInput
    assinaturas?: assinaturaUncheckedCreateNestedManyWithoutContasInput
  }

  export type contasCreateOrConnectWithoutHistoricoPagamentoInput = {
    where: contasWhereUniqueInput
    create: XOR<contasCreateWithoutHistoricoPagamentoInput, contasUncheckedCreateWithoutHistoricoPagamentoInput>
  }

  export type contasUpsertWithoutHistoricoPagamentoInput = {
    update: XOR<contasUpdateWithoutHistoricoPagamentoInput, contasUncheckedUpdateWithoutHistoricoPagamentoInput>
    create: XOR<contasCreateWithoutHistoricoPagamentoInput, contasUncheckedCreateWithoutHistoricoPagamentoInput>
    where?: contasWhereInput
  }

  export type contasUpdateToOneWithWhereWithoutHistoricoPagamentoInput = {
    where?: contasWhereInput
    data: XOR<contasUpdateWithoutHistoricoPagamentoInput, contasUncheckedUpdateWithoutHistoricoPagamentoInput>
  }

  export type contasUpdateWithoutHistoricoPagamentoInput = {
    nome?: StringFieldUpdateOperationsInput | string
    data_nasc?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: StringFieldUpdateOperationsInput | string
    fagerstrom?: BoolFieldUpdateOperationsInput | boolean
    perfil?: Enumcontas_perfilFieldUpdateOperationsInput | $Enums.contas_perfil
    autenticacao?: autenticacaoUpdateManyWithoutContaNestedInput
    assinaturas?: assinaturaUpdateManyWithoutContasNestedInput
    questionario?: questionarioUpdateOneWithoutContasNestedInput
  }

  export type contasUncheckedUpdateWithoutHistoricoPagamentoInput = {
    idConta?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    data_nasc?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: StringFieldUpdateOperationsInput | string
    fagerstrom?: BoolFieldUpdateOperationsInput | boolean
    perfil?: Enumcontas_perfilFieldUpdateOperationsInput | $Enums.contas_perfil
    idQuestionario?: NullableIntFieldUpdateOperationsInput | number | null
    autenticacao?: autenticacaoUncheckedUpdateManyWithoutContaNestedInput
    assinaturas?: assinaturaUncheckedUpdateManyWithoutContasNestedInput
  }

  export type assinaturaCreateWithoutPlanosInput = {
    codPagamento?: string | null
    ativo?: boolean | null
    data_inicio?: Date | string | null
    ultimo_update?: Date | string | null
    contas: contasCreateNestedOneWithoutAssinaturasInput
  }

  export type assinaturaUncheckedCreateWithoutPlanosInput = {
    idAssinatura?: number
    codPagamento?: string | null
    ativo?: boolean | null
    data_inicio?: Date | string | null
    ultimo_update?: Date | string | null
    idConta: number
  }

  export type assinaturaCreateOrConnectWithoutPlanosInput = {
    where: assinaturaWhereUniqueInput
    create: XOR<assinaturaCreateWithoutPlanosInput, assinaturaUncheckedCreateWithoutPlanosInput>
  }

  export type assinaturaCreateManyPlanosInputEnvelope = {
    data: assinaturaCreateManyPlanosInput | assinaturaCreateManyPlanosInput[]
    skipDuplicates?: boolean
  }

  export type gruposCreateWithoutPlanosInput = {
    dataInicio: Date | string
    dataFinal: Date | string
    link?: string | null
    datas?: datasCreateNestedManyWithoutGruposInput
  }

  export type gruposUncheckedCreateWithoutPlanosInput = {
    idGrupo?: number
    dataInicio: Date | string
    dataFinal: Date | string
    link?: string | null
    datas?: datasUncheckedCreateNestedManyWithoutGruposInput
  }

  export type gruposCreateOrConnectWithoutPlanosInput = {
    where: gruposWhereUniqueInput
    create: XOR<gruposCreateWithoutPlanosInput, gruposUncheckedCreateWithoutPlanosInput>
  }

  export type gruposCreateManyPlanosInputEnvelope = {
    data: gruposCreateManyPlanosInput | gruposCreateManyPlanosInput[]
    skipDuplicates?: boolean
  }

  export type assinaturaUpsertWithWhereUniqueWithoutPlanosInput = {
    where: assinaturaWhereUniqueInput
    update: XOR<assinaturaUpdateWithoutPlanosInput, assinaturaUncheckedUpdateWithoutPlanosInput>
    create: XOR<assinaturaCreateWithoutPlanosInput, assinaturaUncheckedCreateWithoutPlanosInput>
  }

  export type assinaturaUpdateWithWhereUniqueWithoutPlanosInput = {
    where: assinaturaWhereUniqueInput
    data: XOR<assinaturaUpdateWithoutPlanosInput, assinaturaUncheckedUpdateWithoutPlanosInput>
  }

  export type assinaturaUpdateManyWithWhereWithoutPlanosInput = {
    where: assinaturaScalarWhereInput
    data: XOR<assinaturaUpdateManyMutationInput, assinaturaUncheckedUpdateManyWithoutPlanosInput>
  }

  export type assinaturaScalarWhereInput = {
    AND?: assinaturaScalarWhereInput | assinaturaScalarWhereInput[]
    OR?: assinaturaScalarWhereInput[]
    NOT?: assinaturaScalarWhereInput | assinaturaScalarWhereInput[]
    idAssinatura?: IntFilter<"assinatura"> | number
    codPagamento?: StringNullableFilter<"assinatura"> | string | null
    ativo?: BoolNullableFilter<"assinatura"> | boolean | null
    data_inicio?: DateTimeNullableFilter<"assinatura"> | Date | string | null
    ultimo_update?: DateTimeNullableFilter<"assinatura"> | Date | string | null
    idPlanos?: IntFilter<"assinatura"> | number
    idConta?: IntFilter<"assinatura"> | number
  }

  export type gruposUpsertWithWhereUniqueWithoutPlanosInput = {
    where: gruposWhereUniqueInput
    update: XOR<gruposUpdateWithoutPlanosInput, gruposUncheckedUpdateWithoutPlanosInput>
    create: XOR<gruposCreateWithoutPlanosInput, gruposUncheckedCreateWithoutPlanosInput>
  }

  export type gruposUpdateWithWhereUniqueWithoutPlanosInput = {
    where: gruposWhereUniqueInput
    data: XOR<gruposUpdateWithoutPlanosInput, gruposUncheckedUpdateWithoutPlanosInput>
  }

  export type gruposUpdateManyWithWhereWithoutPlanosInput = {
    where: gruposScalarWhereInput
    data: XOR<gruposUpdateManyMutationInput, gruposUncheckedUpdateManyWithoutPlanosInput>
  }

  export type gruposScalarWhereInput = {
    AND?: gruposScalarWhereInput | gruposScalarWhereInput[]
    OR?: gruposScalarWhereInput[]
    NOT?: gruposScalarWhereInput | gruposScalarWhereInput[]
    idGrupo?: IntFilter<"grupos"> | number
    dataInicio?: DateTimeFilter<"grupos"> | Date | string
    dataFinal?: DateTimeFilter<"grupos"> | Date | string
    link?: StringNullableFilter<"grupos"> | string | null
    idPlanos?: IntFilter<"grupos"> | number
  }

  export type contasCreateWithoutAutenticacaoInput = {
    nome: string
    data_nasc: Date | string
    foto?: string | null
    celular: string
    fagerstrom?: boolean
    perfil: $Enums.contas_perfil
    historicoPagamento?: historicoPagamentoCreateNestedManyWithoutContasInput
    assinaturas?: assinaturaCreateNestedManyWithoutContasInput
    questionario?: questionarioCreateNestedOneWithoutContasInput
  }

  export type contasUncheckedCreateWithoutAutenticacaoInput = {
    idConta?: number
    nome: string
    data_nasc: Date | string
    foto?: string | null
    celular: string
    fagerstrom?: boolean
    perfil: $Enums.contas_perfil
    idQuestionario?: number | null
    historicoPagamento?: historicoPagamentoUncheckedCreateNestedManyWithoutContasInput
    assinaturas?: assinaturaUncheckedCreateNestedManyWithoutContasInput
  }

  export type contasCreateOrConnectWithoutAutenticacaoInput = {
    where: contasWhereUniqueInput
    create: XOR<contasCreateWithoutAutenticacaoInput, contasUncheckedCreateWithoutAutenticacaoInput>
  }

  export type contasUpsertWithoutAutenticacaoInput = {
    update: XOR<contasUpdateWithoutAutenticacaoInput, contasUncheckedUpdateWithoutAutenticacaoInput>
    create: XOR<contasCreateWithoutAutenticacaoInput, contasUncheckedCreateWithoutAutenticacaoInput>
    where?: contasWhereInput
  }

  export type contasUpdateToOneWithWhereWithoutAutenticacaoInput = {
    where?: contasWhereInput
    data: XOR<contasUpdateWithoutAutenticacaoInput, contasUncheckedUpdateWithoutAutenticacaoInput>
  }

  export type contasUpdateWithoutAutenticacaoInput = {
    nome?: StringFieldUpdateOperationsInput | string
    data_nasc?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: StringFieldUpdateOperationsInput | string
    fagerstrom?: BoolFieldUpdateOperationsInput | boolean
    perfil?: Enumcontas_perfilFieldUpdateOperationsInput | $Enums.contas_perfil
    historicoPagamento?: historicoPagamentoUpdateManyWithoutContasNestedInput
    assinaturas?: assinaturaUpdateManyWithoutContasNestedInput
    questionario?: questionarioUpdateOneWithoutContasNestedInput
  }

  export type contasUncheckedUpdateWithoutAutenticacaoInput = {
    idConta?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    data_nasc?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: StringFieldUpdateOperationsInput | string
    fagerstrom?: BoolFieldUpdateOperationsInput | boolean
    perfil?: Enumcontas_perfilFieldUpdateOperationsInput | $Enums.contas_perfil
    idQuestionario?: NullableIntFieldUpdateOperationsInput | number | null
    historicoPagamento?: historicoPagamentoUncheckedUpdateManyWithoutContasNestedInput
    assinaturas?: assinaturaUncheckedUpdateManyWithoutContasNestedInput
  }

  export type autenticacaoCreateWithoutContaInput = {
    email: string
    senha: string
  }

  export type autenticacaoUncheckedCreateWithoutContaInput = {
    idAutenticacao?: number
    email: string
    senha: string
  }

  export type autenticacaoCreateOrConnectWithoutContaInput = {
    where: autenticacaoWhereUniqueInput
    create: XOR<autenticacaoCreateWithoutContaInput, autenticacaoUncheckedCreateWithoutContaInput>
  }

  export type autenticacaoCreateManyContaInputEnvelope = {
    data: autenticacaoCreateManyContaInput | autenticacaoCreateManyContaInput[]
    skipDuplicates?: boolean
  }

  export type historicoPagamentoCreateWithoutContasInput = {
    nome: string
    descricao: string
    pago: boolean
    valorTotal: number
    data_inicio?: Date | string | null
  }

  export type historicoPagamentoUncheckedCreateWithoutContasInput = {
    idHistoricoPagamento?: number
    nome: string
    descricao: string
    pago: boolean
    valorTotal: number
    data_inicio?: Date | string | null
  }

  export type historicoPagamentoCreateOrConnectWithoutContasInput = {
    where: historicoPagamentoWhereUniqueInput
    create: XOR<historicoPagamentoCreateWithoutContasInput, historicoPagamentoUncheckedCreateWithoutContasInput>
  }

  export type historicoPagamentoCreateManyContasInputEnvelope = {
    data: historicoPagamentoCreateManyContasInput | historicoPagamentoCreateManyContasInput[]
    skipDuplicates?: boolean
  }

  export type assinaturaCreateWithoutContasInput = {
    codPagamento?: string | null
    ativo?: boolean | null
    data_inicio?: Date | string | null
    ultimo_update?: Date | string | null
    planos: planosCreateNestedOneWithoutAssinaturaInput
  }

  export type assinaturaUncheckedCreateWithoutContasInput = {
    idAssinatura?: number
    codPagamento?: string | null
    ativo?: boolean | null
    data_inicio?: Date | string | null
    ultimo_update?: Date | string | null
    idPlanos: number
  }

  export type assinaturaCreateOrConnectWithoutContasInput = {
    where: assinaturaWhereUniqueInput
    create: XOR<assinaturaCreateWithoutContasInput, assinaturaUncheckedCreateWithoutContasInput>
  }

  export type assinaturaCreateManyContasInputEnvelope = {
    data: assinaturaCreateManyContasInput | assinaturaCreateManyContasInput[]
    skipDuplicates?: boolean
  }

  export type questionarioCreateWithoutContasInput = {
    questao1?: string | null
    questao2?: string | null
    questao3?: string | null
    questao4?: string | null
    questao5?: string | null
    questao6?: string | null
  }

  export type questionarioUncheckedCreateWithoutContasInput = {
    idQuestionario?: number
    questao1?: string | null
    questao2?: string | null
    questao3?: string | null
    questao4?: string | null
    questao5?: string | null
    questao6?: string | null
  }

  export type questionarioCreateOrConnectWithoutContasInput = {
    where: questionarioWhereUniqueInput
    create: XOR<questionarioCreateWithoutContasInput, questionarioUncheckedCreateWithoutContasInput>
  }

  export type autenticacaoUpsertWithWhereUniqueWithoutContaInput = {
    where: autenticacaoWhereUniqueInput
    update: XOR<autenticacaoUpdateWithoutContaInput, autenticacaoUncheckedUpdateWithoutContaInput>
    create: XOR<autenticacaoCreateWithoutContaInput, autenticacaoUncheckedCreateWithoutContaInput>
  }

  export type autenticacaoUpdateWithWhereUniqueWithoutContaInput = {
    where: autenticacaoWhereUniqueInput
    data: XOR<autenticacaoUpdateWithoutContaInput, autenticacaoUncheckedUpdateWithoutContaInput>
  }

  export type autenticacaoUpdateManyWithWhereWithoutContaInput = {
    where: autenticacaoScalarWhereInput
    data: XOR<autenticacaoUpdateManyMutationInput, autenticacaoUncheckedUpdateManyWithoutContaInput>
  }

  export type autenticacaoScalarWhereInput = {
    AND?: autenticacaoScalarWhereInput | autenticacaoScalarWhereInput[]
    OR?: autenticacaoScalarWhereInput[]
    NOT?: autenticacaoScalarWhereInput | autenticacaoScalarWhereInput[]
    idAutenticacao?: IntFilter<"autenticacao"> | number
    email?: StringFilter<"autenticacao"> | string
    senha?: StringFilter<"autenticacao"> | string
    idConta?: IntFilter<"autenticacao"> | number
  }

  export type historicoPagamentoUpsertWithWhereUniqueWithoutContasInput = {
    where: historicoPagamentoWhereUniqueInput
    update: XOR<historicoPagamentoUpdateWithoutContasInput, historicoPagamentoUncheckedUpdateWithoutContasInput>
    create: XOR<historicoPagamentoCreateWithoutContasInput, historicoPagamentoUncheckedCreateWithoutContasInput>
  }

  export type historicoPagamentoUpdateWithWhereUniqueWithoutContasInput = {
    where: historicoPagamentoWhereUniqueInput
    data: XOR<historicoPagamentoUpdateWithoutContasInput, historicoPagamentoUncheckedUpdateWithoutContasInput>
  }

  export type historicoPagamentoUpdateManyWithWhereWithoutContasInput = {
    where: historicoPagamentoScalarWhereInput
    data: XOR<historicoPagamentoUpdateManyMutationInput, historicoPagamentoUncheckedUpdateManyWithoutContasInput>
  }

  export type historicoPagamentoScalarWhereInput = {
    AND?: historicoPagamentoScalarWhereInput | historicoPagamentoScalarWhereInput[]
    OR?: historicoPagamentoScalarWhereInput[]
    NOT?: historicoPagamentoScalarWhereInput | historicoPagamentoScalarWhereInput[]
    idHistoricoPagamento?: IntFilter<"historicoPagamento"> | number
    nome?: StringFilter<"historicoPagamento"> | string
    descricao?: StringFilter<"historicoPagamento"> | string
    pago?: BoolFilter<"historicoPagamento"> | boolean
    valorTotal?: FloatFilter<"historicoPagamento"> | number
    data_inicio?: DateTimeNullableFilter<"historicoPagamento"> | Date | string | null
    idConta?: IntFilter<"historicoPagamento"> | number
  }

  export type assinaturaUpsertWithWhereUniqueWithoutContasInput = {
    where: assinaturaWhereUniqueInput
    update: XOR<assinaturaUpdateWithoutContasInput, assinaturaUncheckedUpdateWithoutContasInput>
    create: XOR<assinaturaCreateWithoutContasInput, assinaturaUncheckedCreateWithoutContasInput>
  }

  export type assinaturaUpdateWithWhereUniqueWithoutContasInput = {
    where: assinaturaWhereUniqueInput
    data: XOR<assinaturaUpdateWithoutContasInput, assinaturaUncheckedUpdateWithoutContasInput>
  }

  export type assinaturaUpdateManyWithWhereWithoutContasInput = {
    where: assinaturaScalarWhereInput
    data: XOR<assinaturaUpdateManyMutationInput, assinaturaUncheckedUpdateManyWithoutContasInput>
  }

  export type questionarioUpsertWithoutContasInput = {
    update: XOR<questionarioUpdateWithoutContasInput, questionarioUncheckedUpdateWithoutContasInput>
    create: XOR<questionarioCreateWithoutContasInput, questionarioUncheckedCreateWithoutContasInput>
    where?: questionarioWhereInput
  }

  export type questionarioUpdateToOneWithWhereWithoutContasInput = {
    where?: questionarioWhereInput
    data: XOR<questionarioUpdateWithoutContasInput, questionarioUncheckedUpdateWithoutContasInput>
  }

  export type questionarioUpdateWithoutContasInput = {
    questao1?: NullableStringFieldUpdateOperationsInput | string | null
    questao2?: NullableStringFieldUpdateOperationsInput | string | null
    questao3?: NullableStringFieldUpdateOperationsInput | string | null
    questao4?: NullableStringFieldUpdateOperationsInput | string | null
    questao5?: NullableStringFieldUpdateOperationsInput | string | null
    questao6?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type questionarioUncheckedUpdateWithoutContasInput = {
    idQuestionario?: IntFieldUpdateOperationsInput | number
    questao1?: NullableStringFieldUpdateOperationsInput | string | null
    questao2?: NullableStringFieldUpdateOperationsInput | string | null
    questao3?: NullableStringFieldUpdateOperationsInput | string | null
    questao4?: NullableStringFieldUpdateOperationsInput | string | null
    questao5?: NullableStringFieldUpdateOperationsInput | string | null
    questao6?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type contasCreateWithoutQuestionarioInput = {
    nome: string
    data_nasc: Date | string
    foto?: string | null
    celular: string
    fagerstrom?: boolean
    perfil: $Enums.contas_perfil
    autenticacao?: autenticacaoCreateNestedManyWithoutContaInput
    historicoPagamento?: historicoPagamentoCreateNestedManyWithoutContasInput
    assinaturas?: assinaturaCreateNestedManyWithoutContasInput
  }

  export type contasUncheckedCreateWithoutQuestionarioInput = {
    idConta?: number
    nome: string
    data_nasc: Date | string
    foto?: string | null
    celular: string
    fagerstrom?: boolean
    perfil: $Enums.contas_perfil
    autenticacao?: autenticacaoUncheckedCreateNestedManyWithoutContaInput
    historicoPagamento?: historicoPagamentoUncheckedCreateNestedManyWithoutContasInput
    assinaturas?: assinaturaUncheckedCreateNestedManyWithoutContasInput
  }

  export type contasCreateOrConnectWithoutQuestionarioInput = {
    where: contasWhereUniqueInput
    create: XOR<contasCreateWithoutQuestionarioInput, contasUncheckedCreateWithoutQuestionarioInput>
  }

  export type contasCreateManyQuestionarioInputEnvelope = {
    data: contasCreateManyQuestionarioInput | contasCreateManyQuestionarioInput[]
    skipDuplicates?: boolean
  }

  export type contasUpsertWithWhereUniqueWithoutQuestionarioInput = {
    where: contasWhereUniqueInput
    update: XOR<contasUpdateWithoutQuestionarioInput, contasUncheckedUpdateWithoutQuestionarioInput>
    create: XOR<contasCreateWithoutQuestionarioInput, contasUncheckedCreateWithoutQuestionarioInput>
  }

  export type contasUpdateWithWhereUniqueWithoutQuestionarioInput = {
    where: contasWhereUniqueInput
    data: XOR<contasUpdateWithoutQuestionarioInput, contasUncheckedUpdateWithoutQuestionarioInput>
  }

  export type contasUpdateManyWithWhereWithoutQuestionarioInput = {
    where: contasScalarWhereInput
    data: XOR<contasUpdateManyMutationInput, contasUncheckedUpdateManyWithoutQuestionarioInput>
  }

  export type contasScalarWhereInput = {
    AND?: contasScalarWhereInput | contasScalarWhereInput[]
    OR?: contasScalarWhereInput[]
    NOT?: contasScalarWhereInput | contasScalarWhereInput[]
    idConta?: IntFilter<"contas"> | number
    nome?: StringFilter<"contas"> | string
    data_nasc?: DateTimeFilter<"contas"> | Date | string
    foto?: StringNullableFilter<"contas"> | string | null
    celular?: StringFilter<"contas"> | string
    fagerstrom?: BoolFilter<"contas"> | boolean
    perfil?: Enumcontas_perfilFilter<"contas"> | $Enums.contas_perfil
    idQuestionario?: IntNullableFilter<"contas"> | number | null
  }

  export type planosCreateWithoutGruposInput = {
    nome: string
    subtitulo: string
    descricao: string
    valorTotal: number
    tipoFuncionalidade: $Enums.tipoFuncionalidade
    tipo: $Enums.tipoPlano
    qtdePessoas: number
    meses: number
    maxSessoes: number
    assinatura?: assinaturaCreateNestedManyWithoutPlanosInput
  }

  export type planosUncheckedCreateWithoutGruposInput = {
    idPlanos?: number
    nome: string
    subtitulo: string
    descricao: string
    valorTotal: number
    tipoFuncionalidade: $Enums.tipoFuncionalidade
    tipo: $Enums.tipoPlano
    qtdePessoas: number
    meses: number
    maxSessoes: number
    assinatura?: assinaturaUncheckedCreateNestedManyWithoutPlanosInput
  }

  export type planosCreateOrConnectWithoutGruposInput = {
    where: planosWhereUniqueInput
    create: XOR<planosCreateWithoutGruposInput, planosUncheckedCreateWithoutGruposInput>
  }

  export type datasCreateWithoutGruposInput = {
    dia: $Enums.dias
    hora: string
  }

  export type datasUncheckedCreateWithoutGruposInput = {
    idData?: number
    dia: $Enums.dias
    hora: string
  }

  export type datasCreateOrConnectWithoutGruposInput = {
    where: datasWhereUniqueInput
    create: XOR<datasCreateWithoutGruposInput, datasUncheckedCreateWithoutGruposInput>
  }

  export type datasCreateManyGruposInputEnvelope = {
    data: datasCreateManyGruposInput | datasCreateManyGruposInput[]
    skipDuplicates?: boolean
  }

  export type planosUpsertWithoutGruposInput = {
    update: XOR<planosUpdateWithoutGruposInput, planosUncheckedUpdateWithoutGruposInput>
    create: XOR<planosCreateWithoutGruposInput, planosUncheckedCreateWithoutGruposInput>
    where?: planosWhereInput
  }

  export type planosUpdateToOneWithWhereWithoutGruposInput = {
    where?: planosWhereInput
    data: XOR<planosUpdateWithoutGruposInput, planosUncheckedUpdateWithoutGruposInput>
  }

  export type planosUpdateWithoutGruposInput = {
    nome?: StringFieldUpdateOperationsInput | string
    subtitulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    valorTotal?: FloatFieldUpdateOperationsInput | number
    tipoFuncionalidade?: EnumtipoFuncionalidadeFieldUpdateOperationsInput | $Enums.tipoFuncionalidade
    tipo?: EnumtipoPlanoFieldUpdateOperationsInput | $Enums.tipoPlano
    qtdePessoas?: IntFieldUpdateOperationsInput | number
    meses?: IntFieldUpdateOperationsInput | number
    maxSessoes?: FloatFieldUpdateOperationsInput | number
    assinatura?: assinaturaUpdateManyWithoutPlanosNestedInput
  }

  export type planosUncheckedUpdateWithoutGruposInput = {
    idPlanos?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    subtitulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    valorTotal?: FloatFieldUpdateOperationsInput | number
    tipoFuncionalidade?: EnumtipoFuncionalidadeFieldUpdateOperationsInput | $Enums.tipoFuncionalidade
    tipo?: EnumtipoPlanoFieldUpdateOperationsInput | $Enums.tipoPlano
    qtdePessoas?: IntFieldUpdateOperationsInput | number
    meses?: IntFieldUpdateOperationsInput | number
    maxSessoes?: FloatFieldUpdateOperationsInput | number
    assinatura?: assinaturaUncheckedUpdateManyWithoutPlanosNestedInput
  }

  export type datasUpsertWithWhereUniqueWithoutGruposInput = {
    where: datasWhereUniqueInput
    update: XOR<datasUpdateWithoutGruposInput, datasUncheckedUpdateWithoutGruposInput>
    create: XOR<datasCreateWithoutGruposInput, datasUncheckedCreateWithoutGruposInput>
  }

  export type datasUpdateWithWhereUniqueWithoutGruposInput = {
    where: datasWhereUniqueInput
    data: XOR<datasUpdateWithoutGruposInput, datasUncheckedUpdateWithoutGruposInput>
  }

  export type datasUpdateManyWithWhereWithoutGruposInput = {
    where: datasScalarWhereInput
    data: XOR<datasUpdateManyMutationInput, datasUncheckedUpdateManyWithoutGruposInput>
  }

  export type datasScalarWhereInput = {
    AND?: datasScalarWhereInput | datasScalarWhereInput[]
    OR?: datasScalarWhereInput[]
    NOT?: datasScalarWhereInput | datasScalarWhereInput[]
    idData?: IntFilter<"datas"> | number
    dia?: EnumdiasFilter<"datas"> | $Enums.dias
    hora?: StringFilter<"datas"> | string
    idGrupo?: IntFilter<"datas"> | number
  }

  export type gruposCreateWithoutDatasInput = {
    dataInicio: Date | string
    dataFinal: Date | string
    link?: string | null
    planos: planosCreateNestedOneWithoutGruposInput
  }

  export type gruposUncheckedCreateWithoutDatasInput = {
    idGrupo?: number
    dataInicio: Date | string
    dataFinal: Date | string
    link?: string | null
    idPlanos: number
  }

  export type gruposCreateOrConnectWithoutDatasInput = {
    where: gruposWhereUniqueInput
    create: XOR<gruposCreateWithoutDatasInput, gruposUncheckedCreateWithoutDatasInput>
  }

  export type gruposUpsertWithoutDatasInput = {
    update: XOR<gruposUpdateWithoutDatasInput, gruposUncheckedUpdateWithoutDatasInput>
    create: XOR<gruposCreateWithoutDatasInput, gruposUncheckedCreateWithoutDatasInput>
    where?: gruposWhereInput
  }

  export type gruposUpdateToOneWithWhereWithoutDatasInput = {
    where?: gruposWhereInput
    data: XOR<gruposUpdateWithoutDatasInput, gruposUncheckedUpdateWithoutDatasInput>
  }

  export type gruposUpdateWithoutDatasInput = {
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFinal?: DateTimeFieldUpdateOperationsInput | Date | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    planos?: planosUpdateOneRequiredWithoutGruposNestedInput
  }

  export type gruposUncheckedUpdateWithoutDatasInput = {
    idGrupo?: IntFieldUpdateOperationsInput | number
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFinal?: DateTimeFieldUpdateOperationsInput | Date | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    idPlanos?: IntFieldUpdateOperationsInput | number
  }

  export type assinaturaCreateManyPlanosInput = {
    idAssinatura?: number
    codPagamento?: string | null
    ativo?: boolean | null
    data_inicio?: Date | string | null
    ultimo_update?: Date | string | null
    idConta: number
  }

  export type gruposCreateManyPlanosInput = {
    idGrupo?: number
    dataInicio: Date | string
    dataFinal: Date | string
    link?: string | null
  }

  export type assinaturaUpdateWithoutPlanosInput = {
    codPagamento?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    data_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimo_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contas?: contasUpdateOneRequiredWithoutAssinaturasNestedInput
  }

  export type assinaturaUncheckedUpdateWithoutPlanosInput = {
    idAssinatura?: IntFieldUpdateOperationsInput | number
    codPagamento?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    data_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimo_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idConta?: IntFieldUpdateOperationsInput | number
  }

  export type assinaturaUncheckedUpdateManyWithoutPlanosInput = {
    idAssinatura?: IntFieldUpdateOperationsInput | number
    codPagamento?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    data_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimo_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idConta?: IntFieldUpdateOperationsInput | number
  }

  export type gruposUpdateWithoutPlanosInput = {
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFinal?: DateTimeFieldUpdateOperationsInput | Date | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    datas?: datasUpdateManyWithoutGruposNestedInput
  }

  export type gruposUncheckedUpdateWithoutPlanosInput = {
    idGrupo?: IntFieldUpdateOperationsInput | number
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFinal?: DateTimeFieldUpdateOperationsInput | Date | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    datas?: datasUncheckedUpdateManyWithoutGruposNestedInput
  }

  export type gruposUncheckedUpdateManyWithoutPlanosInput = {
    idGrupo?: IntFieldUpdateOperationsInput | number
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFinal?: DateTimeFieldUpdateOperationsInput | Date | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autenticacaoCreateManyContaInput = {
    idAutenticacao?: number
    email: string
    senha: string
  }

  export type historicoPagamentoCreateManyContasInput = {
    idHistoricoPagamento?: number
    nome: string
    descricao: string
    pago: boolean
    valorTotal: number
    data_inicio?: Date | string | null
  }

  export type assinaturaCreateManyContasInput = {
    idAssinatura?: number
    codPagamento?: string | null
    ativo?: boolean | null
    data_inicio?: Date | string | null
    ultimo_update?: Date | string | null
    idPlanos: number
  }

  export type autenticacaoUpdateWithoutContaInput = {
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
  }

  export type autenticacaoUncheckedUpdateWithoutContaInput = {
    idAutenticacao?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
  }

  export type autenticacaoUncheckedUpdateManyWithoutContaInput = {
    idAutenticacao?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
  }

  export type historicoPagamentoUpdateWithoutContasInput = {
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    pago?: BoolFieldUpdateOperationsInput | boolean
    valorTotal?: FloatFieldUpdateOperationsInput | number
    data_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type historicoPagamentoUncheckedUpdateWithoutContasInput = {
    idHistoricoPagamento?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    pago?: BoolFieldUpdateOperationsInput | boolean
    valorTotal?: FloatFieldUpdateOperationsInput | number
    data_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type historicoPagamentoUncheckedUpdateManyWithoutContasInput = {
    idHistoricoPagamento?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    pago?: BoolFieldUpdateOperationsInput | boolean
    valorTotal?: FloatFieldUpdateOperationsInput | number
    data_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type assinaturaUpdateWithoutContasInput = {
    codPagamento?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    data_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimo_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planos?: planosUpdateOneRequiredWithoutAssinaturaNestedInput
  }

  export type assinaturaUncheckedUpdateWithoutContasInput = {
    idAssinatura?: IntFieldUpdateOperationsInput | number
    codPagamento?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    data_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimo_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idPlanos?: IntFieldUpdateOperationsInput | number
  }

  export type assinaturaUncheckedUpdateManyWithoutContasInput = {
    idAssinatura?: IntFieldUpdateOperationsInput | number
    codPagamento?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    data_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimo_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idPlanos?: IntFieldUpdateOperationsInput | number
  }

  export type contasCreateManyQuestionarioInput = {
    idConta?: number
    nome: string
    data_nasc: Date | string
    foto?: string | null
    celular: string
    fagerstrom?: boolean
    perfil: $Enums.contas_perfil
  }

  export type contasUpdateWithoutQuestionarioInput = {
    nome?: StringFieldUpdateOperationsInput | string
    data_nasc?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: StringFieldUpdateOperationsInput | string
    fagerstrom?: BoolFieldUpdateOperationsInput | boolean
    perfil?: Enumcontas_perfilFieldUpdateOperationsInput | $Enums.contas_perfil
    autenticacao?: autenticacaoUpdateManyWithoutContaNestedInput
    historicoPagamento?: historicoPagamentoUpdateManyWithoutContasNestedInput
    assinaturas?: assinaturaUpdateManyWithoutContasNestedInput
  }

  export type contasUncheckedUpdateWithoutQuestionarioInput = {
    idConta?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    data_nasc?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: StringFieldUpdateOperationsInput | string
    fagerstrom?: BoolFieldUpdateOperationsInput | boolean
    perfil?: Enumcontas_perfilFieldUpdateOperationsInput | $Enums.contas_perfil
    autenticacao?: autenticacaoUncheckedUpdateManyWithoutContaNestedInput
    historicoPagamento?: historicoPagamentoUncheckedUpdateManyWithoutContasNestedInput
    assinaturas?: assinaturaUncheckedUpdateManyWithoutContasNestedInput
  }

  export type contasUncheckedUpdateManyWithoutQuestionarioInput = {
    idConta?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    data_nasc?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: StringFieldUpdateOperationsInput | string
    fagerstrom?: BoolFieldUpdateOperationsInput | boolean
    perfil?: Enumcontas_perfilFieldUpdateOperationsInput | $Enums.contas_perfil
  }

  export type datasCreateManyGruposInput = {
    idData?: number
    dia: $Enums.dias
    hora: string
  }

  export type datasUpdateWithoutGruposInput = {
    dia?: EnumdiasFieldUpdateOperationsInput | $Enums.dias
    hora?: StringFieldUpdateOperationsInput | string
  }

  export type datasUncheckedUpdateWithoutGruposInput = {
    idData?: IntFieldUpdateOperationsInput | number
    dia?: EnumdiasFieldUpdateOperationsInput | $Enums.dias
    hora?: StringFieldUpdateOperationsInput | string
  }

  export type datasUncheckedUpdateManyWithoutGruposInput = {
    idData?: IntFieldUpdateOperationsInput | number
    dia?: EnumdiasFieldUpdateOperationsInput | $Enums.dias
    hora?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use PlanosCountOutputTypeDefaultArgs instead
     */
    export type PlanosCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlanosCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContasCountOutputTypeDefaultArgs instead
     */
    export type ContasCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContasCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestionarioCountOutputTypeDefaultArgs instead
     */
    export type QuestionarioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestionarioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GruposCountOutputTypeDefaultArgs instead
     */
    export type GruposCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GruposCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use assinaturaDefaultArgs instead
     */
    export type assinaturaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = assinaturaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use historicoPagamentoDefaultArgs instead
     */
    export type historicoPagamentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = historicoPagamentoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use planosDefaultArgs instead
     */
    export type planosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = planosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use autenticacaoDefaultArgs instead
     */
    export type autenticacaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = autenticacaoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use contasDefaultArgs instead
     */
    export type contasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = contasDefaultArgs<ExtArgs>
    /**
     * @deprecated Use questionarioDefaultArgs instead
     */
    export type questionarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = questionarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use geralDefaultArgs instead
     */
    export type geralArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = geralDefaultArgs<ExtArgs>
    /**
     * @deprecated Use gruposDefaultArgs instead
     */
    export type gruposArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = gruposDefaultArgs<ExtArgs>
    /**
     * @deprecated Use grupoContaDefaultArgs instead
     */
    export type grupoContaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = grupoContaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use datasDefaultArgs instead
     */
    export type datasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = datasDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}